# 代码整洁之道

## 3.1 短小

函数应该要短小。

作者在 Kent Beck 家中拜访的时候，看到了一个有趣的Swing程序（Swing 是一个为Java设计的GUI工具包），这个程序运行时会在鼠标的位置爆发出火花特效，然后火花就掉落在窗口底部。然后肯特给我看代码的时候，我对于代码中函数的小尺寸而惊讶，因为我看惯了Swing程序中一大串的函数。里面的函数只有三行左右长，每个函数都一目了然，而且每个函数都会依序把你带到下一个函数。

像 `if` 语句、`else` 语句或者 `while` 语句等，其中的代码块应该只有一行，不仅保持函数短小，也能易于阅读和理解。

## 3.2 只做一件事

函数应该做一件事。做好这件事。只做这一件事。

要判断函数是否不止做了一件事，就是看是否能再拆出一个函数，或者是否能切分出多个区段。

## 3.3 每个函数一个抽象层级

想要函数只有一个抽象层级需要让代码拥有自顶向下的阅读顺序。这个规则也称为向下规则。

最开头：

+ **要容纳设置步骤**
+ 纳入测试页面内容
+ 纳入分拆步骤

然后对 **容纳设置步骤** 进行拆解

+ 要容纳设置步骤
  + 如果是套件，就纳入 **套件设置步骤**
  + 然后再纳入普通设置步骤

然后对 **套件设置步骤** 进行拆解

+ 要容纳套件设置步骤
  + 先搜索 “SuiteSetup” 页面的上级继承关系
  + 再添加一个包括该页面路径的语句

## 3.4 switch语句

这是一段代码

```java
public Money calculatePay(Employee e) throws InvalidEmployeeType{
    switch (e.type) {
        case COMMISSIONED:
            return calculateCommissionedPay(e);
        case HOURLY:
            return calculateCommissionedPay(e);
        case SALARIED:
            return calculateCommissionedPay(e);
        // 如果要添加新的类型
        // case xxxxxx:
        //   return 
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```

该代码有几个问题：

+ 当雇员类型增多时，`switch` 的长度会变得更长
+ 违反了单一权责原则（如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责），例如当某个类型改变了，需要改变 `case` 的判断条件。
+ 违反了开放闭合原则（软件实体应该是可扩展，而不可修改的）。每次新增类型时，就必须到函数里修改
+ 

## 3.5 使用描述性的名称

+ 函数名称需要具有描述性
+ 别害怕长名称
+ 命名方式要保持一直

## 3.6 函数参数

最理想的参数数量时零，其次是一，再次是二，应尽量避免三。

### 3.6.1 一元函数

+ 向函数传入单个参数有两种极普遍的理由
  + 处理参数：传入一个参数，然后处理完成后，**返回一个参数**
  + 触发事件：传入一个参数，触发相对应的事件，**不返回参数**
+ 避免不编写除了上面两种的一元函数
+ 不要向函数传入布尔值

### 3.6.3 二元函数

+ 二元函数比一元函数更难懂，更不明了
+ 如果有自然的组合和自然的排序可以使用两元函数，例如用于表示一个点的 `x` 值和 `y`值
+ 如果没有自然顺序的二元函数，需要进一步的小心
+ 可以使用一些机制将二元函数转换成一元函数。例如将 `writeField(outputStream, name)` 转换成 `outputStream.writeField(name)`

### 3.6.4 三元函数

+ 三元函数里参数的排序、琢磨和忽略的问题都会加倍
+ 在写三元函数前一定要想清楚

### 3.6.5 参数对象

+ 如果函数看来需要两个、三个或者三个以上的参数，就说明其中一些参数应该封装为类。

### 3.6.6 参数列表

+ 如果使用可变变量，不变数量的参数最好少于等于两个

### 3.6.7 动词与关键词

+ 对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。例如 `write(name)` ，我们不知道 `name` 是什么，如果写成 `writeField(name)` ，我们就知道 `name` 是个 `Field`
+ 如果能把参数名称编码成了函数名。例如 `assertEqual` 改成 `assertExpectedEqualsActual(expected, actual)` ，就很明显知道第一个参数是 `Expected` ，第二个参数是 `actual`

## 3.7 无副作用

+ 在函数调用时，不要更改当前系统的状态。
+ 在面向对象编程中，函数尽量不要有输出值。

## 3.8 分隔指令与询问

+ 要把指令与询问分隔开来，例如判断后再处理，而不是处理完后再根据处理结果进行判断

## 3.9 使用异常替代返回错误码

+ 使用异常替代返回错误码有几个好处
  1. 不会导致更深层次的嵌套结果
  2. 错误处理代码可以从主路径代码中分离出来
  3. 错误码通常是某个类或者枚举，当修改时，导入和使用它的类都需要重新编译和部署，这就对Error类造成了负面压力
  4. 在使用 `Try/Catch` 代码块的时候可以从主体部分抽离出来
  5. 抽离出来后函数可以单独只处理错误这一件事

## 3.10 别重复自己

重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。

## 3.11 结构化编程

Dijkstra 认为，每个函数、函数中的每个代码块都应该有一个入口、一哥出口。

意味着在每个函数只该有一个 `return` 语句，循环中不能有 `break` 或者 `continue` 语句，不能有 `goto` 语句

## 15.1 Junit内幕

+ Junit 有个模块，这个模块是用来比较错误的一段代码。
+ 对于两个不同的字符串，它将用 `<` 和 `>` 指出不同的地方，例如 ABCDE 和 ABXDE ，它将输出 `<...B[X]D...>`

下面是一个使用 Junit 这个模块的测试方法

+ 方法名的意思是测试 `Message` 。而 `Message` 是 `compact` 方法的形参

```java
public void testMessage() {
  String failure = new ComparisonCompactor(0, "b", "c").compact("a");
  assertTrue("a expected:<[b]> but was:<[c]>".equals(failure));
}
```

然后去 Junit 源码里看下 `Message` 形参有什么用，下面是 `compact` 方法的源码

+ `fContextLength` 、 `fExpected` 和 `fActual` 是成员变量，此时分别为 `0` 、`"b"` 和 `"c"`
+ 先判断 `fExpected` 和 `fActual` 是否为 `null` ，然后判断 `fExpected` 和 `fActual` 是否一致，这些条件有一个符合，就调用 `Assert.format()` 方法
+  `Assert.format()` 方法传入了三个参数，使用这三个参数返回了指定格式的字符串，这时会返回 `a expected:<[b]> but was:<[c]>`

<img src="D:\GitCode\20230311\src\学习\读书笔记\1.png" style="zoom:33%;" />

```java
public String compact(String message) {
  if (fExpected == null || fActual == null || areStringsEqual()) {
      return Assert.format(message, fExpected, fActual);
  }

  findCommonPrefix();
  findCommonSuffix();
  String expected = compactString(fExpected);
  String actual = compactString(fActual);
  return Assert.format(message, expected, actual);
}
```

+ 然后执行了 `findCommonPrefix()` ，函数意思名为找出前缀，下面为源代码。
+ 主要作用是找出两个字符串中不同的地方的前一个下标。

```java
private void findCommonPrefix() {
  fPrefix = 0;
  // 找出第一个词和第二个词最小的长度，作为循环的次数
  int end = Math.min(fExpected.length(), fActual.length());
  for (; fPrefix < end; fPrefix++) {
    // 找到不同的地方退出循环，此时就是前缀下标
    if (fExpected.charAt(fPrefix) != fActual.charAt(fPrefix)) {
        break;
    }
  }
}
```

+ 然后继续执行了 `findCommonSuffix()` 方法，函数意思名为找出后缀，下面为源代码。
+ 主要作用是找出两个字符串中不同的地方的后一个下标。
+ 后缀比找前缀较麻烦点，找前缀时两个字符串都是下标从 0 开始，而找后缀需要从两个字符串的长度 - 1 开始。

```java
private void findCommonSuffix() {
  // 获取到两个比较字符串的长度
  int expectedSuffix = fExpected.length() - 1;
  int actualSuffix = fActual.length() - 1;
  // 当后缀不超过前缀时继续循环
  for (; actualSuffix >= fPrefix && expectedSuffix >= fPrefix; actualSuffix--, expectedSuffix--) {
    if (fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix)) {
        break;
    }
  }
  // 此时获取到的是尾部里不同地方的距离，
  // 需要将预期的字符串的长度减取距离才是需要的下标
  fSuffix = fExpected.length() - expectedSuffix;
}
```

+ 接着调用了 `compactString(fExpected)` 和 `compactString(fActual)` 
+ 下面为 `compactString` 方法的源码。主要作用是将不同的字符串用 `[]` 包含起来。然后又在前后分别拼接了 `computeCommonPrefix()` 和 `computeCommonSuffix()`

```java
private String compactString(String source) {
  // [ 不同的字符串 ]
  String result = DELTA_START + source.substring(fPrefix, source.length() - fSuffix + 1) + DELTA_END;
  if (fPrefix > 0) {
      result = computeCommonPrefix() + result;
  }
  if (fSuffix > 0) {
      result = result + computeCommonSuffix();
  }
  return result;
}
```

+ 下面是 `computeCommonPrefix()` 源码。主要作用是找出共同的前缀，然后根据 `fContextLength` 是否用省略号来省略前面的部分，然后取出剩余的前缀字符串，并拼接在一起。

```java
private String computeCommonPrefix() {
    return (fPrefix > fContextLength ? ELLIPSIS : "") + fExpected.substring(Math.max(0, fPrefix - fContextLength), fPrefix);
}
```

+ 后缀也是一样的原理，只是代码稍微有点复杂

```java
private String computeCommonSuffix() {
    int end = Math.min(fExpected.length() - fSuffix + 1 + fContextLength, fExpected.length());
    return fExpected.substring(fExpected.length() - fSuffix + 1, end) + (fExpected.length() - fSuffix + 1 < fExpected.length() - fContextLength ? ELLIPSIS : "");
}
```

源码就这里就完了，看下其他的测试代码。

+ 这里 `compact` 传入了 `null` ，所以 `expected` 前面没有任何标识
+ 然后在 `new ComparisonCompactor(2, "abcdde", "abcde")` 这里传入了 2 ，所以前面两个共同的字符用省略号表示了。

```java
public void testComparisonErrorOverlapingMatches2() {
    String failure = new ComparisonCompactor(2, "abcdde", "abcde").compact(null);
    assertEquals("expected:<...cd[d]e> but was:<...cd[]e>", failure);
}
```

---

但是这里的代码根据童子军军规，可以更整洁。

+ 在 `compact` 函数里条件判断可以封装

![image-20230910133946941](D:\GitCode\20230311\src\学习\读书笔记\image-20230910133946941.png)

+ 但否定式比肯定式难理解点，所以使用肯定式然后进行条件转换

![image-20230910141653803](D:\GitCode\20230311\src\学习\读书笔记\image-20230910141653803.png)

+ 定义的变量名和原本的成员变量名很相似，定义的变量名需要更有标识性

![image-20230910134447485](D:\GitCode\20230311\src\学习\读书笔记\image-20230910134447485.png)

+ 定义的函数名和实际做的内容不一致，`compact()` 函数不仅压缩了字符串，而且返回了格式化完成后的字符串

![image-20230910142027124](D:\GitCode\20230311\src\学习\读书笔记\image-20230910142027124.png)

+ 这几行代码主要做的是压缩，而当前的函数名已经改为格式化，和当前函数的目的不符，所以需要拆分为一个新的函数

![image-20230910142323459](D:\GitCode\20230311\src\学习\读书笔记\image-20230910142323459.png)

+ 这个函数里有操作行为不一致，有些函数有返回值，有些没有，需要改成都有返回值的函数。
+ 而且还需要修改成员变量的变量名，我们才知道成员变量是记录下标的，而原来的 `fPrefix` 和 `fSuffix` ，不知道里面存的是字符串还是下标

<img src="D:\GitCode\20230311\src\学习\读书笔记\image-20230910160247862.png" alt="image-20230910160247862" style="zoom:50%;" />

+ 两个函数并排调用没有突出时序性，可以改为在一个函数前面调用另一个函数

![image-20230910162325596](D:\GitCode\20230311\src\学习\读书笔记\image-20230910162325596.png)

+ `suffixIndex` 其实存放的是后缀的长度，且其变量是从 1 开始，所以可以将涉及到的函数转换一下

![image-20230910183833256](D:\GitCode\20230311\src\学习\读书笔记\image-20230910183833256.png)
