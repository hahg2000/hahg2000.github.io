import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as p,a,b as s,f as n}from"./app-Chw2KLnS.js";const o={},l=a("h1",{id:"第-14-章-monads",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#第-14-章-monads"},[a("span",null,"第 14 章：Monads")])],-1),c=a("hr",null,null,-1),i=a("p",null,[s("在 "),a("code",{class:"interpreted-text",role:"doc"},"7"),s(" 中，我们讨论了 "),a("code",null,"IO"),s(" monad，那时我们刻意把精力集中在如何与外界交互上，并没有讨论monad是什么。")],-1),r=a("p",null,[s("在 "),a("code",{class:"interpreted-text",role:"doc"},"7"),s(" 中我们看到 "),a("code",null,"IO"),s(" Monad确实很好用；除了在语法上不同之外，在 "),a("code",null,"IO"),s(" monad中写代码跟其他命令式语言基本没有什么区别。")],-1),d=a("p",null,"在前面的章节中，我们在解决一些实际问题的时候引入了一些数据结构，很快我们就会知道它们其实就是monads。我们想告诉你的是，在解决某些问题的时候，monad通常是一个非常直观且实用的工具。本章我们将定义一些monads并告诉你它有多么简单。",-1),k=a("h2",{id:"revisiting-earlier-code-examples",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#revisiting-earlier-code-examples"},[a("span",null,"回顾之前代码")])],-1),u=a("h3",{id:"maybe-chaining",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#maybe-chaining"},[a("span",null,"Maybe链")])],-1),v=a("p",null,[s("我们先看看我们在 "),a("code",{class:"interpreted-text",role:"doc"},"10"),s(" 写的 "),a("code",null,"parseP5"),s(" 函数:")],-1),h=n(`<div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch10/PNM.hs</span>
<span class="token hvariable">matchHeader</span> <span class="token operator">::</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span> <span class="token operator">-&gt;</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span>

<span class="token comment">-- &quot;nat&quot; here is short for &quot;natural number&quot;</span>
<span class="token hvariable">getNat</span> <span class="token operator">::</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span><span class="token punctuation">)</span>

<span class="token hvariable">getBytes</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span>
         <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">L<span class="token punctuation">.</span>ByteString</span><span class="token punctuation">,</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span><span class="token punctuation">)</span>

<span class="token hvariable">parseP5</span> <span class="token hvariable">s</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">matchHeader</span> <span class="token punctuation">(</span><span class="token constant">L8</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token string">&quot;P5&quot;</span><span class="token punctuation">)</span> <span class="token hvariable">s</span> <span class="token keyword">of</span>
    <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
    <span class="token constant">Just</span> <span class="token hvariable">s1</span> <span class="token operator">-&gt;</span>
      <span class="token keyword">case</span> <span class="token hvariable">getNat</span> <span class="token hvariable">s1</span> <span class="token keyword">of</span>
        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
        <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">width</span><span class="token punctuation">,</span> <span class="token hvariable">s2</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
          <span class="token keyword">case</span> <span class="token hvariable">getNat</span> <span class="token punctuation">(</span><span class="token constant">L8</span><span class="token punctuation">.</span><span class="token builtin">dropWhile</span> <span class="token builtin">isSpace</span> <span class="token hvariable">s2</span><span class="token punctuation">)</span> <span class="token keyword">of</span>
            <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
            <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">height</span><span class="token punctuation">,</span> <span class="token hvariable">s3</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
              <span class="token keyword">case</span> <span class="token hvariable">getNat</span> <span class="token punctuation">(</span><span class="token constant">L8</span><span class="token punctuation">.</span><span class="token builtin">dropWhile</span> <span class="token builtin">isSpace</span> <span class="token hvariable">s3</span><span class="token punctuation">)</span> <span class="token keyword">of</span>
                <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
                <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">maxGrey</span><span class="token punctuation">,</span> <span class="token hvariable">s4</span><span class="token punctuation">)</span>
                  <span class="token operator">|</span> <span class="token hvariable">maxGrey</span> <span class="token operator">&gt;</span> <span class="token number">255</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
                  <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span>
                      <span class="token keyword">case</span> <span class="token hvariable">getBytes</span> <span class="token number">1</span> <span class="token hvariable">s4</span> <span class="token keyword">of</span>
                        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
                        <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">s5</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
                          <span class="token keyword">case</span> <span class="token hvariable">getBytes</span> <span class="token punctuation">(</span><span class="token hvariable">width</span> <span class="token operator">*</span> <span class="token hvariable">height</span><span class="token punctuation">)</span> <span class="token hvariable">s5</span> <span class="token keyword">of</span>
                            <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
                            <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">bitmap</span><span class="token punctuation">,</span> <span class="token hvariable">s6</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
                              <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Greymap</span> <span class="token hvariable">width</span> <span class="token hvariable">height</span> <span class="token hvariable">maxGrey</span> <span class="token hvariable">bitmap</span><span class="token punctuation">,</span> <span class="token hvariable">s6</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数要是再复杂一点，就要超出屏幕的右边了；当时我们使用 <code>(&gt;&gt;?)</code> 操作符避免了这种情况:</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch10/PNM.hs</span>
<span class="token punctuation">(</span><span class="token operator">&gt;&gt;?</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span>
<span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;?</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
<span class="token constant">Just</span> <span class="token hvariable">v</span>  <span class="token operator">&gt;&gt;?</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们对 <code>(&gt;&gt;?)</code> 操作符的类型进行了精挑细选使得它能把一系列返回类型是 <code>Maybe</code> 的函数串联起来；只要一个函数的返回值能和下一个函数的参数类型匹配，我们就能无限串联返回类型是 <code>Maybe</code> 的函数。 <code>(&gt;&gt;?)</code> 的函数体把细节隐藏了起来，我们不知道我们通过 <code>(&gt;&gt;?)</code> 串联的函数是由于中间某个函数返回 <code>Nothing</code> 而中断了还是所有函数全部执行了。</p><h3 id="implicit-state" tabindex="-1"><a class="header-anchor" href="#implicit-state"><span>隐式状态</span></a></h3><p><code>(&gt;&gt;?)</code> 被用来整理 <code>parseP5</code> 的结构，但是在解析的时候我们还是要一点一点地处理输入字符串；这使得我们必须把当前处理的值通过一个元组传递下去[若干个函数串联了起来，都返回Maybe，作者称之为Maybe链]。Maybe链上的每一个函数把自己处理的结果以及自己没有解析的剩下的字符串放到元组里面，并传递下去。 :</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch10/PNM.hs</span>
<span class="token hvariable">parseP5_take2</span> <span class="token operator">::</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Greymap</span><span class="token punctuation">,</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span><span class="token punctuation">)</span>
<span class="token hvariable">parseP5_take2</span> <span class="token hvariable">s</span> <span class="token operator">=</span>
    <span class="token hvariable">matchHeader</span> <span class="token punctuation">(</span><span class="token constant">L8</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token string">&quot;P5&quot;</span><span class="token punctuation">)</span> <span class="token hvariable">s</span>       <span class="token operator">&gt;&gt;?</span>
    <span class="token operator">\\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token hvariable">skipSpace</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>           <span class="token operator">&gt;&gt;?</span>
    <span class="token punctuation">(</span><span class="token hvariable">getNat</span> <span class="token operator">.</span> <span class="token builtin">snd</span><span class="token punctuation">)</span>                    <span class="token operator">&gt;&gt;?</span>
    <span class="token hvariable">skipSpace</span>                         <span class="token operator">&gt;&gt;?</span>
    <span class="token operator">\\</span><span class="token punctuation">(</span><span class="token hvariable">width</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>   <span class="token hvariable">getNat</span> <span class="token hvariable">s</span>         <span class="token operator">&gt;&gt;?</span>
    <span class="token hvariable">skipSpace</span>                         <span class="token operator">&gt;&gt;?</span>
    <span class="token operator">\\</span><span class="token punctuation">(</span><span class="token hvariable">height</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>  <span class="token hvariable">getNat</span> <span class="token hvariable">s</span>         <span class="token operator">&gt;&gt;?</span>
    <span class="token operator">\\</span><span class="token punctuation">(</span><span class="token hvariable">maxGrey</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">getBytes</span> <span class="token number">1</span> <span class="token hvariable">s</span>     <span class="token operator">&gt;&gt;?</span>
    <span class="token punctuation">(</span><span class="token hvariable">getBytes</span> <span class="token punctuation">(</span><span class="token hvariable">width</span> <span class="token operator">*</span> <span class="token hvariable">height</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">snd</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;?</span>
    <span class="token operator">\\</span><span class="token punctuation">(</span><span class="token hvariable">bitmap</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Greymap</span> <span class="token hvariable">width</span> <span class="token hvariable">height</span> <span class="token hvariable">maxGrey</span> <span class="token hvariable">bitmap</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>

<span class="token hvariable">skipSpace</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">L<span class="token punctuation">.</span>ByteString</span><span class="token punctuation">)</span>
<span class="token hvariable">skipSpace</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">L8</span><span class="token punctuation">.</span><span class="token builtin">dropWhile</span> <span class="token builtin">isSpace</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们又碰到了有着重复行为的模式：处理字符串的时候，某个函数消耗部分字符串并返回它处理的结果，同时把剩下的字符串传递给下一个函数继续处理。但是，这个模式比之前的更糟糕：如果我们要在处理链往下传递另外一些额外信息，我们必须把传递的二元组修改为三元组，这几乎要修改这个处理链上的所有元素！</p><p>我们把管理当前字符串的任务从处理链上的单个函数移出来，将它(管理字符串)转交给串联这些单个函数的函数完成！[译：比如上面的 <code>(&gt;&gt;?)</code>]</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch10/Parse.hs</span>
<span class="token punctuation">(</span><span class="token operator">==&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Parse</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Parse</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Parse</span> <span class="token hvariable">b</span>

<span class="token hvariable">firstParser</span> <span class="token operator">==&gt;</span> <span class="token hvariable">secondParser</span>  <span class="token operator">=</span>  <span class="token constant">Parse</span> <span class="token hvariable">chainedParser</span>
  <span class="token keyword">where</span> <span class="token hvariable">chainedParser</span> <span class="token hvariable">initState</span>   <span class="token operator">=</span>
          <span class="token keyword">case</span> <span class="token hvariable">runParse</span> <span class="token hvariable">firstParser</span> <span class="token hvariable">initState</span> <span class="token keyword">of</span>
            <span class="token constant">Left</span> <span class="token hvariable">errMessage</span> <span class="token operator">-&gt;</span>
                <span class="token constant">Left</span> <span class="token hvariable">errMessage</span>
            <span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token hvariable">firstResult</span><span class="token punctuation">,</span> <span class="token hvariable">newState</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span>
                <span class="token hvariable">runParse</span> <span class="token punctuation">(</span><span class="token hvariable">secondParser</span> <span class="token hvariable">firstResult</span><span class="token punctuation">)</span> <span class="token hvariable">newState</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们把解析状态的细节隐藏在 <code>ParseState</code> 类型中，就连 <code>getState</code> 和 <code>putState</code> 都不会窥视解析状态，所以，无论对 <code>ParseState</code> 做怎样的修改都不会影响已有的代码。</p><h2 id="looking-for-shared-patterns" tabindex="-1"><a class="header-anchor" href="#looking-for-shared-patterns"><span>寻找共同特征</span></a></h2><p>如果我们仔细分析上面的例子，它们好像没有什么共同特点。不过有一点比较明显，它们都想把函数串联起来并试图隐藏细节以便我们写出整洁的代码。然后，我们先不管那些细节，从更粗略的层面去思考一下。</p><p>首先，我们看一看类型声明：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Maybe.hs</span>
<span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
             <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>

<span class="token comment">-- file: ch11/Parse.hs</span>
<span class="token keyword">newtype</span> <span class="token constant">Parse</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Parse</span> <span class="token punctuation">{</span>
      <span class="token hvariable">runParse</span> <span class="token operator">::</span> <span class="token constant">ParseState</span> <span class="token operator">-&gt;</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">ParseState</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个类型的共同特点是它们都有一个类型参数，因此它们都是范型，对具体的类型一无所知。</p><p>然后看一看我们给两个类型写的串联函数：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span>?<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span>?<span class="token punctuation">)</span> :: Maybe a -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> Maybe b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> Maybe b

ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">==</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> :: Parse a -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> Parse b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> Parse b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个函数的类型非常相似，如果我们把它们的类型构造器替换为一个类型变量，我们会得到一个更加抽象的类型。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Maybe.hs</span>
<span class="token hvariable">chain</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最终，在两种情况下，我们都得到了一个获取一个普通的值，然后把它&quot;注入&quot;到一个目标类型里面去的函数。对于 <code>Maybe</code> 类型，这个函数就是它的一个值构造器 <code>Just</code> ，<code>Parse</code>的注入函数就略微复杂一些。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch10/Parse.hs</span>
<span class="token hvariable">identity</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Parse</span> <span class="token hvariable">a</span>
<span class="token hvariable">identity</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Parse</span> <span class="token punctuation">(</span><span class="token operator">\\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们不用关心它的实现细节，也不管它有多么复杂；重要的是，这些类型都有一个&quot;注入器&quot;函数，它大致长这样：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Maybe.hs</span>
<span class="token hvariable">inject</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在Haskell里面，正是这三个属性和一些如何使用它们的规则定义了monad。我们集中总结一下：</p><ol><li>一个类型构造器 <code>m</code></li><li>一个用于把某个函数的输出串联到另外一个函数输入上的函数，它的类型是 <code>m a -&gt; (a -&gt; m b) -&gt; m b</code></li><li>一个类型是 <code>a -&gt; m a</code> 类型的函数，它把普通值注入到调用链里面，也就是说，它把类型 <code>a</code> 用类型构造器 <code>m</code> 包装起来。</li></ol><p>Maybe 类型的类型构造器 <code>Maybe a</code> ,串联函数 <code>(&gt;&gt;?)</code> 以及注入函数 <code>Just</code> 使Maybe成为一个monad。对于 <code>Parse</code> 类型，对应的是类型构造器 <code>Parse a</code> ，串联函数 <code>Parse a</code> 以及注入函数 <code>identify</code> 。</p><p>对于Monad的串联函数和注入函数具体应该干什么我们刻意只字未提，因为它几乎不重要。事实上，正是因为Monad如此简单，它在Haskell里面无处不在。许多常见的编程模式都用到了monad结构：传递隐式数据，或是短路求值链。</p><h2 id="the-monad-typeclass" tabindex="-1"><a class="header-anchor" href="#the-monad-typeclass"><span>Monad 类型类</span></a></h2><p>在 Haskell 里面我们可以使用一个类型类(typeclass)来表示&quot;串联&quot;以及&quot;注入&quot;的概念以及它们的类型。标准库的Predule模块已经包含了这样一个类型类，也就是 <code>Monad</code> 。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Maybe.hs</span>
<span class="token keyword">class</span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token comment">-- chain</span>
    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span>  <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
    <span class="token comment">-- inject</span>
    <span class="token builtin">return</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,31),b=a("p",null,[s("在这里，"),a("code",null,"(>>=)"),s(" 就是我们的串联函数。 在 "),a("code",{class:"interpreted-text",role:"ref"},"sequencing"),s(' 中我们已经介绍了它。通常将这个操作符称呼为"绑定"，因为它把左侧运算的结果绑定到右侧运算的参数上。')],-1),m=a("p",null,[s("我们的注入函数是 "),a("code",null,"return"),s(" ,在 "),a("code",{class:"interpreted-text",role:"ref"},"the-nature-of-return"),s(" 中讲过，选用 "),a("code",null,"return"),s(" 这个名字有点倒霉。这个关键字在命令式语言中被广泛使用并且有一个非常容易理解的含义。但是在Haskell里面它的含义完全不同；具体来说，在函数调用链中间使用 "),a("code",null,"return"),s(" 并不会导致调用链提前中止；我们可以这样理解它：它把纯值( "),a("code",null,"a"),s(" 类型)放进(returns)monads( "),a("code",null,"m a"),s(" 类型)里。")],-1),g=n(`<p><code>(&gt;&gt;=)</code> 和 <code>return</code> 是 <code>Monad</code> 这个类型类的核心函数；除此之外，它还定义了另外两个函数。一个函数是 <code>(&gt;&gt;)</code> ，类似于 <code>(&gt;&gt;=)</code> ，它的作用也是串联，但是它忽略左侧的值。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Maybe.hs</span>
    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
        <span class="token hvariable">a</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们需要按顺序执行一系列操作的，并且不关心先前的计算结果的时候，可以使用这操作符。这样也许看起来让人觉得费解：为什么我们会忽略一个函数的返回值呢，这样有什么意义？回想一下，我们之前定义了一个 <code>(==&gt;&amp;)</code> 组合子来专门表达这个概念。另外，考虑一下 <code>print</code> 这样的函数，它的返回结果是一个占位符，我们没有必要关心它返回值是什么。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type print <span class="token string">&quot;foo&quot;</span>
print <span class="token string">&quot;foo&quot;</span> :: IO <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们使用普通的 <code>(&gt;&gt;=)</code> 来串联调用，我们必须提供一个新的函数来忽略参数（这个参数是前一个 <code>print</code> 的返回值。)</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> print <span class="token string">&quot;foo&quot;</span> <span class="token operator">&gt;&gt;</span><span class="token operator">=</span> <span class="token punctuation">\\</span>_ -<span class="token operator">&gt;</span> print <span class="token string">&quot;bar&quot;</span>
<span class="token string">&quot;foo&quot;</span>
<span class="token string">&quot;bar&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果我们使用 <code>(&gt;&gt;)</code> 操作符，那么就可以去掉那个没什么用的函数了：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> print <span class="token string">&quot;baz&quot;</span> <span class="token operator">&gt;&gt;</span> print <span class="token string">&quot;quux&quot;</span>
<span class="token string">&quot;baz&quot;</span>
<span class="token string">&quot;quux&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如我们上面看到的一样， <code>(&gt;&gt;)</code> 的默认实现是通过 <code>(&gt;&gt;=)</code> 完成的。</p><p>Monad类型类另外一个非核心函数是 <code>fail</code> ，这个函数接受一个错误消息然后让函数调用链失败。</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>许多Monad实现并没有重写 <code>fail</code>函数的默认实现，因此在这些Monad里面，<code>fail</code> 将由 <code>error</code> 函数实现。但是由于 <code>error</code> 函数抛出的异常对于调用者来说要么就是无法捕获的，要么就是无法预期的，所以调用 <code>error</code> 并不是一件好事。 就算你很清楚在Monad使用 <code>fail</code> 在当前场景下是个明智之选，但是依然非常不推荐使用它。当你以后重构代码的时候，很有可能这个 <code>fail</code> 函数在新的语境下无法工作从而导致非常复杂的问题，这种情况太容易发生了。</p></div>`,11),f=a("p",null,[s("回顾一下我们在 "),a("code",{class:"interpreted-text",role:"doc"},"10"),s(" 写的parse，里面有一个 "),a("code",null,"Monad"),s(" 的实例：")],-1),y=n(`<div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch10/Parse.hs</span>
<span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token constant">Parse</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token operator">=</span> <span class="token hvariable">identity</span>
    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">==&gt;</span><span class="token punctuation">)</span>
    <span class="token builtin">fail</span> <span class="token operator">=</span> <span class="token hvariable">bail</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="and-now-a-jargon-moment" tabindex="-1"><a class="header-anchor" href="#and-now-a-jargon-moment"><span>术语解释</span></a></h2><p>可能你对monad的某些惯用语并不熟悉，虽然他们不是正式术语，但是很常见；因此有必要了解一下。</p><ul><li>&quot;Monadic&quot;仅仅表示&quot;和Monad相关的&quot;。一个monadic 类型就是一个Monad 类型类的实例；一个monadic值就是一个具有monadic类型的值。</li><li>当我们说某个东西&quot;是一个monad&quot;的时候，我们其实表达的意思是&quot;这个类型是Monad这个类型类的实例&quot;；作为Monad的实例就有三要素：类型构造器，注入函数，串联函数。</li><li>同样，当我们谈到&quot;Foo这个monad&quot;的时候，我们实际上指的是Foo这个类型，只不过Foo是Monad这个类型类的实例。</li><li>Monadic值的一个别称是&quot;动作&quot;；这个说法可能源自 <code>I/O Monad</code> 的引入，<code>print &quot;foo&quot;</code> 这样的monad值会导致副作用。返回类型是monadic值的函数有时候也被称之为动作，虽然这样并不太常见。</li></ul><h2 id="using-a-new-monad-show-your-work" tabindex="-1"><a class="header-anchor" href="#using-a-new-monad-show-your-work"><span>使用新的Monad</span></a></h2><p>我们在介绍Monad的时候，展示了一些之前的代码，并说明它们其实就是Monad。既然我们慢慢知道monad是什么，而且已经见识过 <code>Monad</code> 这个类型类；现在就让我们用学到的知识来写一个Monad吧。我们先定义它的接口，然后使用它；一旦完成了这些，我们就写出了自己的Monad！</p><p>纯粹的Haskell代码写起来非常简洁，但是它不能执行IO操作；有时候，我们想记下我们程序的一些操作，但是又不想直接把日志信息写入文件；就这些需求，我们开发一个小型库。</p>`,7),x=a("p",null,[s("回忆一下我们在 "),a("code",{class:"interpreted-text",role:"ref"},"translate-a-glob-pattern-into-a-regular-expression"),s(" 中定义的 "),a("code",null,"globToRegex"),s(" 函数；我们修改它让它能够记住每次它翻译过的句子。我们又回到了熟悉的恐怖场景：比较同一份代码的Monadic版本和非Monadic版。")],-1),M=n(`<p>首先，我们可以使用一个 <code>Logger</code> 类型类把处理结果的类型包装起来。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">globToRegex</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Logger</span> <span class="token constant">String</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="information-hiding" tabindex="-1"><a class="header-anchor" href="#information-hiding"><span>信息隐藏</span></a></h3><p>我们将刻意隐藏 <code>Logger</code> 模块的实现。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token keyword">module</span> <span class="token constant">Logger</span>
    <span class="token punctuation">(</span>
      <span class="token constant">Logger</span>
    <span class="token punctuation">,</span> <span class="token constant">Log</span>
    <span class="token punctuation">,</span> <span class="token hvariable">runLogger</span>
    <span class="token punctuation">,</span> <span class="token hvariable">record</span>
    <span class="token punctuation">)</span> <span class="token keyword">where</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>像这样隐藏实现有两个好处：它很大程度出上保证了我们对于Monad实现的灵活性，更重要的是，这样有一个非常简单的接口。</p><p><code>Logger</code> 类型就是单纯的一个类型构造器。我们并没有将它的值构造器导出，因此 <code>Logger</code> 模块的使用者没有办法自己创建一个 <code>Logger</code> 类型的值，它们对于 <code>Logger</code> 类型能做的就是把它写在类型签名上。</p><p><code>Log</code> 类型就是一串字符串的别名，这样写是为了让它可读性更好。同时我们使用一串字符串来保持实现的简单。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token keyword">type</span> <span class="token constant">Log</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们给接口的使用者提供了一个 <code>runLogger</code> 函数来执行某个日志操作，而不是直接给他们一个值构造器。这个函数既回传了日志纪录这个操作，同时也回传了日志信息本身。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">runLogger</span> <span class="token operator">::</span> <span class="token constant">Logger</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Log</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="controlled-escape" tabindex="-1"><a class="header-anchor" href="#controlled-escape"><span>受控的Monad</span></a></h3><p>Monad类型类没有提供任何方法使一个monadic的值成为一个普通的值。我们可以使用 <code>return</code> 函数把一个普通的值&quot;注入&quot;到monad里面；我们也可以用 <code>(&gt;&gt;=)</code> 操作符把一个monadic的值提取出来，但是经过操作符处理之后还是回传一个monadic的值。</p><p>很多monads都有一个或者多个类似 <code>runLogger</code> 的函数； <code>IO</code> monad是个例外，通常情况下我们只能退出整个程序来脱离这个monad。</p><p>一个Monad函数在monad内部执行然后向外返回结果；一般来说这些函数是把一个Monadic的值脱离Monad成为一个普通值的唯一方法。因此，Monad的创建者对于如何处理这个过程有着完全的控制权。</p><p>有的Monad有好几个执行函数。在我们这个Logger的例子里面，我们可以假设有一些 <code>runLogger</code> 的替代方法：一个仅仅返回日志信息，另外一个可能返回日志操作，然后把日志信息本身丢掉。</p><h3 id="leaving-a-trace" tabindex="-1"><a class="header-anchor" href="#leaving-a-trace"><span>日志纪录</span></a></h3><p>当我们执行一个 <code>Logger</code> 动作的时候，代码将调用 <code>record</code> 函数来纪录某些东西。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">record</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Logger</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于日志纪录的过程发生在Monad的内部，因此 <code>record</code> 这个动作并不返回什么有用的信息（ <code>()</code> )</p><p>通常Monad会提供一些类似 <code>record</code> 这样的辅助函数；这些函数也是我们访问这个Monad某些特定行为的方式。</p><p>我们的模块也把 <code>Logger</code> 定义为了 <code>Monad</code> 的实例。这个实例里面的定义就是使用 <code>Logger</code> 类型所需要的全部东西。</p><p>下面就是使用我们的 <code>Logger</code> 类的一个例子：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> simple <span class="token operator">=</span> <span class="token builtin class-name">return</span> True :: Logger Bool
ghci<span class="token operator">&gt;</span> runLogger simple
<span class="token punctuation">(</span>True,<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们使用 <code>runLogger</code> 函数执行被记录的操作之后，会得到一个二元组。二元组的第一个元素是我们代码的执行结果；第二个元素是我们的日志动作执行的时候纪录信息的列表。由于我们没有纪录任何东西，所以返回的列表是空；来个有日志信息的例子。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> runLogger <span class="token punctuation">(</span>record <span class="token string">&quot;hi mom!&quot;</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">return</span> <span class="token number">3.1337</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3.1337</span>,<span class="token punctuation">[</span><span class="token string">&quot;hi mom!&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="using-the-logger-monad" tabindex="-1"><a class="header-anchor" href="#using-the-logger-monad"><span>使用 Logger monad</span></a></h3><p>在 <code>Logger</code> monad里面我们可以剔除通配符到正则表达式的转换，代码如下：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">globToRegex</span> <span class="token hvariable">cs</span> <span class="token operator">=</span>
    <span class="token hvariable">globToRegex&#39;</span> <span class="token hvariable">cs</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">ds</span> <span class="token operator">-&gt;</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token char string">&#39;^&#39;</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们来简单说明一下一些值得注意的代码风格。我们函数体在函数名字下面一行，要这么做，需要添加一些水平的空格；对于匿名函数，我们把它的参数放在另起的一行，这是monadic代码通常的组织方式。</p><p>回忆一下 <code>(&gt;&gt;=)</code> 的类型：它从 <code>Logger</code> 包装器中中提取出操作符 <code>(&gt;&gt;=)</code> 左边的值，然后把取出来的值传递给右边的函数。右边的操作数函数必须把这个取出来的值用 <code>Logger</code> 包装起来然后回传出去。这个操作正如正如 <code>return</code> 一样：接受一个纯值，然后用Monad的类型构造器包装一下返回。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span> :: <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> m a -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> m b
ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span>globToRegex <span class="token string">&quot;&quot;</span> <span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>globToRegex <span class="token string">&quot;&quot;</span> <span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span> :: <span class="token punctuation">(</span>String -<span class="token operator">&gt;</span> Logger b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> Logger b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就算我们写一个什么都不做的函数，我们也必须使用 <code>return</code> 去包装具有正确类型的值。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">globToRegex&#39;</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Logger</span> <span class="token constant">String</span>
<span class="token hvariable">globToRegex&#39;</span> <span class="token string">&quot;&quot;</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token string">&quot;$&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们要使用 <code>record</code> 函数纪录某些日志的时候，我们采用 <code>(&gt;&gt;)</code> 而不是 <code>(&gt;&gt;=)</code> 来串联一系列的日志操作。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">globToRegex&#39;</span> <span class="token punctuation">(</span><span class="token char string">&#39;?&#39;</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token hvariable">record</span> <span class="token string">&quot;any&quot;</span> <span class="token operator">&gt;&gt;</span>
    <span class="token hvariable">globToRegex&#39;</span> <span class="token hvariable">cs</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">ds</span> <span class="token operator">-&gt;</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token char string">&#39;.&#39;</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>(&gt;&gt;)</code> 就是 <code>(&gt;&gt;=)</code> 的一个变种，只不过它会忽略左边操作的结果；由于 <code>record</code> 函数的返回值永远都是 <code>()</code> 因此获取它的返回值没有什么意义，直接使用 <code>&gt;&gt;</code> 更简洁。</p>`,37),w=a("p",null,[s("另外，我们也可以使用在 "),a("code",{class:"interpreted-text",role:"ref"},"sequencing"),s(" 引入的 "),a("code",null,"do"),s(" 表示法来整理代码。")],-1),S=n(`<div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">globToRegex&#39;</span> <span class="token punctuation">(</span><span class="token char string">&#39;*&#39;</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">record</span> <span class="token string">&quot;kleene star&quot;</span>
    <span class="token hvariable">ds</span> <span class="token operator">&lt;-</span> <span class="token hvariable">globToRegex&#39;</span> <span class="token hvariable">cs</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token string">&quot;.*&quot;</span> <span class="token operator">++</span> <span class="token hvariable">ds</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),L=a("p",null,[s("选择使用 "),a("code",null,"do"),s(" 表示法还是显式使用 "),a("code",null,"(>>=)"),s(" 结合匿名函数完全取决于个人爱好，但是对于长度超过两行的代码来说，几乎所有人都会选择使用 "),a("code",null,"do"),s(". 这两种风格有一个非常重要的区别，我们将会在 "),a("code",{class:"interpreted-text",role:"ref"},"desugaring-of-do-blocks"),s(" 里面介绍。")],-1),q=n(`<p>对于解析单个字符的情况，monadic的代码几乎和普通的一样：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">globToRegex&#39;</span> <span class="token punctuation">(</span><span class="token char string">&#39;[&#39;</span><span class="token operator">:</span><span class="token char string">&#39;!&#39;</span><span class="token operator">:</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token hvariable">record</span> <span class="token string">&quot;character class, negative&quot;</span> <span class="token operator">&gt;&gt;</span>
    <span class="token hvariable">charClass</span> <span class="token hvariable">cs</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">ds</span> <span class="token operator">-&gt;</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token string">&quot;[^&quot;</span> <span class="token operator">++</span> <span class="token hvariable">c</span> <span class="token operator">:</span> <span class="token hvariable">ds</span><span class="token punctuation">)</span>
<span class="token hvariable">globToRegex&#39;</span> <span class="token punctuation">(</span><span class="token char string">&#39;[&#39;</span><span class="token operator">:</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token hvariable">record</span> <span class="token string">&quot;character class&quot;</span> <span class="token operator">&gt;&gt;</span>
    <span class="token hvariable">charClass</span> <span class="token hvariable">cs</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">ds</span> <span class="token operator">-&gt;</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token string">&quot;[&quot;</span> <span class="token operator">++</span> <span class="token hvariable">c</span> <span class="token operator">:</span> <span class="token hvariable">ds</span><span class="token punctuation">)</span>
<span class="token hvariable">globToRegex&#39;</span> <span class="token punctuation">(</span><span class="token char string">&#39;[&#39;</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token builtin">fail</span> <span class="token string">&quot;unterminated character class&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="mixing-pure-and-monadic-code" tabindex="-1"><a class="header-anchor" href="#mixing-pure-and-monadic-code"><span>同时使用puer和monadic代码</span></a></h2><p>迄今为止我们看到的Monad好像有一个非常明显的缺陷：Monad的类型构造器把一个值包装成一个monadic的值，这样导致在monad里面使用普通的纯函数有点困难。举个例子，假设我们有一段运行在monad里面的代码，它所做的就是返回一个字符串：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> m <span class="token operator">=</span> <span class="token builtin class-name">return</span> <span class="token string">&quot;foo&quot;</span> :: Logger String
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果我们想知道字符串的长度是多少，我们不能直接调用 <code>length</code> 函数：因为这个字符串被 <code>Logger</code> 这个monad包装起来了，因此类型并不匹配。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> length m

<span class="token operator">&lt;</span>interactive<span class="token operator">&gt;</span>:1:7:
    Couldn<span class="token string">&#39;t match expected type \`[a]&#39;</span>
           against inferred <span class="token builtin class-name">type</span> <span class="token variable"><span class="token variable">\`</span>Logger String&#39;
    In the first argument of <span class="token variable">\`</span></span>length<span class="token string">&#39;, namely \`m&#39;</span>
    In the expression: length m
    In the definition of \`it&#39;: it <span class="token operator">=</span> length m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们能做的事情就是下面这样：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type   m <span class="token operator">&gt;&gt;</span><span class="token operator">=</span> <span class="token punctuation">\\</span>s -<span class="token operator">&gt;</span> <span class="token builtin class-name">return</span> <span class="token punctuation">(</span>length s<span class="token punctuation">)</span>
m <span class="token operator">&gt;&gt;</span><span class="token operator">=</span> <span class="token punctuation">\\</span>s -<span class="token operator">&gt;</span> <span class="token builtin class-name">return</span> <span class="token punctuation">(</span>length s<span class="token punctuation">)</span> :: Logger Int
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用 <code>(&gt;&gt;=)</code> 把字符串从monad里面取出来，然后使用一个匿名函数调用 <code>length</code> 接着用 <code>return</code> 把这个字符串重新包装成 <code>Logger</code> 。</p>`,10),_=a("p",null,[s("由于这种形式的代码经常在Haskell里面出现，因此已经有一个类似的操作符存在了。在 "),a("code",{class:"interpreted-text",role:"ref"},"introducing-functors"),s(" 里面我们介绍了 "),a("em",null,"lifting"),s(" 这种技术；把一个纯函数 Lift 为一个函子通常意味着从一个带有上下文的特殊值里面取出那个值，然后使用这个普通的值调用纯函数，得到结果之后用特定的类型构造器包装成原来有着上下文的特殊值。")],-1),R=n(`<p>在monad里面，我们需要干同样的一件事。由于 <code>Monad</code> 这个类型类已经提供了 <code>(&gt;&gt;=)</code> 和 <code>return</code> 这两个函数处理monadic的值和普通值之间的转换，因此 <code>liftM</code> 函数不需要知道monad的任何实现细节。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">liftM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">liftM</span> <span class="token hvariable">f</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">i</span> <span class="token operator">-&gt;</span>
            <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">i</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们把一个类型声明为 <code>Functor</code> 这个类型类的实例之后，我们必须根据这个特定的类型实现对应的 <code>fmap</code> 函数；但是， 由于 <code>(&gt;&gt;=)</code> 和 <code>return</code> 对monad的进行了抽象，因此<code>liftM</code> 不需要知道任何monad的任何实现细节。我们只需要实现一次并配上合适的类型签名即可。</p><p>在标准库的 <code>Control.Monad</code> 模块里面已经为我们定义好了 <code>liftM</code> 函数。</p><p>我们来看看使用 <code>liftM</code> 对于提升我们代码可读性有什么作用；先看看没有使用 <code>liftM</code> 的代码：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">charClass_wordy</span> <span class="token punctuation">(</span><span class="token char string">&#39;]&#39;</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token hvariable">globToRegex&#39;</span> <span class="token hvariable">cs</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">ds</span> <span class="token operator">-&gt;</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token char string">&#39;]&#39;</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span>
<span class="token hvariable">charClass_wordy</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token hvariable">charClass_wordy</span> <span class="token hvariable">cs</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">ds</span> <span class="token operator">-&gt;</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们用 <code>liftM</code> 去掉那些 <code>(&gt;&gt;=))</code> 和匿名函数：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">charClass</span> <span class="token punctuation">(</span><span class="token char string">&#39;]&#39;</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token char string">&#39;]&#39;</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">\`liftM\`</span> <span class="token hvariable">globToRegex&#39;</span> <span class="token hvariable">cs</span>
<span class="token hvariable">charClass</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">\`liftM\`</span> <span class="token hvariable">charClass</span> <span class="token hvariable">cs</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如 <code>fmap</code> 一样，我们通常用中缀的方式调用 <code>liftM</code> 。可以用这种方式来阅读这个表达式：把右边操作得到的monadic的值应用到左边的纯函数上。</p><p><code>liftM</code> 函数实在是太有用了，因此 <code>Control.Monad</code> 定义了它的几个变种，这些变种可以处理更长的参数；我们可以看一看 <code>globToRegex</code> 这个函数的最后一个分句：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">globToRegex&#39;</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">liftM2</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">escape</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">globToRegex&#39;</span> <span class="token hvariable">cs</span><span class="token punctuation">)</span>

<span class="token hvariable">escape</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Logger</span> <span class="token constant">String</span>
<span class="token hvariable">escape</span> <span class="token hvariable">c</span>
    <span class="token operator">|</span> <span class="token hvariable">c</span> <span class="token operator">\`elem\`</span> <span class="token hvariable">regexChars</span> <span class="token operator">=</span> <span class="token hvariable">record</span> <span class="token string">&quot;escape&quot;</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">[</span><span class="token char string">&#39;\\\\&#39;</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">]</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>           <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span>
  <span class="token keyword">where</span> <span class="token hvariable">regexChars</span> <span class="token operator">=</span> <span class="token string">&quot;\\\\+()^$.{}]|&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这段代码用到的 <code>liftM2</code> 函数的定义如下：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">liftM2</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">c</span>
<span class="token hvariable">liftM2</span> <span class="token hvariable">f</span> <span class="token hvariable">m1</span> <span class="token hvariable">m2</span> <span class="token operator">=</span>
    <span class="token hvariable">m1</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span>
    <span class="token hvariable">m2</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它首先执行第一个动作，接着执行第二个操作，然后把这两个操作的结果组合起来应用到那个纯函数上并包装返回的结果。<code>Control.Monad</code> 里面定义了 <code>liftM</code> <code>liftM2</code> 直到 <code>liftM5</code> 。</p><h2 id="putting-a-few-misconceptions-to-rest" tabindex="-1"><a class="header-anchor" href="#putting-a-few-misconceptions-to-rest"><span>关于Monad的一些误解</span></a></h2><p>我们已经见识过很多Monad的例子并且对monad也有一些感觉了；在继续探讨monad之前，有一些广为流传的关于monad的观念需要澄清。你肯定经常听到这些说法，因此你可能已经有一些很好的理由来反驳这些谬论了。</p><ul><li><em>Monads很难理解</em> 我们已经从好几个实例的问题来说明Monad是如何工作的了，并且我们已经知道理解monad最好的方式就是先通过一些具体的例子来进行解释，然后抽象出这些这些例子共同的东西。</li><li><em>Monads仅仅用于 I/O 操作和命令式代码</em> 虽然我们在Haskell的IO里面使用Monad，但是Monad在其他的地方也非常有用。我们已经通过monad串联简单的计算，隐藏复杂的状态以及纪录日志了；然而，Monad的作用我们还只看到冰山一角。</li><li><em>只有Haskell才有Monad</em> Haskell有可能是显式使用Monad最多的语言，但是在别的语言里面也存在，从C++到OCaml。由于Haskell的 <code>do</code> 表示法，强大的类型系统以及语言的语法使得Monad在Haskell里面非常容易处理。</li><li><em>Monads使用来控制求值顺序的</em></li></ul><h2 id="building-the-logger-monad" tabindex="-1"><a class="header-anchor" href="#building-the-logger-monad"><span>创建Logger Monad</span></a></h2><p><code>Logger</code> 类的定义非常简单：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token keyword">newtype</span> <span class="token constant">Logger</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Logger</span> <span class="token punctuation">{</span> <span class="token hvariable">execLogger</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Log</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>它其实就是一个二元组，第一个元素是执行动作的结果，第二元素是我们执行动作的时候纪录的日志信息列表。</p><p>我们使用 <code>newtype</code> 关键字把二元组进行了包装使它的类型更加清晰易读。<code>runLogger</code> 函数可以从这个Monad里面取出这个元组里面的值；这个函数其实是 <code>execLogger</code> 的一个别名。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">runLogger</span> <span class="token operator">=</span> <span class="token hvariable">execLogger</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>record</code> 这个函数将为接收到的日志信息创建一个只包含单个元素的列表。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token hvariable">record</span> <span class="token hvariable">s</span> <span class="token operator">=</span> <span class="token constant">Logger</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token hvariable">s</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个动作的结果是 <code>()</code> 。</p><p>让我们以 <code>return</code> 开始，构建 <code>Monad</code> 实例；先尝试一下：它什么都不记录，然后把结果存放在二元组里面。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
<span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token constant">Logger</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Logger</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>(&gt;&gt;=)</code> 的定义更有趣，当然它也是monad的核心。 <code>(&gt;&gt;=)</code> 把一个普通的值和一个monadic的函数结合起来，得到新的运算结果和一个新的日志信息。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Logger.hs</span>
    <span class="token comment">-- (&gt;&gt;=) :: Logger a -&gt; (a -&gt; Logger b) -&gt; Logger b</span>
    <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">execLogger</span> <span class="token hvariable">m</span>
                  <span class="token hvariable">n</span>      <span class="token operator">=</span> <span class="token hvariable">k</span> <span class="token hvariable">a</span>
                  <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">execLogger</span> <span class="token hvariable">n</span>
              <span class="token keyword">in</span> <span class="token constant">Logger</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">w</span> <span class="token operator">++</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看看这段代码里面发生了什么。首先使用 <code>runLogger</code> 函数从动作 <code>m</code> 取出结果 <code>a</code> ,然后把它传递给monadic函数 <code>k</code>; 接着我们又取出 <code>b</code> ；最后把 <code>w</code> 和 <code>x</code> 拼接得到一个新的日志。</p><h3 id="sequential-logging-not-sequential-evaluation" tabindex="-1"><a class="header-anchor" href="#sequential-logging-not-sequential-evaluation"><span>顺序的日志，而不是顺序的求值</span></a></h3><p>我们定义的 <code>(&gt;&gt;=)</code> 保证了新输出的日志一定在之前的输出的日志之后。但是这并不意味着 <code>a</code> 和 <code>b</code> 的求值是顺序的：<code>(&gt;&gt;=)</code> 操作符是惰性求值的。</p><p>正如Monad的很多其他行为一样，求值的严格性是由Monad的实现者控制的，并不是所有Monad的共同性质。事实上，有一些Monad同时有几种特性，每一种都有着不同程度的严格性（求值）。</p><h3 id="the-writer-monad" tabindex="-1"><a class="header-anchor" href="#the-writer-monad"><span>Writer monad</span></a></h3>`,35),N=a("p",null,[s("我们创建的 "),a("code",null,"Logger"),s(" monad实际上是标准库里面 "),a("code",null,"Writer"),s(" Monad的一个特例；"),a("code",null,"Writer"),s(" Monad可以在 "),a("code",null,"mtl"),s(" 包里面的 "),a("code",null,"Control.Monad.Writer"),s(" 模块找到。我们会在 "),a("code",{class:"interpreted-text",role:"ref"},"using-typeclasses"),s(" 里面介绍 "),a("code",null,"Writer"),s(" 的用法。")],-1),P=n(`<h2 id="the-maybe-monad" tabindex="-1"><a class="header-anchor" href="#the-maybe-monad"><span>Maybe monad</span></a></h2><p><code>Maybe</code> 应该是最简单的Monad了。它代表了一种可能不会产生计算结果的计算过程。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Maybe.hs</span>
<span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">k</span>  <span class="token operator">=</span>  <span class="token hvariable">k</span> <span class="token hvariable">x</span>
    <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">_</span> <span class="token operator">=</span>  <span class="token constant">Nothing</span>

    <span class="token constant">Just</span> <span class="token hvariable">_</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">k</span>   <span class="token operator">=</span>  <span class="token hvariable">k</span>
    <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">_</span>  <span class="token operator">=</span>  <span class="token constant">Nothing</span>

    <span class="token builtin">return</span> <span class="token hvariable">x</span>      <span class="token operator">=</span>  <span class="token constant">Just</span> <span class="token hvariable">x</span>

    <span class="token builtin">fail</span> <span class="token hvariable">_</span>        <span class="token operator">=</span>  <span class="token constant">Nothing</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们使用 <code>(&gt;&gt;=)</code> 或者 <code>(&gt;&gt;)</code> 串联一些 <code>Maybe</code> 计算的时候，如果这些计算中的任何一个返回了 <code>Nothing</code> ， <code>(&gt;&gt;=)</code> 和 <code>(&gt;&gt;)</code> 就不会对余下的任何计算进行求值。</p><p>值得一提的是，整个调用链并不是完全短路的。每一个 <code>(&gt;&gt;=)</code> 或者 <code>(&gt;&gt;)</code> 仍然会匹配它左边的 <code>Nothing</code> 然后给右边的函数一个 <code>Nothing</code> ，直到达到调用链的末端。这一点很容易被遗忘：当调用链中某个计算失败的时候，之前计算的结果，余下的调用链以及使用的 <code>Nothing</code> 值在运行时的开销是廉价的，但并不是完全没有开销。</p><h3 id="executing-the-maybe-monad" tabindex="-1"><a class="header-anchor" href="#executing-the-maybe-monad"><span>执行Maybe monad</span></a></h3><p>适合执行 <code>Maybe</code> Monad的函数是 <code>maybe</code> （&quot;执行&quot;一个monad意味着取出Monad里面包含的值，移除Monad类的包装）</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Maybe.hs</span>
<span class="token builtin">maybe</span> <span class="token operator">::</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token builtin">maybe</span> <span class="token hvariable">n</span> <span class="token hvariable">_</span> <span class="token constant">Nothing</span>  <span class="token operator">=</span> <span class="token hvariable">n</span>
<span class="token builtin">maybe</span> <span class="token hvariable">_</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果第三个参数是 <code>Nothing</code> ， <code>maybe</code> 将使用第一个参数作为返回值；而第二个参数则是在 <code>Just</code> 值构造器里面进行包装值的函数。</p><p>由于 <code>Maybe</code> 类型非常简单，直接对它进行模式匹配和调用 <code>maybe</code> 函数使用起来差不多，在不同的场景下，两种方式都有各自的优点。</p><h3 id="maybe-at-work-and-good-api-design" tabindex="-1"><a class="header-anchor" href="#maybe-at-work-and-good-api-design"><span>使用Maybe，以及好的API设计方式</span></a></h3><p>下面是一个使用 <code>Maybe</code> 的例子。给出一个顾客的名字，找出它们手机号对应的账单地址。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Carrier.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Map <span class="token keyword">as</span> M</span>

<span class="token keyword">type</span> <span class="token constant">PersonName</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">PhoneNumber</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">BillingAddress</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">data</span> <span class="token constant">MobileCarrier</span> <span class="token operator">=</span> <span class="token constant">Honest_Bobs_Phone_Network</span>
                   <span class="token operator">|</span> <span class="token constant">Morrisas_Marvelous_Mobiles</span>
                   <span class="token operator">|</span> <span class="token constant">Petes_Plutocratic_Phones</span>
                     <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>

<span class="token hvariable">findCarrierBillingAddress</span> <span class="token operator">::</span> <span class="token constant">PersonName</span>
                          <span class="token operator">-&gt;</span> <span class="token constant">M<span class="token punctuation">.</span>Map</span> <span class="token constant">PersonName</span> <span class="token constant">PhoneNumber</span>
                          <span class="token operator">-&gt;</span> <span class="token constant">M<span class="token punctuation">.</span>Map</span> <span class="token constant">PhoneNumber</span> <span class="token constant">MobileCarrier</span>
                          <span class="token operator">-&gt;</span> <span class="token constant">M<span class="token punctuation">.</span>Map</span> <span class="token constant">MobileCarrier</span> <span class="token constant">BillingAddress</span>
                          <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">BillingAddress</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的第一个实现使用 <code>case</code> 表达式，用它完成的代码相当难看，差不多超出了屏幕的右边。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Carrier.hs</span>
<span class="token hvariable">variation1</span> <span class="token hvariable">person</span> <span class="token hvariable">phoneMap</span> <span class="token hvariable">carrierMap</span> <span class="token hvariable">addressMap</span> <span class="token operator">=</span>
    <span class="token keyword">case</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">person</span> <span class="token hvariable">phoneMap</span> <span class="token keyword">of</span>
      <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
      <span class="token constant">Just</span> <span class="token hvariable">number</span> <span class="token operator">-&gt;</span>
          <span class="token keyword">case</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">number</span> <span class="token hvariable">carrierMap</span> <span class="token keyword">of</span>
            <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
            <span class="token constant">Just</span> <span class="token hvariable">carrier</span> <span class="token operator">-&gt;</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">carrier</span> <span class="token hvariable">addressMap</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模块 <code>Data.Map</code> 的函数 <code>lookup</code> 返回一个 monadic的值：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :module +Data.Map
ghci<span class="token operator">&gt;</span> :type Data.Map.lookup
Data.Map.lookup :: <span class="token punctuation">(</span>Ord k, Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> k -<span class="token operator">&gt;</span> Map k a -<span class="token operator">&gt;</span> m a
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>换句话说，如果给定的key在map里面存在，那么 <code>lookup</code> 函数使用 <code>return</code> 把这个值注入到monad里面去；否则就会调用 <code>fail</code> 函数。这是这个API一个有趣的实现，虽然有人觉得它很糟糕。</p><ul><li>这样设计好的一方式是，根据具体Monad实现的不同，查找成功和失败的结果是可以根据不同需求定制的；而且， <code>lookup</code> 函数本身对于具体的这些行为完全不用关心。</li><li>坏处就是，在有些Monad里面调用 <code>fail</code> 会直接抛出让人恼火的异常；之前我们就警告过最好不要使用 <code>fail</code> 函数，这里就不在赘述了。</li></ul><p>实际上，每个人都使用 <code>Maybe</code> 类型作为 <code>lookup</code> 函数的返回结果；这样一个简单的函数对于它的返回结果提供了它并不需要的通用性：其实 <code>lookup</code> 应该直接返回 <code>Maybe</code> 。</p><p>先放下API设计的问题，我们来处理一下我们之前用 <code>case</code> 编写的丑陋代码。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Carrier.hs</span>
<span class="token hvariable">variation2</span> <span class="token hvariable">person</span> <span class="token hvariable">phoneMap</span> <span class="token hvariable">carrierMap</span> <span class="token hvariable">addressMap</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token hvariable">number</span> <span class="token operator">&lt;-</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">person</span> <span class="token hvariable">phoneMap</span>
  <span class="token hvariable">carrier</span> <span class="token operator">&lt;-</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">number</span> <span class="token hvariable">carrierMap</span>
  <span class="token hvariable">address</span> <span class="token operator">&lt;-</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">carrier</span> <span class="token hvariable">addressMap</span>
  <span class="token builtin">return</span> <span class="token hvariable">address</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果这其中的任何一个查找失败， <code>(&gt;&gt;=)</code> 和 <code>(&gt;&gt;)</code> 的定义告诉我们整个运算的结果将会是 <code>Nothing</code>; 就和我们显式使用 <code>case</code> 表达式结果一样。</p><p>使用Monad的版本的代码更加整洁，但是其实 <code>return</code> 是不必要的；从风格上说，使用 <code>return</code> 让代码看起来更加有规律，另外熟悉命令式编程的程序员可能对它感觉更熟悉；但其实上它是多余的；下面是与它等价的版本：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Carrier.hs</span>
<span class="token hvariable">variation2a</span> <span class="token hvariable">person</span> <span class="token hvariable">phoneMap</span> <span class="token hvariable">carrierMap</span> <span class="token hvariable">addressMap</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token hvariable">number</span> <span class="token operator">&lt;-</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">person</span> <span class="token hvariable">phoneMap</span>
  <span class="token hvariable">carrier</span> <span class="token operator">&lt;-</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">number</span> <span class="token hvariable">carrierMap</span>
  <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">carrier</span> <span class="token hvariable">addressMap</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="the-list-monad" tabindex="-1"><a class="header-anchor" href="#the-list-monad"><span>List Monad</span></a></h2><p><code>Maybe</code> 类型代表有可能有值也可能没有值的计算；也有的情况下希望计算会返回一系列的结果，显然，List正适合这个目的。List的类型带有一个参数，这暗示它有可能能作为一个monad使用；事实上，我们确实能把它当作monad使用。</p><p>先不看标准库的 <code>Prelude</code> 对于List monad的实现，我们自己来看看一个 List 的monad应该是什么样的。这个过程很简单：首先看 <code>(&gt;&gt;=)</code> 和 <code>return</code> 的类型，然后进行一些替换操作，看看我们能不能使用一些熟悉的list函数。</p><p><code>return</code> 和 <code>(&gt;&gt;=)</code> 这两个函数里面显然 <code>return</code> 比较简单。我们已经知道 <code>return</code> 函数接受一个类型，然后把它用类型构造器 <code>m</code> 包装一下然后产生一个新的类型 <code>m a</code>. 在List这种情况下，这个类型构造器就是 <code>[]</code>. 把这个类型构造器使用List的类型构造器替换掉我们就得到了类型 <code>[] a</code> （当然，这样写是非法的！）；可以把它写成更加熟悉的形式 <code>[a]</code>.</p><p>现在我们知道list的 <code>return</code> 函数的类型应该是 <code>a -&gt; [a]</code> 。对于这种类型的函数，只有少数那么几种实现的可能：要么它返回一个空列表，要么返回一个单个元素的列表，或者一个无穷长度的列表。基于我们现在对于Monad的理解，最有可能的实现方式应该是返回单个元素的列表：它不会丢失已有信息，也不会无限重复。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/ListMonad.hs</span>
<span class="token hvariable">returnSingleton</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">returnSingleton</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们对 <code>(&gt;&gt;=)</code> 的类型签名进行和 <code>return</code> 类似的替换，我们会得到：<code>[a] -&gt; (a -&gt; [b]) -&gt; [b]</code> . 这看起来和 <code>map</code> 非常相似。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span> :: <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> m a -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> m b
ghci<span class="token operator">&gt;</span> :type map
map :: <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>map</code> 函数的参数顺序和它有点不对应，我们可以改成这样：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span> :: <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> m a -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> m b
ghci<span class="token operator">&gt;</span> :type flip map
flip map :: <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是还是有一点小问题： <code>flip map</code> 的第二个参数的类型是 <code>a -&gt; b</code> ，但是 <code>(&gt;&gt;=)</code> 的第二个参数的类型是 <code>a -&gt; [b]</code> ,应该怎么办呢？</p><p>我们对类型进行更多的替换，看看会发生什么。 <code>flip map</code> 这个函数能把任何类型 <code>b</code> 作为返回结果；如果我们使用 <code>[b]</code> 来替换 <code>b</code> ，这个函数的类型就成了 <code>a -&gt; (a -&gt; [n]) -&gt; [[b]]</code> 。换句话说，如果我们使用 <code>map</code> ，将一个列表与一个返回列表的函数进行映射，我们会得到一个包含列表的列表。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> flip map <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">\\</span>a -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a,a+100<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1,101</span><span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">2,102</span><span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">3,103</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>有趣的是，我们这么做并没有让 <code>flip map</code> 和 <code>(&gt;&gt;=)</code> 的类型更加匹配一点；<code>(&gt;&gt;=)</code> 的类型是 <code>[a] -&gt; (a -&gt; [b]) -&gt; [b]</code> ；然而，<code>flip map</code> 如果对返回列表的函数进行map那么它的类型签名是 <code>[a] -&gt; (a -&gt; [b]) -&gt; [[b]]</code> 。在类型上依然是不匹配的，我们仅仅是把不匹配的类型从中间转移到了末尾。但是，我们的努力并没有白费：我们现在其实只需要一个能把 <code>[[b]]</code> 转化成 <code>[b]</code> 的函数就好了。很明显 <code>concat</code> 符合我们的要求。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type concat
concat :: <span class="token punctuation">[</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>(&gt;&gt;=)</code> 的类型告诉我们应该把 <code>map</code> 的参数进行翻转，然后使用 <code>concat</code> 进行处理得到单个列表。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">\\</span>xs f -<span class="token operator">&gt;</span> concat <span class="token punctuation">(</span>map f xs<span class="token punctuation">)</span>
<span class="token punctuation">\\</span>xs f -<span class="token operator">&gt;</span> concat <span class="token punctuation">(</span>map f xs<span class="token punctuation">)</span> :: <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a1<span class="token punctuation">]</span><span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a1<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>事实上lists的 <code>(&gt;&gt;=)</code> 定义就是这样：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/ListMonad.hs</span>
<span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
        <span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它使用函数 <code>f</code> 对列表 <code>xs</code> 的每一个元素 <code>x</code> 进行处理，然后把得到的结果拼接起来得到单个列表。</p><p>现在我们已经搞定了List这个Monad的两个核心函数，另外两个非核心函数实现起来就很容易了：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/ListMonad.hs</span>
    <span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="understanding-the-list-monad" tabindex="-1"><a class="header-anchor" href="#understanding-the-list-monad"><span>理解List monad</span></a></h3><p>List monad与Haskell的另外一个工具------列表推导非常相似。我们可以通过计算两个列表的笛卡尔集来说明它们之间的相似性。首先，我们写一个列表推导：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/CartesianProduct.hs</span>
<span class="token hvariable">comprehensive</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token hvariable">ys</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们使用大括号语法来表示monadic代码，这样会告诉我们monadic代码和列表推导该有多么相似。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/CartesianProduct.hs</span>
<span class="token hvariable">monadic</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">;</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token hvariable">ys</span><span class="token punctuation">;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>唯一的一个不同点是使用monadic代码计算的结果在一系列表达式的末尾得到；而列表推导的结果表示在最开始。除此之外，这个函数计算的结果是完全相同的。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> comprehensive <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span> <span class="token string">&quot;bar&quot;</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&#39;r&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&#39;r&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> comprehensive <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span> <span class="token string">&quot;bar&quot;</span> <span class="token operator">==</span> monadic <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span> <span class="token string">&quot;bar&quot;</span>
True
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一开始肯定对列表monad非常迷惑，我们一起看一下monadic代码计算笛卡尔集的过程。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/CartesianProduct.hs</span>
<span class="token hvariable">blockyDo</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span>
    <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token hvariable">ys</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>x</code> 每次取列表 <code>xs</code> 的一个值， <code>y</code> 每次取列表 <code>ys</code> 的一个值，然后组合在一起得到最终结果；事实上，这就是两层嵌套循环！这也说明了关于monad的一个很重要的事实：除非你知道monad内部是如何执行的，否则你将无法预期monadic代码的行为。</p><p>我们再进一步观察这个代码；首先去掉 <code>do</code> 表示法；稍微改变一下代码的结构让它看起来更像一个嵌套循环。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/CartesianProduct.hs</span>
<span class="token hvariable">blockyPlain</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span>
    <span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;=</span>
    <span class="token operator">\\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">ys</span> <span class="token operator">&gt;&gt;=</span>
    <span class="token operator">\\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>

<span class="token hvariable">blockyPlain_reloaded</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span>
    <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span>
                 <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span>
                              <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                         <span class="token hvariable">ys</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 <code>xs</code> 的值是 <code>[1, 2, 3]</code> ，那么函数体的前两行会依次把x值绑定为 <code>1</code> ，<code>2</code> 和 <code>3</code> ；如果 <code>ys</code> 的值是 <code>[True, False]</code> ；那么最后一行会被求值六次：一次是 <code>x</code> 为 <code>1</code> , <code>y</code> 值为 <code>True</code> ；然后是 <code>x</code> 值为 <code>1</code> , <code>y</code> 的值为 <code>False</code> ；一直继续下去。 <code>return</code> 表达式把每个元组包装成一个单个列表的元素。</p><h3 id="putting-the-list-monad-to-work" tabindex="-1"><a class="header-anchor" href="#putting-the-list-monad-to-work"><span>使用List Monad</span></a></h3><p>给定一个整数，找出所有的正整数对，使得它们两个积等于这个整数；下面是这个问题的简单解法：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MultiplyTo.hs</span>
<span class="token hvariable">guarded</span> <span class="token operator">::</span> <span class="token constant">Bool</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">guarded</span> <span class="token constant">True</span>  <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">xs</span>
<span class="token hvariable">guarded</span> <span class="token constant">False</span> <span class="token hvariable">_</span>  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token hvariable">multiplyTo</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">multiplyTo</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token hvariable">n</span><span class="token punctuation">]</span>
  <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token operator">..</span><span class="token hvariable">n</span><span class="token punctuation">]</span>
  <span class="token hvariable">guarded</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">==</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">$</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <strong>ghci</strong> 验证结果：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> multiplyTo <span class="token number">8</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1,8</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2,4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> multiplyTo <span class="token number">100</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1,100</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2,50</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4,25</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">5,20</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">10,10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> multiplyTo <span class="token number">891</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1,891</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3,297</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">9,99</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">11,81</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">27,33</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="desugaring-of-do-blocks" tabindex="-1"><a class="header-anchor" href="#desugaring-of-do-blocks"><span>还原do的本质</span></a></h2><p>Haskell的 <code>do</code> 表示法实际上是个语法糖：它给我们提供了一种不使用 <code>(&gt;&gt;=)</code> 和匿名函数来写monadic代码的方式。去除do语法糖的过程就是把它翻译为 <code>(&gt;&gt;=)</code> 和匿名函数。</p><p>去除do语法糖的规则非常简单。我们可以简单的把编译器想象为机械重复地对这些do语句块执行这些规则直到没有任何do关键字为止。</p><p><code>do</code> 关键字后面接单个动作（action）直接翻译为动作本身。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">doNotation1</span> <span class="token operator">=</span>
    <span class="token keyword">do</span> <span class="token hvariable">act</span>

<span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">translated1</span> <span class="token operator">=</span>
    <span class="token hvariable">act</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>do</code> 后面包含多个动作（action）的表示是这样的：首先是第一个动作，但是接一个 <code>(&gt;&gt;)</code> 操作符，然后一个 <code>do</code> 关键字；最后接剩下的动作。当我们对do语句块重复应用这条规则的时候，整个do语句快就会被 <code>(&gt;&gt;)</code> 串联起来。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">doNotation2</span> <span class="token operator">=</span>
    <span class="token keyword">do</span> <span class="token hvariable">act1</span>
       <span class="token hvariable">act2</span>
       <span class="token comment">{- ... etc. -}</span>
       <span class="token hvariable">actN</span>

<span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">translated2</span> <span class="token operator">=</span>
    <span class="token hvariable">act1</span> <span class="token operator">&gt;&gt;</span>
    <span class="token keyword">do</span> <span class="token hvariable">act2</span>
       <span class="token comment">{- ... etc. -}</span>
       <span class="token hvariable">actN</span>

<span class="token hvariable">finalTranslation2</span> <span class="token operator">=</span>
    <span class="token hvariable">act1</span> <span class="token operator">&gt;&gt;</span>
    <span class="token hvariable">act2</span> <span class="token operator">&gt;&gt;</span>
    <span class="token comment">{- ... etc. -}</span>
    <span class="token hvariable">actN</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>&lt;-</code> 标记需要额外注意。在 <code>&lt;-</code> 的左边是一个正常的Haskell模式，可以是单个变量或者更复杂的东西；但是这里不允许使用模式匹配的守卫(guards):</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">doNotation3</span> <span class="token operator">=</span>
    <span class="token keyword">do</span> <span class="token hvariable">pattern</span> <span class="token operator">&lt;-</span> <span class="token hvariable">act1</span>
       <span class="token hvariable">act2</span>
       <span class="token comment">{- ... etc. -}</span>
       <span class="token hvariable">actN</span>

<span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">translated3</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token hvariable">pattern</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token hvariable">act2</span>
                       <span class="token comment">{- ... etc. -}</span>
                       <span class="token hvariable">actN</span>
        <span class="token hvariable">f</span> <span class="token hvariable">_</span>     <span class="token operator">=</span> <span class="token builtin">fail</span> <span class="token string">&quot;...&quot;</span>
    <span class="token keyword">in</span> <span class="token hvariable">act1</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种情况会被翻译为声明了一个名字唯一的局部函数(上面的例子里面我们仅仅使用了 <code>f</code> 这个名字)的 <code>let</code> 表达式； <code>&lt;-</code> 右边的动作会用 <code>(&gt;&gt;=)</code> 和这个局部函数串联起来。</p><p>要注意的是，如果模式匹配失败， <code>let</code> 表达式会调用Monad的 <code>fail</code> 函数；下面是一个使用 <code>Maybe</code> monad的例子。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">robust</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">robust</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token hvariable">xs</span>
               <span class="token builtin">return</span> <span class="token hvariable">x</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Maybe</code> monad里面 <code>fail</code> 的实现是返回一个 <code>Nothing</code> 。如果上面的代码模式匹配失败，那么整个计算结果就会是 <code>Nothing</code> .</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> robust <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>
Just <span class="token number">2</span>
ghci<span class="token operator">&gt;</span> robust <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
Nothing
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们在 <code>do</code> 块里面使用 <code>let</code> 表达式的时候，可以省略掉 <code>in</code> 关键字；但是 <code>let</code> 后面的语句必须和它对齐。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">doNotation4</span> <span class="token operator">=</span>
    <span class="token keyword">do</span> <span class="token keyword">let</span> <span class="token hvariable">val1</span> <span class="token operator">=</span> <span class="token hvariable">expr1</span>
           <span class="token hvariable">val2</span> <span class="token operator">=</span> <span class="token hvariable">expr2</span>
           <span class="token comment">{- ... etc. -}</span>
           <span class="token hvariable">valN</span> <span class="token operator">=</span> <span class="token hvariable">exprN</span>
       <span class="token hvariable">act1</span>
       <span class="token hvariable">act2</span>
       <span class="token comment">{- ... etc. -}</span>
       <span class="token hvariable">actN</span>

<span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">translated4</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">val1</span> <span class="token operator">=</span> <span class="token hvariable">expr1</span>
        <span class="token hvariable">val2</span> <span class="token operator">=</span> <span class="token hvariable">expr2</span>
        <span class="token hvariable">valN</span> <span class="token operator">=</span> <span class="token hvariable">exprN</span>
    <span class="token keyword">in</span> <span class="token keyword">do</span> <span class="token hvariable">act1</span>
          <span class="token hvariable">act2</span>
          <span class="token comment">{- ... etc. -}</span>
          <span class="token hvariable">actN</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="monads-as-a-programmable-semicolon" tabindex="-1"><a class="header-anchor" href="#monads-as-a-programmable-semicolon"><span>Monads: 可编程分号</span></a></h3>`,82),C=a("p",null,[s("在"),a("code",{class:"interpreted-text",role:"ref"},"the-offside-rule-is-not-mandatory"),s(" 里面提到过缩进排版是Haskell的标准，但是这并不是必要的。我们可以使用 "),a("code",null,"do"),s(" 表示法来替代缩进排版。")],-1),I=n(`<div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">semicolon</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token punctuation">{</span>
    <span class="token hvariable">act1</span><span class="token punctuation">;</span>
    <span class="token hvariable">val1</span> <span class="token operator">&lt;-</span> <span class="token hvariable">act2</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token hvariable">val2</span> <span class="token operator">=</span> <span class="token hvariable">expr1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token hvariable">actN</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token comment">-- file: ch14/Do.hs</span>
<span class="token hvariable">semicolonTranslated</span> <span class="token operator">=</span>
    <span class="token hvariable">act1</span> <span class="token operator">&gt;&gt;</span>
    <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token hvariable">val1</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token hvariable">val2</span> <span class="token operator">=</span> <span class="token hvariable">expr1</span>
                 <span class="token keyword">in</span> <span class="token hvariable">actN</span>
        <span class="token hvariable">f</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token builtin">fail</span> <span class="token string">&quot;...&quot;</span>
    <span class="token keyword">in</span> <span class="token hvariable">act2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然很少人有这么用，但是在单个表达式里面显式地使用分号容易让人产生这种感觉：monads是一种&quot;可编程的分号&quot;，因为在每个monad里面 <code>(&gt;&gt;=)</code> 和 <code>(&gt;&gt;)</code> 的行为都是不一样的。</p><h3 id="why-go-sugar-free" tabindex="-1"><a class="header-anchor" href="#why-go-sugar-free"><span>为什么要sugar-free</span></a></h3><p>当我们在代码里面显式使用 <code>(&gt;&gt;=)</code> 的时候，它提醒我们在使用组合子组合函数而不是简单的序列化动作。</p><p>如果你对monad感觉还很陌生，那么我建议你多显式地使用 <code>(&gt;&gt;=)</code> 而不是 <code>do</code> 语法来写monadic的代码。这些重复对于大多数的程序员来说都能帮助理解。</p><p>当熟悉了monad的时候，你可以按照需要选择你自己的风格；但是永远不要再同一个函数里面混用 <code>do</code> 和 <code>(&gt;&gt;=)</code> 。</p><p>不管你用不用do表示法， <code>(=&lt;&lt;)</code> 函数经常被使用；它就是 <code>(&gt;&gt;=)</code> 的参数翻转版本。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token operator">=</span><span class="token punctuation">)</span> :: <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> m a -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> m b
ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token operator">=</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">=</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">)</span> :: <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> m a -<span class="token operator">&gt;</span> m b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想把monadic函数按照通常Haskell从右往左结合起来的话，那么 <code>(=&lt;&lt;)</code> 非常有用。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/CartesianProduct.hs</span>
<span class="token hvariable">wordCount</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token builtin">length</span> <span class="token operator">.</span> <span class="token builtin">words</span> <span class="token operator">=&lt;&lt;</span> <span class="token builtin">getContents</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="the-state-monad" tabindex="-1"><a class="header-anchor" href="#the-state-monad"><span>状态monad</span></a></h2>`,11),T=a("p",null,[s("在 "),a("code",{class:"interpreted-text",role:"doc"},"10"),s(" 里面我们说 "),a("code",null,"Parse"),s(" 是一个monad。"),a("code",null,"Parser"),s(" 有两个完全不同的角度像Monad，其一是它在解析失败时候的行为------我们使用 "),a("code",null,"Either"),s(" 表达；其二是它携带这一些隐式的状态信息（每次被部分消耗的 "),a("code",null,"ByteString"),s(" .")],-1),B=n(`<p>在Haskell里面读写状态这种场景太常见了，因此标准库提供了一个叫做 <code>State</code> 的monad解决这个问题。在 <code>Control.Monad.State</code> 这个模块可以找到它。</p><p>我们的 <code>Parse</code> 类型能携带一个 <code>ByteString</code> 类型的状态， <code>State</code> monad可以携带任意类型的状态。姑且把这个未知状态的类型记为 <code>s</code> .</p><p>我们能对一个状态做什么？给定一个状态的值，我们可以查看这个状态，产生一个结果然后返回一个新的状态。假设计算的结果类型是 <code>a</code> . 那么表达这个过程的类型就是 <code>s -&gt; (a, s)</code> : 接受一个状态 <code>s</code> 对它进行某些操作，返回结果 <code>a</code> 和新状态 <code>s</code> .</p><h3 id="almost-a-state-monad" tabindex="-1"><a class="header-anchor" href="#almost-a-state-monad"><span>自己定义State monad</span></a></h3><p>我们先自己实现一个State monad，然后看看标准库的实现是什么样的。首先我们从类型定义开始，正如上面我们已经讨论过的，State的类型定义如下：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/SimpleState.hs</span>
<span class="token keyword">type</span> <span class="token constant">SimpleState</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们定义的monad是把一个状态转换为另外一个状态的函数，在转化的过程中产生一个计算结果。因此，state monad也经常被称为状态转换monad。</p><p>在这一章的开始，我们说过monad有一个带单个类型参数的类型构造器，但是这里我们有两个类型参数。理解这里的关键是，我们可以把类型构造器像使用函数一样部分应用（partially apply）；下面是一个最简单的例子。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/SimpleState.hs</span>
<span class="token keyword">type</span> <span class="token constant">StringState</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">SimpleState</span> <span class="token constant">String</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们把类型变量 <code>s</code> 固定为了 <code>String</code> 类型。 <code>StringState</code> 还带有一个类型参数 <code>a</code> ；这样就能比较明显的看出来这个类型与Monad类型构造器比较匹配了。换句话说，现在monad的类型构造器是 <code>SimpleState s</code> ,而不是单独的 <code>SimpleState</code> .</p><p>实现这个State monad接下来要做的就是定义 <code>return</code> 函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/SimpleState.hs</span>
<span class="token hvariable">returnSt</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">SimpleState</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span>
<span class="token hvariable">returnSt</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token operator">\\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 <code>return</code> 函数所做的就是接受一个结果和当前状态，把它包装成一个二元组，然后返回。你现在应该已经习惯了Haskell把带有多个参数的函数当成一系列单个参数函数的串联调用，以下是另一种更直观的写法：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/SimpleState.hs</span>
<span class="token hvariable">returnAlt</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">SimpleState</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span>
<span class="token hvariable">returnAlt</span> <span class="token hvariable">a</span> <span class="token hvariable">s</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现自定义的State monad最后一步就是定义 <code>(&gt;&gt;=)</code> 。下面是标准库的 <code>State</code> monad对于 <code>(&gt;&gt;=)</code> 的实现：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/SimpleState.hs</span>
<span class="token hvariable">bindSt</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">SimpleState</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">SimpleState</span> <span class="token hvariable">s</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">SimpleState</span> <span class="token hvariable">s</span> <span class="token hvariable">b</span>
<span class="token hvariable">bindSt</span> <span class="token hvariable">m</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token operator">\\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s&#39;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">m</span> <span class="token hvariable">s</span>
                   <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">k</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token hvariable">s&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些单个参数的变量不太容易懂，先把它们换成一些更可读的名字。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/SimpleState.hs</span>
<span class="token comment">-- m == step</span>
<span class="token comment">-- k == makeStep</span>
<span class="token comment">-- s == oldState</span>

<span class="token hvariable">bindAlt</span> <span class="token hvariable">step</span> <span class="token hvariable">makeStep</span> <span class="token hvariable">oldState</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">result</span><span class="token punctuation">,</span> <span class="token hvariable">newState</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">step</span> <span class="token hvariable">oldState</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">makeStep</span> <span class="token hvariable">result</span><span class="token punctuation">)</span> <span class="token hvariable">newState</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="reading-and-modifying-the-state" tabindex="-1"><a class="header-anchor" href="#reading-and-modifying-the-state"><span>读取和修改状态</span></a></h3><p><code>(&gt;&gt;=)</code> 和 <code>return</code> 的定义仅仅转移状态，但是并不对状态内部做任何事情。因此我们需要一些简单的辅助函数来对状态进行操作。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/SimpleState.hs</span>
<span class="token hvariable">getSt</span> <span class="token operator">::</span> <span class="token constant">SimpleState</span> <span class="token hvariable">s</span> <span class="token hvariable">s</span>
<span class="token hvariable">getSt</span> <span class="token operator">=</span> <span class="token operator">\\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>

<span class="token comment">-- \`\`getSt\`\` 函数就是接受当前状态并把它作为计算结果和状态一并返回； \`\`putSt\`\` 函数忽略当前状态并使用一个新的状态取代它。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="will-the-real-state-monad-please-stand-up" tabindex="-1"><a class="header-anchor" href="#will-the-real-state-monad-please-stand-up"><span>真正的State monad定义</span></a></h3><p>我们之前实现的 <code>SimpleState</code> 仅仅使用了类型别名而不是使用一个新的类型；如果我们当时就使用 <code>newtype</code> 包装一个新的类型，那么对于这个类型的处理会使我们的代码不太容易懂。</p><p>要定义一个Monad的实例，除了实现 <code>(&gt;&gt;=)</code> 和 <code>return</code> 还要提供一个合适的类型构造器。这正是标准库的 <code>State</code> Monad的做法：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/State.hs</span>
<span class="token keyword">newtype</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token punctuation">{</span>
      <span class="token hvariable">runState</span> <span class="token operator">::</span> <span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里所做的就是把 <code>s -&gt; (a, s)</code> 类型用 <code>State</code> 构造器包装起来。通过使用Haskell的纪录语法来定义新类型，我们自动获得了一个 <code>runState</code> 函数来从类型构造器里面提取状态值。 <code>runState</code> 的类型是 <code>State s a -&gt; s -&gt; (a, s)</code></p><p>标准库的State monad中 <code>return</code> 的定义和我们的 <code>SimpleState</code> 的 <code>return</code> 定义基本相同，只不过这里使用 <code>State</code> 构造器包装了一下状态函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/State.hs</span>
<span class="token hvariable">returnState</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span>
<span class="token hvariable">returnState</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 <code>(&gt;&gt;=)</code> 要使用 <code>runState</code> 函数来提取 <code>State</code> 的值，因此它的的定义略微复杂一些。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/State.hs</span>
<span class="token hvariable">bindState</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">b</span>
<span class="token hvariable">bindState</span> <span class="token hvariable">m</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">s&#39;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">runState</span> <span class="token hvariable">m</span> <span class="token hvariable">s</span>
                              <span class="token keyword">in</span> <span class="token hvariable">runState</span> <span class="token punctuation">(</span><span class="token hvariable">k</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token hvariable">s&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数与我们之前在 <code>SimpleState</code> 里面定义的 <code>bindSt</code> 函数唯一的不同是它有提取和包装一些值的操作。</p><p>同样，我们也修改了读取和修改状态的函数（提取和包装了一些值）：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/State.hs</span>
<span class="token hvariable">get</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">s</span>
<span class="token hvariable">get</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>

<span class="token hvariable">put</span> <span class="token operator">::</span> <span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">put</span> <span class="token hvariable">s</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">s</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="using-the-state-monad-generating-random-values" tabindex="-1"><a class="header-anchor" href="#using-the-state-monad-generating-random-values"><span>使用State monad生成随机数</span></a></h3><p>之前我们使用 <code>Parse</code> 解析二进制数据，当时我们把要管理的状态直接放在了 <code>Parse</code> 类型里面。</p><p>其实 <code>State</code> monad可以接受任意的类型作为状态参数，我们可以提供这个状态类型，比如 <code>State ByteString</code>.</p><p>如果你有命令式编程语言的背景的话，相对于别的很多monad，你可能对 <code>State</code> 这个monad更加熟悉。毕竟命令式语言所做的就是携带和转移一些隐式的状态，比如读写某些部分，通过赋值修改一些东西；这正是State monad所做的。</p><p>既然这样，我们不用费力地解释怎么使用State monad了，直接来个实际的例子就好：生成伪随机数。在命令式编程语言里面，通常有一些很方便使用的均匀分布的伪随机数源；比如在C语言标准库里面，有一个 <code>rand</code> 函数使用一个全局的状态生成伪随机数。</p><p>Haskell标准库里面生成伪随机数的模块叫做 <code>System.Random</code> ，它可以生成任意类型的随机数，而不仅仅是数值类型。这个模块提供了一些非常实用的函数。比如与C语言里面 <code>rand</code> 等价的函数如下：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>

<span class="token hvariable">rand</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token constant">Int</span>
<span class="token hvariable">rand</span> <span class="token operator">=</span> <span class="token hvariable">getStdRandom</span> <span class="token punctuation">(</span><span class="token hvariable">randomR</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">maxBound</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（ <code>randomR</code> 函数接受一个希望生成的随机数所在范围的闭区间。）</p><p><code>System.Random</code> 模块提供了一个 <code>RandomGen</code> 类型类，它允许我们自行定义一个新的随机整数源。 <code>StdGen</code> 类型是标准的 <code>RandomGen</code> 的实例，它可以生成伪随机数值。如果我们有一个外部的真实可靠的随机数源，我们可以创建一个 <code>RandomGen</code> 的实例来创建真实的随机数，而不是使用伪随机数。</p><p><code>Random</code> 这个类型类展示了如何给特定的类型生成随机数值。这个模块给所有常见的简单类型创建了 <code>Random</code> 的实例。</p><p>顺便说下，前面定义的 <code>rand</code> 函数也会读取和修改 <code>IO</code> monad中内置的全局随机数生成器。</p><h3 id="a-first-attempt-at-purity" tabindex="-1"><a class="header-anchor" href="#a-first-attempt-at-purity"><span>实用纯函数生成随机数的尝试</span></a></h3><p>我们一直尽量避免使用 <code>IO</code> monad，如果仅仅是为了生成随机数就要打破这一点就有点不好意思了。实际上， <code>System.Random</code> 模块里面提供了一些纯函数来生成随机数。</p><p>使用传统纯函数的缺点是，我们得获取或者手动创建一个随机数生成器，然后把它传递到需要得地方，最终调用这个纯函数的时候回传一个新的随机数生成器：要记住的是，我们是纯函数，所以不能修改已经存在的随机数生成器。</p><p>如果我们不管不变性而是直接复用原来的随机数生成器，那么每次我们调用这个函数都会得到完全一样的&quot;随机数&quot;。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token hvariable">twoBadRandoms</span> <span class="token operator">::</span> <span class="token constant">RandomGen</span> <span class="token hvariable">g</span> <span class="token operator">=&gt;</span> <span class="token hvariable">g</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token hvariable">twoBadRandoms</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">fst</span> <span class="token operator">$</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span><span class="token punctuation">,</span> <span class="token builtin">fst</span> <span class="token operator">$</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span><span class="token punctuation">)</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">twoBadRandoms</span> <span class="token operator">\`fmap\`</span> <span class="token hvariable">getStdGen</span>
<span class="token constant">Loading</span> <span class="token hvariable">package</span> <span class="token hvariable">old</span><span class="token operator">-</span><span class="token hvariable">locale</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">.</span><span class="token number">0.0</span> <span class="token operator">...</span> <span class="token hvariable">linking</span> <span class="token operator">...</span> <span class="token hvariable">done</span><span class="token punctuation">.</span>
<span class="token constant">Loading</span> <span class="token hvariable">package</span> <span class="token hvariable">old</span><span class="token operator">-</span><span class="token hvariable">time</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">.</span><span class="token number">0.0</span> <span class="token operator">...</span> <span class="token hvariable">linking</span> <span class="token operator">...</span> <span class="token hvariable">done</span><span class="token punctuation">.</span>
<span class="token constant">Loading</span> <span class="token hvariable">package</span> <span class="token hvariable">random</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">.</span><span class="token number">0.0</span> <span class="token operator">...</span> <span class="token hvariable">linking</span> <span class="token operator">...</span> <span class="token hvariable">done</span><span class="token punctuation">.</span>
<span class="token constant">Loading</span> <span class="token hvariable">package</span> <span class="token hvariable">mtl</span><span class="token operator">-</span><span class="token number">1.1</span><span class="token punctuation">.</span><span class="token number">0.0</span> <span class="token operator">...</span> <span class="token hvariable">linking</span> <span class="token operator">...</span> <span class="token hvariable">done</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span><span class="token number">945769311181683171</span><span class="token punctuation">,</span><span class="token number">945769311181683171</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 <code>random</code> 函数有一个默认的随机数生成范围，而不是像 <code>randomR</code> 一样接受用户传递的参数范围； <code>getStdGen</code> 函数从 <code>IO</code> monad里面获取全局的标准数据生成器的值。</p><p>不幸的是，如果我们把第一个随机数生成之后新的生成器的值正确地传递给第二个随机数的生成过程，代码就不太可读了，下面是个简单的例子：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token hvariable">twoGoodRandoms</span> <span class="token operator">::</span> <span class="token constant">RandomGen</span> <span class="token hvariable">g</span> <span class="token operator">=&gt;</span> <span class="token hvariable">g</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">g</span><span class="token punctuation">)</span>
<span class="token hvariable">twoGoodRandoms</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">gen&#39;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span>
                         <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">gen&#39;&#39;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">gen&#39;</span>
                     <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">gen&#39;&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们学到了 <code>State</code> monad, 它好像是个比较好的解决办法。 state monad 允许我们整洁地管理可变的状态，并且保证这部分代码与任何诸如修改文件，连接网络等副作用操作分离开来；这样让我们能够更加容易地思考代码的行为。</p><h3 id="random-values-in-the-state-monad" tabindex="-1"><a class="header-anchor" href="#random-values-in-the-state-monad"><span>state monad里面的随机数值</span></a></h3><p>下面是一个使用 <code>StdGen</code> 作为状态的state monad：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token keyword">type</span> <span class="token constant">RandomState</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token constant">StdGen</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的类型别名不是必要的，但是很有用；其一它可以让我们少敲几个字符，其二，如果我们想使用别的随机数生成器而不是 <code>StdGen</code> ，我们可以少修改一些类型签名。</p><p>有了 <code>RandomState</code> ，生成随机数值就是获取当前的随机数生成器，使用它然后用新的随机数生成器修改当前状态就行了。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token hvariable">getRandom</span> <span class="token operator">::</span> <span class="token constant">Random</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">RandomState</span> <span class="token hvariable">a</span>
<span class="token hvariable">getRandom</span> <span class="token operator">=</span>
  <span class="token hvariable">get</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\\</span><span class="token hvariable">gen</span> <span class="token operator">-&gt;</span>
  <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">val</span><span class="token punctuation">,</span> <span class="token hvariable">gen&#39;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span> <span class="token keyword">in</span>
  <span class="token hvariable">put</span> <span class="token hvariable">gen&#39;</span> <span class="token operator">&gt;&gt;</span>
  <span class="token builtin">return</span> <span class="token hvariable">val</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们可以用之前学到的知识写一些monadic的代码来生成一对随机数：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token hvariable">getTwoRandoms</span> <span class="token operator">::</span> <span class="token constant">Random</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">RandomState</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">getTwoRandoms</span> <span class="token operator">=</span> <span class="token hvariable">liftM2</span> <span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token hvariable">getRandom</span> <span class="token hvariable">getRandom</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>^^^^ 1. 用 <code>do</code> 重写 <code>getRandom</code> 函数</p><h3 id="running-the-state-monad" tabindex="-1"><a class="header-anchor" href="#running-the-state-monad"><span>运行state monad</span></a></h3><p>之前提到过，每个monad都有他自己的求值函数；在state monad里面，有几个求值函数可供选择。</p><ol><li><code>runState</code> 返回求值结果和最终状态</li><li><code>evalState</code> 只返回结果</li><li><code>execState</code> 只返回最终状态</li></ol><blockquote><p><code>evalState</code> 和 <code>execState</code> 函数其实就是 <code>runState</code> 和 <code>fst</code> , <code>snd</code> 函数的简单组合。所以三个里面最重要的是要记住 <code>runState</code> .</p></blockquote><p>下面是实现 <code>getTwoRandoms</code> 一个完整的例子：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token hvariable">runTwoRandoms</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token hvariable">runTwoRandoms</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token hvariable">oldState</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getStdGen</span>
  <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">result</span><span class="token punctuation">,</span> <span class="token hvariable">newState</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">runState</span> <span class="token hvariable">getTwoRandoms</span> <span class="token hvariable">oldState</span>
  <span class="token hvariable">setStdGen</span> <span class="token hvariable">newState</span>
  <span class="token builtin">return</span> <span class="token hvariable">result</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="管理更多的状态" tabindex="-1"><a class="header-anchor" href="#管理更多的状态"><span>管理更多的状态</span></a></h3><p>很难想象针对单个状态我们竟写了这么多有趣的代码，当我们想一次性纪录多个状态的时候，通常的办法是把这些状态放在一个数据结构里面管理。下面是一个纪录我们生成随机数数目的例子：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token keyword">data</span> <span class="token constant">CountedRandom</span> <span class="token operator">=</span> <span class="token constant">CountedRandom</span> <span class="token punctuation">{</span>
      <span class="token hvariable">crGen</span> <span class="token operator">::</span> <span class="token constant">StdGen</span>
    <span class="token punctuation">,</span> <span class="token hvariable">crCount</span> <span class="token operator">::</span> <span class="token constant">Int</span>
    <span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token constant">CRState</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token constant">CountedRandom</span>

<span class="token hvariable">getCountedRandom</span> <span class="token operator">::</span> <span class="token constant">Random</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">CRState</span> <span class="token hvariable">a</span>
<span class="token hvariable">getCountedRandom</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token hvariable">st</span> <span class="token operator">&lt;-</span> <span class="token hvariable">get</span>
  <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">val</span><span class="token punctuation">,</span> <span class="token hvariable">gen&#39;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token punctuation">(</span><span class="token hvariable">crGen</span> <span class="token hvariable">st</span><span class="token punctuation">)</span>
  <span class="token hvariable">put</span> <span class="token constant">CountedRandom</span> <span class="token punctuation">{</span> <span class="token hvariable">crGen</span> <span class="token operator">=</span> <span class="token hvariable">gen&#39;</span><span class="token punctuation">,</span> <span class="token hvariable">crCount</span> <span class="token operator">=</span> <span class="token hvariable">crCount</span> <span class="token hvariable">st</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span>
  <span class="token builtin">return</span> <span class="token hvariable">val</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的函数每次被调用的时候都会处理状态的两个元素然后返回一个全新的状态；更常见的情况是我们只需要读写整个状态的某一部分；下面的函数可以获取当前生成过的随机数的数目：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token hvariable">getCount</span> <span class="token operator">::</span> <span class="token constant">CRState</span> <span class="token constant">Int</span>
<span class="token hvariable">getCount</span> <span class="token operator">=</span> <span class="token hvariable">crCount</span> <span class="token operator">\`liftM\`</span> <span class="token hvariable">get</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子也说明了我们为什么要使用纪录语法定义 <code>CountedRandom</code> 状态；使用纪录函数提供的访问函数，把它与 <code>get</code> 函数结合起来可以很方便地读取状态的特定部分。</p><p>如果想要更新整个状态的某一部分，下面的代码可能不是很吸引人：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token hvariable">putCount</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">CRState</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">putCount</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token hvariable">st</span> <span class="token operator">&lt;-</span> <span class="token hvariable">get</span>
  <span class="token hvariable">put</span> <span class="token hvariable">st</span> <span class="token punctuation">{</span> <span class="token hvariable">crCount</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一段代码我们使用了纪录更新语法而不是用一个函数。表达式 <code>st { crCount = a }</code> 会创建一个和 <code>st</code> 几乎完全相等的值，只是使用给定的 <code>a</code> 作为 <code>crCount</code> 字段的值。由于这是个语法上的小技巧，因此它没有使用函数那么灵活。纪录语法可能并没有Haskell通常的语法那么优雅，但是至少它能完成我们的目的。</p><p>函数 <code>modify</code> 组合了 <code>get</code> 和 <code>put</code> ，它接受一个状态转换函数，但是依然不太令人满意：还是需要使用纪录语法。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/Random.hs</span>
<span class="token hvariable">putCountModify</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">CRState</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">putCountModify</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">modify</span> <span class="token operator">$</span> <span class="token operator">\\</span><span class="token hvariable">st</span> <span class="token operator">-&gt;</span> <span class="token hvariable">st</span> <span class="token punctuation">{</span> <span class="token hvariable">crCount</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="monad-and-functors" tabindex="-1"><a class="header-anchor" href="#monad-and-functors"><span>Monad和Functors</span></a></h2><p>Functor和Monad之间有非常紧密的联系，这两个术语是从数学里面的范畴论引入的，但是又与数学定义不完全相同。</p><p>在范畴论里面，monad通过functor构建出来。你可能希望在Haskell里面也是这样，也就是 <code>Monad</code> 这个类型类是 <code>Functor</code> 类型类的子类；但是在标准库的Prelude里面并不是这么定义的。这是个很不幸的疏忽。</p><p>但是，Haskell库的作者们提供了一个变通方案：一旦他们写了一个 <code>Monad</code> 的实例，几乎总是也给 <code>Functor</code> 定义一个实例。所以对于任何monad你都可以使用 <code>Functor</code> 类型类的 <code>fmap</code> 函数。</p><p>如果把 <code>fmap</code> 函数的类型签名与我们已经见到过标准库里面Monad的一些函数做比较，大致就知道在monad里面 <code>fmap</code> 函数是干什么的了。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type fmap
fmap :: <span class="token punctuation">(</span>Functor f<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> f a -<span class="token operator">&gt;</span> f b
ghci<span class="token operator">&gt;</span> :module +Control.Monad
ghci<span class="token operator">&gt;</span> :type liftM
liftM :: <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a1 -<span class="token operator">&gt;</span> r<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> m a1 -<span class="token operator">&gt;</span> m r
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出， <code>fmap</code> 函数作用和 <code>liftM</code> 一样，它把一个纯函数lift到monad里面。</p><h3 id="换个角度看monad" tabindex="-1"><a class="header-anchor" href="#换个角度看monad"><span>换个角度看Monad</span></a></h3><p>我们已经知道了monad和functor之间的联系，如果回头再看看List这个monad，会发现一些有趣的东西；具体来说，是list的 <code>(&gt;&gt;=)</code> 定义。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/ListMonad.hs</span>
<span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>

<span class="token comment">-- \`\`f\`\` 的类型是 \`\`a -&gt; [a]\`\` 我们调用 \`\`map f xs\`\` 的时候，我们会得到一个类型是 \`\`[[a]]\`\` 的值，然后我们必须使用 \`\`concat\`\` 把它“扁平化”（flatten).</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想一想如果 <code>Monad</code> 是 <code>Functor</code> 的子类的时候我们能做什么；由于list的 <code>fmap</code> 定义就是 <code>map</code> , 在 <code>(&gt;&gt;=)</code> 定义里面我们可以使用 <code>fmap</code> 替换 <code>map</code> .这个替换本身并没有什么特殊意义，我们再进一步探讨一下。</p><blockquote><p><code>concat</code> 函数的类型是 <code>[[a]] -&gt; [a]</code> :正如我们提到的，它把一个嵌套的列表压平。我们可以把list的这函数的类型签名从list推广到所有monad，也就是一个&quot;移除一层嵌套&quot;的类型 <code>m (m a) -&gt; m a</code>; 具有这种类型前面的函数通常叫做 <code>join</code> .</p></blockquote><p>如果已经有了 <code>join</code> 和 <code>fmap</code> 的定义，我们就不需要为每一个monad定义一个 <code>(&gt;&gt;=)</code> 函数了，因为它完全可以由 <code>join</code> 和 <code>fmap</code> 定义出来。下面是 <code>Monad</code> 类型类另外一种定义方式。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/AltMonad.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> Prelude <span class="token keyword">hiding</span></span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">return</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token constant">AltMonad</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token hvariable">join</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
    <span class="token builtin">return</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>

<span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">AltMonad</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不能说哪一种定义比另外一种更好，因为有了 <code>join</code> 我们可以定义 <code>(&gt;&gt;=)</code> ，反之亦然。但是这两个不同的角度给了我们对Monad全新的认识。</p><p>移除一层monadic包装实际上是非常有用的，在 <code>Control.Monad</code> 里面由一个标准的 <code>join</code> 定义。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadJoin.hs</span>
<span class="token hvariable">join</span> <span class="token operator">::</span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
<span class="token hvariable">join</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token builtin">id</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一些使用 <code>join</code> 的例子。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token function">join</span> <span class="token punctuation">(</span>Just <span class="token punctuation">(</span>Just <span class="token number">1</span><span class="token punctuation">))</span>
Just <span class="token number">1</span>
ghci<span class="token operator">&gt;</span> <span class="token function">join</span> Nothing
Nothing
ghci<span class="token operator">&gt;</span> <span class="token function">join</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">2,3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="the-monad-laws-and-good-coding-style" tabindex="-1"><a class="header-anchor" href="#the-monad-laws-and-good-coding-style"><span>单子律以及代码风格</span></a></h2>`,99),H=a("p",null,[s("在 "),a("code",{class:"interpreted-text",role:"ref"},"thinking-more-about-functors"),s(" 里面我们介绍了functors必须遵从的两条规则：")],-1),A=n(`<div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token builtin">fmap</span> <span class="token builtin">id</span>        <span class="token operator">==</span>   <span class="token builtin">id</span> 
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span><span class="token punctuation">)</span>   <span class="token operator">==</span>   <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token builtin">fmap</span> <span class="token hvariable">g</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>monads也有它们必须遵从的规则。下面的三条规则被称为单子律。Haskell并不会强制检查这些规则：完全由monad的作者保证。</p><p>单子律就是简单而正式地表达&quot;某个单子不会表现得让人惊讶&quot;的意思。原则上讲，我们可以完全不管这些规则定义自己的monad，但是如果我们这么干会为人所不齿的；因为单子律有一些我们可能忽视的宝藏。</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>下面的每一条规则，<code>==</code> 左边的表达式等价于右边的表达式。</p></div><p>第一条规则说的是 <code>return</code> 是 <code>(&gt;&gt;=)</code> 的 <em>Left identity</em>.</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span>            <span class="token operator">===</span>   <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一种理解这条规则的方式是：如果我们仅仅是把一个纯值包装到monad里面然后使用 <code>(&gt;&gt;=)</code> 调用的话，我们就没有必要使用 <code>return</code> 了；使用monad的新手通常所犯的错误就是使用 <code>return</code> 把一个纯值包装为monadic的，然后接下来由使用 <code>(&gt;&gt;=)</code> 把这个值取出来。下面是使用do表示法表达这个规律的等价形式：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token keyword">do</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token hvariable">x</span>
   <span class="token hvariable">f</span> <span class="token hvariable">y</span>                    <span class="token operator">===</span>   <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这条规则对于我们的代码风格有着实际上的指导意义：我们不想写一些不必要的代码；这条规则保证了简短的写法和冗余的写法是等价的。</p><p>单子律的第二条说的是 <code>return</code> 是 <code>(&gt;&gt;=)</code> 的 <em>Right identity</em>.</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token builtin">return</span>              <span class="token operator">===</span>   <span class="token hvariable">m</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你以前使用命令式编程语言，那么这一条规则对风格也有好处：如果在一系列的action块里面，如果最后一句就是需要返回的正确结果，那么就不需要使用 <code>return</code> 了；看看使用 <code>do</code> 表示法如何表达这条规则：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token keyword">do</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token hvariable">m</span>
   <span class="token builtin">return</span> <span class="token hvariable">y</span>               <span class="token operator">===</span>   <span class="token hvariable">m</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和第一条规则一样，这条规律也能帮助我们简化代码。</p><p>单子律最后一条和结合性有关。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">g</span><span class="token punctuation">)</span>   <span class="token operator">===</span>   <span class="token punctuation">(</span><span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">g</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这条规则有点难理解，我们先看看等式两边括号里面的内容；等式左边可以重新表示成这样：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">s</span>
  <span class="token keyword">where</span> <span class="token hvariable">s</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">g</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等式右边也做类似的处理：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token hvariable">t</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">g</span>
  <span class="token keyword">where</span> <span class="token hvariable">t</span> <span class="token operator">=</span> <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们可以把上述规律表达成如下等价形式：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch14/MonadLaws.hs</span>
<span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">s</span>                   <span class="token operator">===</span>   <span class="token hvariable">t</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">g</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这条规则的意思是，如果我们把一个大的action分解成一系列的子action，只要我们保证子action的顺序，把哪些子action提取出来组合成一个新action对求值结果是没有影响的。如果我们由三个action串联在一起，我们可以把前两个action替换为它们的组合然后串联第三个，也可以用第一个action串联后面两个cation的组合。</p><p>这条较为复杂的规律对我们的代码风格也有一些意义。在软件重构里面，有一个专业术语叫做&quot;提取方法&quot;，它说的就是在一大段代码里面提取出一些代码片段然后组合成一个新的函数，在原始代码里面调用新的函数来取代提取出来的内容；第三条单子律保证了这种做法在Haskell的monadic代码里面也可以使用这种技术。</p><p>三条单子律都能帮助我们写出更好的monadic代码；前两条规则指导我们如何避免使用不必要的 <code>return</code> ，第三条规则让我们能安全地把一个复杂的action冲构成一系列小的action。我们现在可以不管这些细节，通过直觉我们知道在一个实现良好的monad里面，这些规则是不会被违背的。</p><p>顺便说一下，Haskell编译器并不并不能保证一个monad是否遵守单子律。monad的实现者必须确保自己的代码满足（最好是证明）单子律。</p>`,26),G=[l,c,i,r,d,k,u,v,h,b,m,g,f,y,x,M,w,S,L,q,_,R,N,P,C,I,T,B,H,A];function J(O,D){return t(),p("div",null,G)}const F=e(o,[["render",J],["__file","14.html.vue"]]),W=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/14.html","title":"第 14 章：Monads","lang":"zh-CN","frontmatter":{"description":"第 14 章：Monads 在 7 中，我们讨论了 IO monad，那时我们刻意把精力集中在如何与外界交互上，并没有讨论monad是什么。 在 7 中我们看到 IO Monad确实很好用；除了在语法上不同之外，在 IO monad中写代码跟其他命令式语言基本没有什么区别。 在前面的章节中，我们在解决一些实际问题的时候引入了一些数据结构，很快我们就会知...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/14.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"第 14 章：Monads"}],["meta",{"property":"og:description","content":"第 14 章：Monads 在 7 中，我们讨论了 IO monad，那时我们刻意把精力集中在如何与外界交互上，并没有讨论monad是什么。 在 7 中我们看到 IO Monad确实很好用；除了在语法上不同之外，在 IO monad中写代码跟其他命令式语言基本没有什么区别。 在前面的章节中，我们在解决一些实际问题的时候引入了一些数据结构，很快我们就会知..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-25T04:39:03.000Z"}],["meta",{"property":"article:author","content":"hahg"}],["meta",{"property":"article:modified_time","content":"2024-02-25T04:39:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第 14 章：Monads\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-25T04:39:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hahg\\"}]}"]]},"headers":[{"level":2,"title":"回顾之前代码","slug":"revisiting-earlier-code-examples","link":"#revisiting-earlier-code-examples","children":[{"level":3,"title":"Maybe链","slug":"maybe-chaining","link":"#maybe-chaining","children":[]},{"level":3,"title":"隐式状态","slug":"implicit-state","link":"#implicit-state","children":[]}]},{"level":2,"title":"寻找共同特征","slug":"looking-for-shared-patterns","link":"#looking-for-shared-patterns","children":[]},{"level":2,"title":"Monad 类型类","slug":"the-monad-typeclass","link":"#the-monad-typeclass","children":[]},{"level":2,"title":"术语解释","slug":"and-now-a-jargon-moment","link":"#and-now-a-jargon-moment","children":[]},{"level":2,"title":"使用新的Monad","slug":"using-a-new-monad-show-your-work","link":"#using-a-new-monad-show-your-work","children":[{"level":3,"title":"信息隐藏","slug":"information-hiding","link":"#information-hiding","children":[]},{"level":3,"title":"受控的Monad","slug":"controlled-escape","link":"#controlled-escape","children":[]},{"level":3,"title":"日志纪录","slug":"leaving-a-trace","link":"#leaving-a-trace","children":[]},{"level":3,"title":"使用 Logger monad","slug":"using-the-logger-monad","link":"#using-the-logger-monad","children":[]}]},{"level":2,"title":"同时使用puer和monadic代码","slug":"mixing-pure-and-monadic-code","link":"#mixing-pure-and-monadic-code","children":[]},{"level":2,"title":"关于Monad的一些误解","slug":"putting-a-few-misconceptions-to-rest","link":"#putting-a-few-misconceptions-to-rest","children":[]},{"level":2,"title":"创建Logger Monad","slug":"building-the-logger-monad","link":"#building-the-logger-monad","children":[{"level":3,"title":"顺序的日志，而不是顺序的求值","slug":"sequential-logging-not-sequential-evaluation","link":"#sequential-logging-not-sequential-evaluation","children":[]},{"level":3,"title":"Writer monad","slug":"the-writer-monad","link":"#the-writer-monad","children":[]}]},{"level":2,"title":"Maybe monad","slug":"the-maybe-monad","link":"#the-maybe-monad","children":[{"level":3,"title":"执行Maybe monad","slug":"executing-the-maybe-monad","link":"#executing-the-maybe-monad","children":[]},{"level":3,"title":"使用Maybe，以及好的API设计方式","slug":"maybe-at-work-and-good-api-design","link":"#maybe-at-work-and-good-api-design","children":[]}]},{"level":2,"title":"List Monad","slug":"the-list-monad","link":"#the-list-monad","children":[{"level":3,"title":"理解List monad","slug":"understanding-the-list-monad","link":"#understanding-the-list-monad","children":[]},{"level":3,"title":"使用List Monad","slug":"putting-the-list-monad-to-work","link":"#putting-the-list-monad-to-work","children":[]}]},{"level":2,"title":"还原do的本质","slug":"desugaring-of-do-blocks","link":"#desugaring-of-do-blocks","children":[{"level":3,"title":"Monads: 可编程分号","slug":"monads-as-a-programmable-semicolon","link":"#monads-as-a-programmable-semicolon","children":[]},{"level":3,"title":"为什么要sugar-free","slug":"why-go-sugar-free","link":"#why-go-sugar-free","children":[]}]},{"level":2,"title":"状态monad","slug":"the-state-monad","link":"#the-state-monad","children":[{"level":3,"title":"自己定义State monad","slug":"almost-a-state-monad","link":"#almost-a-state-monad","children":[]},{"level":3,"title":"读取和修改状态","slug":"reading-and-modifying-the-state","link":"#reading-and-modifying-the-state","children":[]},{"level":3,"title":"真正的State monad定义","slug":"will-the-real-state-monad-please-stand-up","link":"#will-the-real-state-monad-please-stand-up","children":[]},{"level":3,"title":"使用State monad生成随机数","slug":"using-the-state-monad-generating-random-values","link":"#using-the-state-monad-generating-random-values","children":[]},{"level":3,"title":"实用纯函数生成随机数的尝试","slug":"a-first-attempt-at-purity","link":"#a-first-attempt-at-purity","children":[]},{"level":3,"title":"state monad里面的随机数值","slug":"random-values-in-the-state-monad","link":"#random-values-in-the-state-monad","children":[]},{"level":3,"title":"运行state monad","slug":"running-the-state-monad","link":"#running-the-state-monad","children":[]},{"level":3,"title":"管理更多的状态","slug":"管理更多的状态","link":"#管理更多的状态","children":[]}]},{"level":2,"title":"Monad和Functors","slug":"monad-and-functors","link":"#monad-and-functors","children":[{"level":3,"title":"换个角度看Monad","slug":"换个角度看monad","link":"#换个角度看monad","children":[]}]},{"level":2,"title":"单子律以及代码风格","slug":"the-monad-laws-and-good-coding-style","link":"#the-monad-laws-and-good-coding-style","children":[]}],"git":{"createdTime":1708835943000,"updatedTime":1708835943000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":50.61,"words":15183},"filePathRelative":"学习/Haskell中文文档/14.md","localizedDate":"2024年2月25日","excerpt":"\\n<hr>\\n<p>在 <code class=\\"interpreted-text\\" role=\\"doc\\">7</code> 中，我们讨论了 <code>IO</code>\\nmonad，那时我们刻意把精力集中在如何与外界交互上，并没有讨论monad是什么。</p>\\n<p>在 <code class=\\"interpreted-text\\" role=\\"doc\\">7</code> 中我们看到 <code>IO</code> Monad确实很好用；除了在语法上不同之外，在 <code>IO</code> monad中写代码跟其他命令式语言基本没有什么区别。</p>\\n<p>在前面的章节中，我们在解决一些实际问题的时候引入了一些数据结构，很快我们就会知道它们其实就是monads。我们想告诉你的是，在解决某些问题的时候，monad通常是一个非常直观且实用的工具。本章我们将定义一些monads并告诉你它有多么简单。</p>","autoDesc":true}');export{F as comp,W as data};
