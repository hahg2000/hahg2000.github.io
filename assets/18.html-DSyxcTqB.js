import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,f as e}from"./app-Chw2KLnS.js";const o={},t=e(`<h1 id="第-18-章-monad变换器" tabindex="-1"><a class="header-anchor" href="#第-18-章-monad变换器"><span>第 18 章： Monad变换器</span></a></h1><h2 id="动机-避免样板代码" tabindex="-1"><a class="header-anchor" href="#动机-避免样板代码"><span>动机： 避免样板代码</span></a></h2><p>Monad提供了一种强大途径以构建带效果的计算。虽然各个标准monad皆专一于其特定的任务，但在实际代码中，我们常常想同时使用多种效果。</p><p>比如，回忆在第十章中开发的 <code>Parse</code> 类型。在介绍monad之时，我们提到这个类型其实是乔装过的 <code>State</code> monad。事实上我们的monad比标准的 <code>State</code> monad 更加复杂：它同时也使用了 <code>Either</code> 类型来表达解析过程中可能的失败。在这个例子中，我们想在解析失败的时候就立刻停止这个过程，而不是以错误的状态继续执行解析。这个monad同时包含了带状态计算的效果和提早退出计算的效果。</p><p>普通的 <code>State</code> monad不允许我们提早退出，因为其只负责状态的携带。其使用的是 <code>fail</code> 函数的默认实现：直接调用 <code>error</code> 抛出异常 － 这一异常无法在纯函数式的代码中捕获。因此，尽管 <code>State</code> monad似乎允许错误，但是这一能力并没有什么用。（再次强调：请尽量避免使用 <code>fail</code> 函数！）</p><p>理想情况下，我们希望能使用标准的 <code>State</code> monad，并为其加上实用的错误处理能力以代替手动地大量定制各种monad。虽然在 <code>mtl</code> 库中的标准monad不可合并使用，但使用库中提供了一系列的 <em>monad变换器</em> 可以达到相同的效果。</p><p>Monad变换器和常规的monad很类似，但它们并不是独立的实体。相反，monad变换器通过修改其以为基础的monad的行为来工作。 大部分 <code>mtl</code> 库中的monad都有对应的变换器。习惯上变换器以其等价的monad名为基础，加以 <code>T</code> 结尾。 例如，与 <code>State</code> 等价的变换器版本称作 <code>StateT</code> ； 它修改下层monad以增加可变状态。此外，若将 <code>WriterT</code> monad变换器叠加于其他（或许不支持数据输出的）monad之上，在被monad修改后的的monad中，输出数据将成为可能。</p><p>[注：<code>mtl</code> 意为monad变换器函数库(Monad Transformer Library)]</p><p>[译注：Monad变换器需要依附在一已有monad上来构成新的monad，在接下来的行文中将使用&quot;下层monad&quot;来称呼monad变换器所依附的那个monad]</p><h2 id="简单的monad变换器实例" tabindex="-1"><a class="header-anchor" href="#简单的monad变换器实例"><span>简单的Monad变换器实例</span></a></h2><p>在介绍monad变换器之前，先看看以下函数，其中使用的都是之前接触过的技术。这个函数递归地访问目录树，并返回一个列表，列表中包含树的每层的实体个数：</p><p>::: literalinclude /code/ch18/CountEntries.hs :::</p><p>现在看看如何使用 <code>Writer</code> monad 实现相同的目标。由于这个monad允许随时记下数值，所以并不需要我们显示地去构建结果。</p><p>为了遍历目录，这个函数必须在 <code>IO</code> monad中执行，因此我们无法直接使用 <code>Writer</code> monad。但我们可以用 <code>WriterT</code> 将记录信息的能力赋予 <code>IO</code> 。一种简单的理解方法是首先理解涉及的类型。</p><p>通常 <code>Writer</code> monad有两个类型参数，因此写作 <code>Writer w a</code> 更为恰当。其中参数 <code>w</code> 用以指明我们想要记录的数值的类型。而另一类型参数 <code>a</code> 是monad类型类所要求的。因此 <code>Writer [(FilePath，Int)] a</code> 是个记录一列目录名和目录大小的writer monad。</p><p><code>WriterT</code> 变换器有着类似的结构。但其增加了另外一个类型参数 <code>m</code> ：这便是下层monad，也是我们想为其增加功能的monad。 <code>WriterT</code> 的完整类型签名是 <code>Writer w m a</code>。</p><p>由于所需的目录遍历操作需要访问 <code>IO</code> monad，因此我们将writer功能累加在 <code>IO</code> monad之上。通过将monad变换器与原有monad结合，我们得到了类型签名：<code>WriterT [(FilePath， Int)] IO a</code> 这个monad变换器和monad的组合自身也是一个monad：</p><p>::: literalinclude /code/ch18/CountEntriesT.hs :::</p><p>代码与其先前的版本区别不大，需要时 <code>liftIO</code> 可以将 <code>IO</code> monad暴露出来；同时， <code>tell</code> 可以用以记下对目录的访问。</p><p>为了执行这一代码，需要选择一个 <code>WriterT</code> 的执行函数：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type runWriterT
runWriterT :: WriterT w m a -<span class="token operator">&gt;</span> m <span class="token punctuation">(</span>a, w<span class="token punctuation">)</span>
ghci<span class="token operator">&gt;</span> :type execWriterT
execWriterT :: Monad m <span class="token operator">=</span><span class="token operator">&gt;</span> WriterT w m a -<span class="token operator">&gt;</span> m w
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些函数都可以用以执行动作，移除 <code>WriterT</code> 的包装，并将结果交给其下层monad。其中 <code>runWriterT</code> 函数同时返回动作结果以及在执行过程获得的记录。而 <code>execWriterT</code> 丢弃动作的结果，只将记录返回。</p><p>因为没有 <code>IOT</code> 这样的monad变换器，所以此处我们在 <code>IO</code> 之上使用 <code>WriterT</code> 。一旦要用 <code>IO</code> monad和其他的一个或多个monad变换器结合， <code>IO</code> 一定在monad栈的最底下。</p><p>[译注：&quot;monad栈&quot;由monad和一个或多个monad变换器叠加而成，形成一个栈的结构。若在monad栈中需要 <code>IO</code> monad，由于没有对应的monad变换器（ <code>IOT</code> ），所以 <code>IO</code> monad只能位于整个monad栈的最底下。此外， <code>IO</code> 是一个很特殊的monad，它的 <code>IOT</code> 版本是无法实现的。]</p><h2 id="monad和monad变换器中的模式" tabindex="-1"><a class="header-anchor" href="#monad和monad变换器中的模式"><span>Monad和Monad变换器中的模式</span></a></h2><p>在 <code>mtl</code> 库中的大部分monad与monad变换器遵从一些关于命名和类型类的模式。</p><p>为说明这些规则，我们将注意力聚焦在一个简单的monad上： <code>reader</code> monad。<code>reader</code> monad的具体API位于 <code>MonadReader</code> 中。大部分 <code>mtl</code> 中的monad都有一个名称相对的类型类。例如 <code>MonadWriter</code> 定义了writer monad的API，以此类推。</p><p>::: literalinclude /code/ch18/Reader.hs :::</p><p>其中类型变量 <code>r</code> 表示reader monad所附带的不变状态， <code>Reader r</code> monad是个 <code>MonadReader</code> 的实例，同时 <code>ReaderT r m</code> monad变换器也是一个。这个模式同样也在其他的 <code>mtl</code> monad中重复着：通常有个具体的monad，和其对应的monad变换器，而它们都是相应命令的类型类的实例。这个类型类定义了功能相同的monad的API。</p><p>回到我们reader monad的例子中，我们之前尚未讨论过 <code>local</code> 函数。通过一个类型为 <code>r -&gt; r</code> 的函数，它可临时修改当前的环境，并在这一临时环境中执行其动作。举个具体的例子：</p><p>::: literalinclude /code/ch18/LocalReader.hs :::</p><p>若在 <code>ghci</code> 中执行 <code>localExample</code> ，可以观察到对环境修改的效果被限制在了一个地方：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> runReader localExample <span class="token string">&quot;Fred&quot;</span>
Loading package mtl-1.1.0.1 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
<span class="token punctuation">(</span><span class="token string">&quot;First, I am Fred&quot;</span>,<span class="token string">&quot;Second, I am Freddy&quot;</span>,<span class="token string">&quot;Third, I am Fred&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当下层monad <code>m</code> 是一个 <code>MonadIO</code> 的实例时， <code>mtl</code> 提供了关于 <code>ReaderT r m</code> 和其他类型类的实例，这里是其中的一些：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/Reader.hs</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">ReaderT</span> <span class="token hvariable">r</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token operator">...</span>

<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">MonadIO</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">MonadIO</span> <span class="token punctuation">(</span><span class="token constant">ReaderT</span> <span class="token hvariable">r</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token operator">...</span>

<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">MonadPlus</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">MonadPlus</span> <span class="token punctuation">(</span><span class="token constant">ReaderT</span> <span class="token hvariable">r</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次说明：为方便使用，大部分的 <code>mtl</code> monad变换器都定义了诸如此类的实例。</p><h2 id="叠加多个monad变换器" tabindex="-1"><a class="header-anchor" href="#叠加多个monad变换器"><span>叠加多个Monad变换器</span></a></h2><p>之前提到过，在常规monad上叠加monad变换器可得到另一个monad。由于混合的结果也是个monad，我们可以凭此为基础再叠加上一层monad变换器。事实上，这么做十分常见。但在什么情况下才需要创建这样的monad呢？</p><ul><li>若代码想和外界打交道，便需要 <code>IO</code> 作为这个monad栈的基础。否则普通的monad便可以满足需求。</li><li>加上一层 <code>ReaderT</code> ，以添加访问只读配置信息的能力。</li><li>叠加上 <code>StateT</code> ，就可以添加可修改的全局状态。</li><li>若想得到记录事件的能力，可以添加一层 <code>WriterT</code> 。</li></ul><p>这个做法的强大之处在于：我们可以指定所需的计算效果，以量身定制monad栈。</p><p>举个多重叠加的moand变换器的例子，这里是之前开发的 <code>countEntries</code> 函数。我们想限制其递归的深度，并记录下它在执行过程中所到达的最大深度：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/UglyStack.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Directory</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>FilePath</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Reader</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token keyword">data</span> <span class="token constant">AppConfig</span> <span class="token operator">=</span> <span class="token constant">AppConfig</span>
  <span class="token punctuation">{</span> <span class="token hvariable">cfgMaxDepth</span> <span class="token operator">::</span> <span class="token constant">Int</span>
  <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>

<span class="token keyword">data</span> <span class="token constant">AppState</span> <span class="token operator">=</span> <span class="token constant">AppState</span>
  <span class="token punctuation">{</span> <span class="token hvariable">stDeepestReached</span> <span class="token operator">::</span> <span class="token constant">Int</span>
  <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此处使用 <code>ReaderT</code> 来记录配置数据，数据的内容表示最大允许的递归深度。同时也使用了 <code>StateT</code> 来记录在实际遍历过程中所达到的最大深度。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/UglyStack.hs</span>
<span class="token keyword">type</span> <span class="token constant">App</span> <span class="token operator">=</span> <span class="token constant">ReaderT</span> <span class="token constant">AppConfig</span> <span class="token punctuation">(</span><span class="token constant">StateT</span> <span class="token constant">AppState</span> <span class="token constant">IO</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的变换器以 <code>IO</code> 为基础，依次叠加 <code>StateT</code> 与 <code>ReaderT</code> 。在此例中，栈顶是 <code>ReaderT</code> 还是 <code>WriterT</code> 并不重要，但是 <code>IO</code> 必须作为最下层monad。</p><p>仅仅几个monad变换器的叠加，也会使类型签名迅速变得复杂起来。故此处以 <code>type</code> 关键字定义类型别名，以简化类型的书写。</p><hr><h3 id="缺失的类型参数呢" tabindex="-1"><a class="header-anchor" href="#缺失的类型参数呢"><span>缺失的类型参数呢？</span></a></h3><p>或许你已注意到，此处的类型别名并没有我们为monad类型所常添加的类型参数 <code>a</code>：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/UglyStack.hs</span>
<span class="token keyword">type</span> <span class="token constant">App2</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">ReaderT</span> <span class="token constant">AppConfig</span> <span class="token punctuation">(</span><span class="token constant">StateT</span> <span class="token constant">AppState</span> <span class="token constant">IO</span><span class="token punctuation">)</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在常规的类型签名用例下， <code>App</code> 和 <code>App2</code> 不会遇到问题。但如果想以此类型为基础构建其他类型，两者的区别就显现出来了。</p><p>例如我们想另加一层monad变换器，编译器会允许 <code>WriterT [String] App a</code> 但拒绝 <code>WriterT [String] App2 a</code> 。</p><p>其中的理由是：Haskell不允许对类型别名的部分应用。 <code>App</code> 不需要类型参数，故没有问题。另一方面，因为 <code>App2</code> 需要一个类型参数，若想基于 <code>App2</code> 构造其他的类型，则必须为这个类型参数提供一个类型。</p><p>这一限制仅适用于类型别名，当构建monad栈时，通常的做法是用 <code>newtype</code> 来封装（接下来的部分就会看到这类例子）。 因此实际应用中很少出现这种问题。</p><p>[译注：类似于函数的部分应用，&quot;类型别名的部分应用&quot;指的是在应用类型别名时，给出的参数数量少于定义中的参数数量。在以上例子中， <code>App</code> 是一个完整的应用，因为在其定义 <code>type App = ...</code> 中，没有类型参数；而 <code>App2</code> 却是个部分应用，因为在其定义 <code>type App2 a = ...</code> 中，还需要一个类型参数 <code>a</code> 。]</p><hr><p>我们monad栈的执行函数很简单：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/UglyStack.hs</span>
<span class="token hvariable">runApp</span> <span class="token operator">::</span> <span class="token constant">App</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">AppState</span><span class="token punctuation">)</span>
<span class="token hvariable">runApp</span> <span class="token hvariable">k</span> <span class="token hvariable">maxDepth</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">config</span> <span class="token operator">=</span> <span class="token constant">AppConfig</span> <span class="token hvariable">maxDepth</span>
        <span class="token hvariable">state</span> <span class="token operator">=</span> <span class="token constant">AppState</span> <span class="token number">0</span>
    <span class="token keyword">in</span> <span class="token hvariable">runStateT</span> <span class="token punctuation">(</span><span class="token hvariable">runReaderT</span> <span class="token hvariable">k</span> <span class="token hvariable">config</span><span class="token punctuation">)</span> <span class="token hvariable">state</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对 <code>runReaderT</code> 的应用移除了 <code>ReaderT</code> 变换器的包装，之后 <code>runStateT</code> 移除了 <code>StateT</code> 的包装，最后的结果便留在 <code>IO</code> monad中。</p><p>和先前的版本相比，我们的修改并未使代码复杂太多，但现在函数却能记录目前的路径，和达到的最大深度：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token hvariable">constrainedCount</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">App</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">FilePath</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">constrainedCount</span> <span class="token hvariable">curDepth</span> <span class="token hvariable">path</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token hvariable">liftIO</span> <span class="token operator">.</span> <span class="token hvariable">listDirectory</span> <span class="token operator">$</span> <span class="token hvariable">path</span>
    <span class="token hvariable">cfg</span> <span class="token operator">&lt;-</span> <span class="token hvariable">ask</span>
    <span class="token hvariable">rest</span> <span class="token operator">&lt;-</span> <span class="token hvariable">forM</span> <span class="token hvariable">contents</span> <span class="token operator">$</span> <span class="token operator">\\</span><span class="token hvariable">name</span> <span class="token operator">-&gt;</span> <span class="token keyword">do</span>
        <span class="token keyword">let</span> <span class="token hvariable">newPath</span> <span class="token operator">=</span> <span class="token hvariable">path</span> <span class="token operator">&lt;/&gt;</span> <span class="token hvariable">name</span>
        <span class="token hvariable">isDir</span> <span class="token operator">&lt;-</span> <span class="token hvariable">liftIO</span> <span class="token operator">$</span> <span class="token hvariable">doesDirectoryExist</span> <span class="token hvariable">newPath</span>
        <span class="token keyword">if</span> <span class="token hvariable">isDir</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">curDepth</span> <span class="token operator">&lt;</span> <span class="token hvariable">cfgMaxDepth</span> <span class="token hvariable">cfg</span>
          <span class="token keyword">then</span> <span class="token keyword">do</span>
            <span class="token keyword">let</span> <span class="token hvariable">newDepth</span> <span class="token operator">=</span> <span class="token hvariable">curDepth</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token hvariable">st</span> <span class="token operator">&lt;-</span> <span class="token hvariable">get</span>
            <span class="token hvariable">when</span> <span class="token punctuation">(</span><span class="token hvariable">stDeepestReached</span> <span class="token hvariable">st</span> <span class="token operator">&lt;</span> <span class="token hvariable">newDepth</span><span class="token punctuation">)</span> <span class="token operator">$</span>
              <span class="token hvariable">put</span> <span class="token hvariable">st</span> <span class="token punctuation">{</span><span class="token hvariable">stDeepestReached</span> <span class="token operator">=</span> <span class="token hvariable">newDepth</span><span class="token punctuation">}</span>
            <span class="token hvariable">constrainedCount</span> <span class="token hvariable">newDepth</span> <span class="token hvariable">newPath</span>
          <span class="token keyword">else</span> <span class="token builtin">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token builtin">return</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token hvariable">path</span><span class="token punctuation">,</span> <span class="token builtin">length</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token builtin">concat</span> <span class="token hvariable">rest</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中如此运用monad变换器确实有些小题大做，因为这仅仅是个简单函数，其并没有因此得到太多的好处。但是这个方法的实用性在于，可以将其 <em>轻易扩展以解决更加复杂的问题</em> 。</p><p>大部分指令式的应用可以使用和这里的 <code>App</code> monad类似的方法，在monad栈中编写。在实际的程序中，或许需要携带更复杂的配置数据，但依旧可以使用 <code>ReaderT</code> 以保持其只读，并只在需要时暴露配置；或许有更多可变状态需要管理，但依旧可以使用 <code>StateT</code> 封装它们。</p><h3 id="隐藏细节" tabindex="-1"><a class="header-anchor" href="#隐藏细节"><span>隐藏细节</span></a></h3><p>使用常规的 <code>newtype</code> 技术，便可将细节与接口分离开：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token keyword">newtype</span> <span class="token constant">MyApp</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">MyA</span>
  <span class="token punctuation">{</span> <span class="token hvariable">runA</span> <span class="token operator">::</span> <span class="token constant">ReaderT</span> <span class="token constant">AppConfig</span> <span class="token punctuation">(</span><span class="token constant">StateT</span> <span class="token constant">AppState</span> <span class="token constant">IO</span><span class="token punctuation">)</span> <span class="token hvariable">a</span>
  <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Monad</span><span class="token punctuation">,</span> <span class="token constant">MonadIO</span><span class="token punctuation">,</span> <span class="token constant">MonadReader</span> <span class="token constant">AppConfig</span><span class="token punctuation">,</span>
              <span class="token constant">MonadState</span> <span class="token constant">AppState</span><span class="token punctuation">)</span>

<span class="token hvariable">runMyApp</span> <span class="token operator">::</span> <span class="token constant">MyApp</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">AppState</span><span class="token punctuation">)</span>
<span class="token hvariable">runMyApp</span> <span class="token hvariable">k</span> <span class="token hvariable">maxDepth</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">config</span> <span class="token operator">=</span> <span class="token constant">AppConfig</span> <span class="token hvariable">maxDepth</span>
        <span class="token hvariable">state</span> <span class="token operator">=</span> <span class="token constant">AppState</span> <span class="token number">0</span>
    <span class="token keyword">in</span> <span class="token hvariable">runStateT</span> <span class="token punctuation">(</span><span class="token hvariable">runReaderT</span> <span class="token punctuation">(</span><span class="token hvariable">runA</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token hvariable">config</span><span class="token punctuation">)</span> <span class="token hvariable">state</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若只导出 <code>MyApp</code> 类构造器和 <code>runMyApp</code> 执行函数，客户端的代码就无法知晓这个monad的内部结构是否是monad栈了。</p><p>此处，庞大的 <code>deriving</code> 子句需要 <code>GeneralizedNewtypeDeriving</code> 语言编译选项。编译器可以为我们生成这些实例，这看似十分神奇，究竟是如何做到的呢？</p><p>早先，我们提到 <code>mtl</code> 库为每个monad变换器都提供了一系列实例。例如 <code>IO</code> monad实现了 <code>MonadIO</code> ，若下层monad是 <code>MonadIO</code> 的实例，那么 <code>mtl</code> 也将为其对应的 <code>StateT</code> 构建一个 <code>MonadIO</code> 的实例，类似的事情也发生在 <code>ReaderT</code> 上。</p><p>因此，这其中并无太多神奇之处：位于monad栈顶层的monad变换器，已是所有我们声明的 <code>deriving</code> 子句中的类型类的实例，我们做的只不过是重新派生这些实例。这是 <code>mtl</code> 精心设计的一系列类型类和实例完美配合的结果。除了基于 <code>newtype</code> 声明的常规的自动推导以外并没有发生什么。</p><p>[译注：注意到此处 <code>newtype MyApp a</code> 只是乔装过的 <code>ReaderT AppConfig (StateT AppState IO) a</code> 。因此我们可以列出 <code>MyApp a</code> 这个monad栈的全貌（自顶向下）：</p><ul><li><code>ReaderT AppConfig</code> （monad变换器）</li><li><code>StateT AppState</code> （monad变换器）</li><li><code>IO</code> （monad）</li></ul><p>注意这个monad栈和 <code>deriving</code> 子句中类型类的相似度。这些实例都可以自动派生： <code>MonadIO</code> 实例自底层派生上来， <code>MonadStateT</code> 从中间一层派生，而 <code>MonadReader</code> 实例来自顶层。所以虽然 <code>newtype MyApp a</code> 引入了一个全新的类型，其实例是可以通过内部结构自动推导的。]</p><h3 id="练习" tabindex="-1"><a class="header-anchor" href="#练习"><span>练习</span></a></h3><ol><li>修改 <code>App</code> 类型别名以交换 <code>ReaderT</code> 和 <code>StateT</code> 的位置，这一变换对执行函数 <code>runApp</code> 会带来什么影响？</li><li>为 <code>App</code> monad栈添加 <code>WriterT</code> 变换器。 相应地修改 <code>runApp</code> 。</li><li>重写 <code>contrainedCount</code> 函数，在为 <code>App</code> 新添加的 <code>WriterT</code> 中记录结果。</li></ol><p>[译注：第一题中的 <code>StateT</code> 原为 <code>WriterT</code> ，鉴于 <code>App</code> 定义中并无 <code>WriterT</code> ，此处应该指的是 <code>StateT</code> ]</p><h2 id="深入monad栈中" tabindex="-1"><a class="header-anchor" href="#深入monad栈中"><span>深入Monad栈中</span></a></h2><p>至今，我们了解了对monad变换器的简单运用。对 <code>mtl</code> 库的便利组合拼接使我们免于了解monad栈构造的细节。我们确实已掌握了足以帮助我们简化大量常见编程任务的monad变换器相关知识。</p><p>但有时，为了实现一些实用的功能，还是我们需要了解 <code>mtl</code> 库并不便利的一面。这些任务可能是将定制的monad置于monad栈底，也可能是将定制的monad变换器置于monad变换器栈中的某处。为了解其中潜在的难度，我们讨论以下例子。</p><p>假设我们有个定制的monad变换器 <code>CustomT</code> ：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/CustomT.hs</span>
<span class="token keyword">newtype</span> <span class="token constant">CustomT</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>mtl</code> 提供的框架中，每个位于栈上的monad变换器都将其下层monad的API暴露出来。这是通过提供大量的类型类实例来实现的。遵从这一模式的规则，我们也可以实现一系列的样板实例：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/CustomT.hs</span>
<span class="token keyword">instance</span> <span class="token constant">MonadReader</span> <span class="token hvariable">r</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token constant">MonadReader</span> <span class="token hvariable">r</span> <span class="token punctuation">(</span><span class="token constant">CustomT</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token operator">...</span>

<span class="token keyword">instance</span> <span class="token constant">MonadIO</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token constant">MonadIO</span> <span class="token punctuation">(</span><span class="token constant">CustomT</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若下层monad是 <code>MonadReader</code> 的实例，则 <code>CustomT</code> 也可作为 <code>MonadReader</code> 的实例：实例化的方法是将所有相关的API调用转接给其下层实例的相应函数。经过实例化之后，上层的代码就可以将monad栈作为一个整体，当作 <code>MonadReader</code> 的实例，而不再需要了解或关心到底是其中的哪一层提供了具体的实现。</p><p>不同于这种依赖类型类实例的方法，我们也可以显式指定想要使用的API。<code>MonadTrans</code> 类型类定义了一个实用的函数 <code>lift</code> ：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :m +Control.Monad.Trans
ghci<span class="token operator">&gt;</span> :info MonadTrans
class MonadTrans t where lift :: <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> m a -<span class="token operator">&gt;</span> t m a
      -- Defined <span class="token keyword">in</span> Control.Monad.Trans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数接受来自monad栈中，当前栈下一层的monad动作，并将这个动作变成，或者说是 <em>抬举</em> 到现在的monad变换器中。每个monad变换器都是 <code>MonadTrans</code> 的实例。</p><p><code>lift</code> 这个名字是基于此函数与 <code>fmap</code> 和 <code>liftM</code> 目的上的相似度的。这些函数都可以从类型系统的下一层中把东西提升到我们目前工作的这一层。它们的区别是：</p><p>fmap : 将纯函数提升到 functor 层次</p><p>liftM : 将纯函数提升到 monad 层次</p><p>lift : 将一 monad 动作，从 monad 栈中的下一层提升到本层</p><p>[译注：实际上 <code>liftM</code> 间接调用了 <code>fmap</code> ，两个函数在效果上是完全一样的。译者认为，当操作对象是monad（所有的monad都是functor）的时候，使用其中的哪一个只是思考方法上的不同。]</p><p>现在重新考虑我们在早些时候定义的 <code>App</code> monad栈 (之前我们将其包装在 <code>newtype</code> 中)：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/UglyStack.hs</span>
<span class="token keyword">type</span> <span class="token constant">App</span> <span class="token operator">=</span> <span class="token constant">ReaderT</span> <span class="token constant">AppConfig</span> <span class="token punctuation">(</span><span class="token constant">StateT</span> <span class="token constant">AppState</span> <span class="token constant">IO</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>若想访问 <code>StateT</code> 所携带的 <code>AppState</code> ，通常需要依赖 <code>mtl</code> 的类型类实例来为我们处理组合工作：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/UglyStack.hs</span>
<span class="token hvariable">implicitGet</span> <span class="token operator">::</span> <span class="token constant">App</span> <span class="token constant">AppState</span>
<span class="token hvariable">implicitGet</span> <span class="token operator">=</span> <span class="token hvariable">get</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过将 <code>get</code> 函数从 <code>StateT</code> 中抬举进 <code>ReaderT</code> ， <code>lift</code> 函数也可以实现同样的效果：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/UglyStack.hs</span>
<span class="token hvariable">explicitGet</span> <span class="token operator">::</span> <span class="token constant">App</span> <span class="token constant">AppState</span>
<span class="token hvariable">explicitGet</span> <span class="token operator">=</span> <span class="token hvariable">lift</span> <span class="token hvariable">get</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显然当 <code>mtl</code> 可以为我们完成这一工作时，代码会变得更清晰。但是 <code>mtl</code> 并不总能完成这类工作。</p><h3 id="何时需要显式的抬举" tabindex="-1"><a class="header-anchor" href="#何时需要显式的抬举"><span>何时需要显式的抬举？</span></a></h3><p>我们必须使用 <code>lift</code> 的一个例子是：当在一个monad栈中，同一个类型类的实例出现了多次时：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/StackStack.hs</span>
<span class="token keyword">type</span> <span class="token constant">Foo</span> <span class="token operator">=</span> <span class="token constant">StateT</span> <span class="token constant">Int</span> <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token constant">String</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>若此时我们试着使用 <code>MonadState</code> 类型类中的 <code>put</code> 动作，得到的实例将是 <code>StateT Int</code> ，因为这个实例在monad栈顶。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/StackStack.hs</span>
<span class="token hvariable">outerPut</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">outerPut</span> <span class="token operator">=</span> <span class="token hvariable">put</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个情况下，唯一能访问下层 <code>State</code> monad的 <code>put</code> 函数的方法是使用 <code>lift</code> ：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/StackStack.hs</span>
<span class="token hvariable">innerPut</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">innerPut</span> <span class="token operator">=</span> <span class="token hvariable">lift</span> <span class="token operator">.</span> <span class="token hvariable">put</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有时我们需要访问多于一层以下的monad，这时我们必须组合 <code>lift</code> 调用。每个函数组合中的 <code>lift</code> 将我们带到更深的一层。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/StackStack.hs</span>
<span class="token keyword">type</span> <span class="token constant">Bar</span> <span class="token operator">=</span> <span class="token constant">ReaderT</span> <span class="token constant">Bool</span> <span class="token constant">Foo</span>

<span class="token hvariable">barPut</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bar</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">barPut</span> <span class="token operator">=</span> <span class="token hvariable">lift</span> <span class="token operator">.</span> <span class="token hvariable">lift</span> <span class="token operator">.</span> <span class="token hvariable">put</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如以上代码所示，当需要用 <code>lift</code> 的时候，一个好习惯是定义并使用包裹函数来为我们完成抬举工作。因为这种在代码各处显式使用lift的方法使代码变得混乱。另一个显式lift的缺点在于，其硬编码了monad栈的层次细节，这将使日后对monad栈的修改变得复杂。</p><h2 id="构建以理解monad变换器" tabindex="-1"><a class="header-anchor" href="#构建以理解monad变换器"><span>构建以理解Monad变换器</span></a></h2><p>为了深入理解monad变换器通常是如何运作的，在本节我们将自己构建一个monad变换器，期间一并讨论其中的组织结构。我们的目标简单而实用： <code>MaybeT</code> 。但是 <code>mtl</code> 库意外地并没有提供它。</p><p>[译注：如果想使用现成的 <code>MaybeT</code> ，现在你可以在 Hackage 上的 <code>transformers</code> 库中找到它。]</p><p>这个monad变换器修改monad的方法是：将下层monad <code>m a</code> 的类型参数 包装在 <code>Maybe</code> 中，以得到类型 <code>m (Maybe a)</code> 。正如 <code>Maybe</code> monad一样，若在 <code>MaybeT</code> monad变换器中调用 <code>fail</code> ，则计算将提早结束执行。</p><p>为使 <code>m (Maybe a)</code> 成为 <code>Monad</code> 的实例，其必须有个独特的类型。这里我们通过 <code>newtype</code> 声明来实现：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MaybeT.hs</span>
<span class="token keyword">newtype</span> <span class="token constant">MaybeT</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">MaybeT</span>
  <span class="token punctuation">{</span> <span class="token hvariable">runMaybeT</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在需要定义三个标准的monad函数。其中最复杂的是 <code>(&gt;&gt;=)</code> ，它的实现也阐明了我们实际上在做什么。在开始研究其操作之前，不妨先看看其类型：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MaybeT.hs</span>
<span class="token hvariable">bindMT</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">MaybeT</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">MaybeT</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">MaybeT</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为理解其类型签名，回顾之前在十五章中对&quot;多参数类型类&quot;讨论。此处我们想使 <em>部分类型</em> <code>MaybeT m</code> 成为 <code>Monad</code> 的实例。这个部分类型拥有通常的单一类型参数 <code>a</code> ，这样便能满足 <code>Monad</code> 类型类的要求。</p><p>[译注： <code>MaybeT</code> 的完整定义是 <code>MaybeT m a</code> ，因此 <code>MaybeT m</code> 只是部分应用。]</p><p>理解以下 <code>(&gt;&gt;=)</code> 实现的关键在于： <code>do</code> 代码块里的代码是在 <em>下层</em> monad中执行的，无论这个下层monad是什么。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MaybeT.hs</span>
<span class="token hvariable">x</span> <span class="token operator">\`bindMT\`</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">MaybeT</span> <span class="token operator">$</span> <span class="token keyword">do</span>
    <span class="token hvariable">unwrapped</span> <span class="token operator">&lt;-</span> <span class="token hvariable">runMaybeT</span> <span class="token hvariable">x</span>
    <span class="token keyword">case</span> <span class="token hvariable">unwrapped</span> <span class="token keyword">of</span>
      <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token constant">Nothing</span>
      <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">runMaybeT</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的 <code>runMaybeT</code> 函数解开了在 <code>x</code> 中包含的结果。进而，注意到 <code>&lt;-</code> 符号是 <code>(&gt;&gt;=)</code> 的语法糖：monad 变换器必须使用其下层monad的 <code>(&gt;&gt;=)</code> 。而最后一部分对 <code>unwrapped</code> 的结构分析（ <code>case</code> 表达式），决定了我们是要短路当前计算，还是将计算继续下去。最后，观察表达式的最外层。为了将下层monad再次藏起来，这里必须用 <code>MaybeT</code> 构造器包装结果。</p><p>刚才展示的 <code>do</code> 标记看起来更容易阅读，但是其将我们依赖下层monad的 <code>(&gt;&gt;=)</code> 函数的事实也藏了起来。下面提供一个更符合语言习惯的 <code>MaybeT</code> 的 <code>(&gt;&gt;=)</code> 实现：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MaybeT.hs</span>
<span class="token hvariable">x</span> <span class="token operator">\`altBindMT\`</span> <span class="token hvariable">f</span> <span class="token operator">=</span>
    <span class="token constant">MaybeT</span> <span class="token operator">$</span> <span class="token hvariable">runMaybeT</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token builtin">maybe</span> <span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token constant">Nothing</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">runMaybeT</span> <span class="token operator">.</span> <span class="token hvariable">f</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们了解了 <code>(&gt;&gt;=)</code> 在干些什么。关于 <code>return</code> 和 <code>fail</code> 无需太多解释， <code>Monad</code> 实例也不言自明：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MaybeT.hs</span>
<span class="token hvariable">returnMT</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">MaybeT</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
<span class="token hvariable">returnMT</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">MaybeT</span> <span class="token operator">$</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>

<span class="token hvariable">failMT</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">MaybeT</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
<span class="token hvariable">failMT</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">MaybeT</span> <span class="token operator">$</span> <span class="token builtin">return</span> <span class="token constant">Nothing</span>

<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token constant">MaybeT</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
  <span class="token builtin">return</span> <span class="token operator">=</span> <span class="token hvariable">returnMT</span>
  <span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">bindMT</span>
  <span class="token builtin">fail</span> <span class="token operator">=</span> <span class="token hvariable">failM</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="建立monad变换器" tabindex="-1"><a class="header-anchor" href="#建立monad变换器"><span>建立Monad变换器</span></a></h3><p>为将我们的类型变成monad变换器，必须提供 <code>MonadTrans</code> 的实例，以使用户可以访问下层monad：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MaybeT.hs</span>
<span class="token keyword">instance</span> <span class="token constant">MonadTrans</span> <span class="token constant">MaybeT</span> <span class="token keyword">where</span>
    <span class="token hvariable">lift</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token constant">MaybeT</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token operator">\`liftM\`</span> <span class="token hvariable">m</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下层monad以类型 <code>a</code> 开始：我们&quot;注入&quot; <code>Just</code> 构造器以使其变成需要的类型： <code>Maybe a</code> 。进而我们通过 <code>MaybeT</code> 藏起下层monad。</p><h3 id="更多的类型类实例" tabindex="-1"><a class="header-anchor" href="#更多的类型类实例"><span>更多的类型类实例</span></a></h3><p>在定义好 <code>MonadTrans</code> 的实例后，便可用其来定义其他大量的 <code>mtl</code> 类型类实例了：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MaybeT.hs</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">MonadIO</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">MonadIO</span> <span class="token punctuation">(</span><span class="token constant">MaybeT</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
  <span class="token hvariable">liftIO</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">lift</span> <span class="token punctuation">(</span><span class="token hvariable">liftIO</span> <span class="token hvariable">m</span><span class="token punctuation">)</span>

<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">MonadState</span> <span class="token hvariable">s</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">MonadState</span> <span class="token hvariable">s</span> <span class="token punctuation">(</span><span class="token constant">MaybeT</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
  <span class="token hvariable">get</span> <span class="token operator">=</span> <span class="token hvariable">lift</span> <span class="token hvariable">get</span>
  <span class="token hvariable">put</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token hvariable">lift</span> <span class="token punctuation">(</span><span class="token hvariable">put</span> <span class="token hvariable">k</span><span class="token punctuation">)</span>

<span class="token comment">-- ... 对 MonadReader，MonadWriter等的实例定义同理 ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于一些 <code>mtl</code> 类型类使用了函数式依赖，有些实例的声明需要GHC大大放宽其原有的类型检查规则。(若我们忘记了其中任意的 <code>LANGUAGE</code> 指令，编译器会在其错误信息中提供建议。)</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MaybeT.hs</span>
<span class="token comment">{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses,
             UndecidableInstances #-}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是花些时间来写这些样板实例呢，还是显式地使用 <code>lift</code> 呢？这取决于这个monad变换器的用途。如果我们只在几种有限的情况下使用它，那么只提供 <code>MonadTrans</code> 实例就够了。在这种情况下，也无妨提供一些依然有意义的实例，比如 <code>MonadIO</code>。另一方面，若我们需要在大量的情况下使用这一monad变换器，那么花些时间来完成这些实例或许也不错。</p><h3 id="以monad栈替代parse类型" tabindex="-1"><a class="header-anchor" href="#以monad栈替代parse类型"><span>以Monad栈替代Parse类型</span></a></h3><p>现在我们已开发了一个支持提早退出的monad变换器，可以用其来辅助开发了。例如，此处若想处理解析一半失败的情况，便可以用这一以我们的需求定制的monad变换器来替代我们在第十章&quot;隐式状态&quot;一节开发的 <code>Parse</code> 类型。</p><h3 id="练习-1" tabindex="-1"><a class="header-anchor" href="#练习-1"><span>练习</span></a></h3><ol><li>我们的Parse monad还不是之前版本的完美替代。因为其用的是 <code>Maybe</code> 而不是 <code>Either</code> 来代表结果。因此在失败时暂时无法提供任何有用的信息。</li></ol><blockquote><p>构建一个 <code>EitherT s</code> （其中 <code>s</code> 是某个类型）来表示结果，并用其实现更适合的 <code>Parse</code> monad以在解析失败时汇报具体错误信息。</p></blockquote><p>或许在你探索Haskell库的途中，在 <code>Control.Monad.Error</code> 遇到过一个 <code>Either</code> 类型的 <code>Monad</code> 实例。我们建议不要参照它来完成你的实现，因为它的设计太局限了：虽然其将 <code>Either String</code> 变成一个monad， 但实际上把 <code>Either</code> 的第一个类型参数限定为 <code>String</code> 并非必要。</p><p>提示: 若你按照这条建议来做，你的定义中或许需要使用 <code>FlexibleInstances</code> 语言扩展。</p><h2 id="注意变换器堆叠顺序" tabindex="-1"><a class="header-anchor" href="#注意变换器堆叠顺序"><span>注意变换器堆叠顺序</span></a></h2><p>从早先使用 <code>ReaderT</code> 和 <code>StateT</code> 的例子中，你或许会认为叠加monad变换器的顺序并不重要。事实并非如此，考虑在 <code>State</code> 上叠加 <code>StateT</code> 的情况，或许会助于你更清晰地意识到：堆叠的顺序确实产生了结果上的区别：类型 <code>StateT Int (State String)</code> 和类型 <code>StateT String (State Int)</code> 或许携带的信息相同，但它们却无法互换使用。叠加的顺序决定了我们是否要用 <code>lift</code> 来取得状态中的某个部分。</p><p>下面的例子更加显著地阐明了顺序的重要性。假设有个可能失败的计算，而我们想记录下在什么情况下其会失败：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MTComposition.hs</span>
<span class="token comment">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>
<span class="token import-statement"><span class="token keyword">import</span> MaybeT</span>

<span class="token hvariable">problem</span> <span class="token operator">::</span> <span class="token constant">MonadWriter</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">problem</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">&quot;this is where i fail&quot;</span><span class="token punctuation">]</span>
  <span class="token builtin">fail</span> <span class="token string">&quot;oops&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么这两个monad栈中的哪一个会带给我们需要的信息呢？</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token keyword">type</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token constant">WriterT</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Maybe</span>

<span class="token keyword">type</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token constant">MaybeT</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token hvariable">a</span> <span class="token operator">::</span> <span class="token constant">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">problem</span>

<span class="token hvariable">b</span> <span class="token operator">::</span> <span class="token constant">B</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">problem</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在 <code>ghci</code> 中试试看：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> runWriterT a
Loading package mtl-1.1.0.1 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
Nothing
ghci<span class="token operator">&gt;</span> runWriter $ runMaybeT b
<span class="token punctuation">(</span>Nothing,<span class="token punctuation">[</span><span class="token string">&quot;this is where i fail&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看执行函数的类型签名，其实结果并不意外：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t runWriterT
runWriterT :: WriterT w m a -<span class="token operator">&gt;</span> m <span class="token punctuation">(</span>a, w<span class="token punctuation">)</span>
ghci<span class="token operator">&gt;</span> :t runWriter <span class="token builtin class-name">.</span> runMaybeT
runWriter <span class="token builtin class-name">.</span> runMaybeT :: MaybeT <span class="token punctuation">(</span>Writer w<span class="token punctuation">)</span> a -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>Maybe a, w<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>Maybe</code> 上叠加 <code>WriterT</code> 的策略使 <code>Maybe</code> 成为下层monad，因此 <code>runWriterT</code> 必须给我们以 <code>Maybe</code> 为类型的结果。在测试样例中，我们只会在不出现任何失败的情况下才能获得日志！</p><p>叠加monad变换器类似于组合函数：如果我们改变函数应用的顺序，那么我们并不会对得到不同的结果感到意外。同样的道理也适用于对monad变换器的叠加。</p><h2 id="纵观monad与monad变换器" tabindex="-1"><a class="header-anchor" href="#纵观monad与monad变换器"><span>纵观Monad与Monad变换器</span></a></h2><p>本节，让我们暂别细节，讨论一下用monad和monad变换器编程的优缺点。</p><h3 id="对纯代码的干涉" tabindex="-1"><a class="header-anchor" href="#对纯代码的干涉"><span>对纯代码的干涉</span></a></h3><p>在实际编程中，使用monad的最恼人之处或许在于其阻碍了我们使用纯代码。很多实用的纯函数需要一个monad版的类似函数，而其monad版只是加上一个占位参数 <code>m</code> 供monad类型构造器填充：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t filter
filter :: <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> Bool<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> :i filterM
filterM :: <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m Bool<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> m <span class="token punctuation">[</span>a<span class="token punctuation">]</span>
      -- Defined <span class="token keyword">in</span> Control.Monad
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，这种覆盖是有限的：标准库中并不总能提供纯函数的monad版本。</p><p>其中有一部分历史原因：Eugenio Moggi于1988年引入了使用monad编程的思想。而当时Haskell 1.0标准尚在开发中。现今版本的 <code>Prelude</code> 中的大部分函数可以追溯到于1990发布的Haskell 1.0。在1991年，Philip Wadler开始为更多的函数式编程听众作文，阐述monad的潜力。从那时起，monad开始用于实践。</p><p>直到1996年Haskell 1.3标准发布之时，monad才得到了支持。但是在那时，语言的设计者已经受制于维护向前兼容性：它们无法改变 <code>Prelude</code> 中的函数签名，因为那会破坏现有的代码。</p><p>从那以后，Haskell社区学会了很多合适的抽象。因此我们可以写出不受这一纯函数／monad函数分裂影响的代码。你可以在 <code>Data.Traversable</code> 和 <code>Data.Foldable</code> 中找到这些思想的精华。</p><p>尽管它们极具吸引力，由于版面的限制。我们不会在本书中涵盖相关内容。但如果你能轻易理解本章内容，自行理解它们也不会有问题。</p><p>在理想世界里，我们是否会与过去断绝，并让 <code>Prelude</code> 包含 <code>Traversable</code> 和 <code>Foldable</code> 类型呢？或许不会，因为学习Haskell本身对新手来说已经是个相当刺激的历程了。在我们已经了解functor和monad之后，<code>Foldable</code> 和 <code>Traversable</code> 的抽象是十分容易理解的。但是对学习者来说这意味着摆在他们面前的是更多纯粹的抽象。若以教授语言为目的， <code>map</code> 操作的最好是列表，而不是functor。</p><p>[译注：实际上，自GHC 7.10开始， <code>Foldable</code> 和 <code>Traversable</code> 已经进入了 <code>Prelude</code> 。 一些函数的类型签名会变得更加抽象（以GHC 7.10.1为例）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci-7.10.<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> :t mapM
mapM :: <span class="token punctuation">(</span>Monad m, Traversable t<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> t a -<span class="token operator">&gt;</span> m <span class="token punctuation">(</span>t b<span class="token punctuation">)</span>
ghci-7.10.<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> :t foldl
foldl :: Foldable t <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>b -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> b -<span class="token operator">&gt;</span> t a -<span class="token operator">&gt;</span> b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这并不是一个对初学者友好的改动，但由于新的函数只是旧有函数的推广形式，使用旧的函数签名依旧可以通过类型检查：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci-7.10.<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> :t <span class="token punctuation">(</span>mapM :: Monad m <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> m <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>mapM :: Monad m <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> m <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span>
  :: Monad m <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> m b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> m <span class="token punctuation">[</span>b<span class="token punctuation">]</span>
ghci-7.10.<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> :t <span class="token punctuation">(</span>foldl :: <span class="token punctuation">(</span>b -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> b -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">(</span>foldl :: <span class="token punctuation">(</span>b -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> b -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span>
  :: <span class="token punctuation">(</span>b -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> b -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若在学习过程中遇到障碍，不妨暂且以旧的类型签名来理解它们。]</p><h3 id="对次序的过度限定" tabindex="-1"><a class="header-anchor" href="#对次序的过度限定"><span>对次序的过度限定</span></a></h3><p>我们使用monad的一个基本原因是：其允许我们指定效果发生的次序。再看看我们早先写的一小段代码：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch18/MTComposition.hs</span>
<span class="token comment">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>
<span class="token import-statement"><span class="token keyword">import</span> MaybeT</span>

<span class="token hvariable">problem</span> <span class="token operator">::</span> <span class="token constant">MonadWriter</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">problem</span> <span class="token operator">=</span> <span class="token keyword">do</span>
  <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">&quot;this is where i fail&quot;</span><span class="token punctuation">]</span>
  <span class="token builtin">fail</span> <span class="token string">&quot;oops&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我们在monad中执行， <code>tell</code> 的效果可以保证发生在 <code>fail</code> 之前。这里的问题在于，这个次序并不必要，但是我们却得到了这样的次序保证。编译器无法任意安排monad式代码的次序，即便这么做能使代码效率更高。</p><p>[译注：解释一下这里的&quot;次序并不必要&quot;。回顾之前对叠加次序问题的讨论：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token keyword">type</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token constant">WriterT</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Maybe</span>

<span class="token keyword">type</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token constant">MaybeT</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token hvariable">a</span> <span class="token operator">::</span> <span class="token constant">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">problem</span>
<span class="token comment">-- runWriterT a == Nothing</span>

<span class="token hvariable">b</span> <span class="token operator">::</span> <span class="token constant">B</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">problem</span>
<span class="token comment">-- runWriter (runMaybeT b) == (Nothing, [&quot;this is where i fail&quot;])</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面把注意力集中于 <code>a</code> ： 注意到 <code>runWriterT a == Nothing</code> ， <code>tell</code> 的结果并不需要，因为接下来的 <code>fail</code> 取消了计算，将之前的结果抛弃了。利用这个事实，可以得知让 <code>fail</code> 先执行效率更高。同时注意对 <code>fail</code> 和 <code>tell</code> 的实际处理来自monad栈的不同层，所以在一定限制下调换某些操作的顺序会不影响结果。但是由于这个monad栈本身也要是个monad，使这种本来可以进行的交换变得不可能了。]</p><h3 id="运行时开销" tabindex="-1"><a class="header-anchor" href="#运行时开销"><span>运行时开销</span></a></h3><p>最后，当我们使用monad和monad变换器时，需要付出一些效率的代价。 例如 <code>State</code> monad携带状态并将其放在一个闭包中。在Haskell的实现中，闭包的开销或许廉价但绝非免费。</p><p>Monad变换器把其自身的开销附加在了其下层monad之上。每次我们使用 <code>(&gt;&gt;=)</code> 时，MaybeT变换器便需要包装和解包。而由 <code>ReaderT</code> ， <code>StateT</code> 和 <code>MaybeT</code> 依次叠加组成的monad栈，在每次使用 <code>(&gt;&gt;=)</code> 时，更是有一系列的簿记工作需要完成。</p><p>一个足够聪明的编译器或许可以将这些开销部分，甚至于全部消除。但是那种深度的复杂工作尚未广泛适用。</p><p>但是依旧有些相对简单技术可以避免其中的一些开销，版面的限制只允许我们在此做简单描述。例如，在continuation monad中，对 <code>(&gt;&gt;=)</code> 频繁的包装和解包可以避免，仅留下执行效果的开销。所幸的是使用这种方法所要考虑的大部分复杂问题，已经在函数库中得到了处理。</p><p>这一部分的工作在本书写作时尚在积极的开发中。如果你想让你对monad变换器的使用更加高效，我们推荐在Hackage中寻找相关的库或是在邮件列表或IRC上寻求指引。</p><h3 id="缺乏灵活性的接口" tabindex="-1"><a class="header-anchor" href="#缺乏灵活性的接口"><span>缺乏灵活性的接口</span></a></h3><p>若我们只把 <code>mtl</code> 当作黑盒，那么所有的组件将很好地合作。但是若我们开始开发自己的monad和monad变换器，并想让它们于 <code>mtl</code> 提供的组件配合，这种缺陷便显现出来了。</p><p>例如，我们开发一个新的monad变换器 <code>FooT</code> ，并想沿用 <code>mtl</code> 中的模式。我们就必须实现一个类型类 <code>MonadFoo</code> 。若我们想让其更好地和 <code>mtl</code> 配合，那么便需要提供大量的实例来支持 <code>mtl</code> 中的类型类。</p><p>除此之外，还需要为每个 <code>mtl</code> 中的变换器提供 <code>MonadFoo</code> 的实例。大部分的实例实现几乎是完全一样的，写起来也十分乏味。若我们想在 <code>mtl</code> 中集成更多的monad变换器，那么我们需要处理的各类活动部件将达到引入的monad变换器数量的 <em>平方级别</em> ！</p><p>公平地看来，这个问题会只影响到少数人。大部分 <code>mtl</code> 的用户并不需要开发新的monad。</p><p>造成这一 <code>mtl</code> 设计缺陷的原因在于，它是第一个monad变换器的函数库。想像其设计者投入这个未知的领域，完成了大量的工作以使这个强大的函数库对于大部分用户来说做到简便易用。</p><p>一个新的关于monad和变换器的函数库 <code>monadLib</code> ，修正了 <code>mtl</code> 中大量的设计缺陷。若在未来你成为了一个monad变换器的中坚骇客，这值得你一试。</p><p>平方级别的实例定义实际上是使用monad变换器带来的问题。除此之外另有其他的手段来组合利用monad。虽然那些手段可以避免这类问题，但是它们对最终用户而言仍不及monad变换器便利。幸运的是，并没有太多基础而泛用的monad变换器需要去定义实现。</p><h3 id="综述" tabindex="-1"><a class="header-anchor" href="#综述"><span>综述</span></a></h3><p>Monad在任何意义下都不是处理效果和类型的终极途径。它只是在我们探索至今，处理这类问题最为实用的技术。语言的研究者们一直致力于找到可以扬长避短的替代系统。</p><p>尽管在使用它们时我们必须做出妥协，monad和monad变换器依旧提供了一定程度上的灵活度和控制，而这在指令式语言中并无先例。仅仅几个声明，我们就可以给分号般基础的东西赋予崭新的意义。</p><p>[译注：此处的分号应该指的是 <code>do</code> 标记中使用的分号。]</p>`,196),p=[t];function c(l,d){return n(),s("div",null,p)}const k=a(o,[["render",c],["__file","18.html.vue"]]),u=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/18.html","title":"第 18 章： Monad变换器","lang":"zh-CN","frontmatter":{"description":"第 18 章： Monad变换器 动机： 避免样板代码 Monad提供了一种强大途径以构建带效果的计算。虽然各个标准monad皆专一于其特定的任务，但在实际代码中，我们常常想同时使用多种效果。 比如，回忆在第十章中开发的 Parse 类型。在介绍monad之时，我们提到这个类型其实是乔装过的 State monad。事实上我们的monad比标准的 St...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/18.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"第 18 章： Monad变换器"}],["meta",{"property":"og:description","content":"第 18 章： Monad变换器 动机： 避免样板代码 Monad提供了一种强大途径以构建带效果的计算。虽然各个标准monad皆专一于其特定的任务，但在实际代码中，我们常常想同时使用多种效果。 比如，回忆在第十章中开发的 Parse 类型。在介绍monad之时，我们提到这个类型其实是乔装过的 State monad。事实上我们的monad比标准的 St..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-25T04:39:03.000Z"}],["meta",{"property":"article:author","content":"hahg"}],["meta",{"property":"article:modified_time","content":"2024-02-25T04:39:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第 18 章： Monad变换器\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-25T04:39:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hahg\\"}]}"]]},"headers":[{"level":2,"title":"动机： 避免样板代码","slug":"动机-避免样板代码","link":"#动机-避免样板代码","children":[]},{"level":2,"title":"简单的Monad变换器实例","slug":"简单的monad变换器实例","link":"#简单的monad变换器实例","children":[]},{"level":2,"title":"Monad和Monad变换器中的模式","slug":"monad和monad变换器中的模式","link":"#monad和monad变换器中的模式","children":[]},{"level":2,"title":"叠加多个Monad变换器","slug":"叠加多个monad变换器","link":"#叠加多个monad变换器","children":[{"level":3,"title":"缺失的类型参数呢？","slug":"缺失的类型参数呢","link":"#缺失的类型参数呢","children":[]},{"level":3,"title":"隐藏细节","slug":"隐藏细节","link":"#隐藏细节","children":[]},{"level":3,"title":"练习","slug":"练习","link":"#练习","children":[]}]},{"level":2,"title":"深入Monad栈中","slug":"深入monad栈中","link":"#深入monad栈中","children":[{"level":3,"title":"何时需要显式的抬举？","slug":"何时需要显式的抬举","link":"#何时需要显式的抬举","children":[]}]},{"level":2,"title":"构建以理解Monad变换器","slug":"构建以理解monad变换器","link":"#构建以理解monad变换器","children":[{"level":3,"title":"建立Monad变换器","slug":"建立monad变换器","link":"#建立monad变换器","children":[]},{"level":3,"title":"更多的类型类实例","slug":"更多的类型类实例","link":"#更多的类型类实例","children":[]},{"level":3,"title":"以Monad栈替代Parse类型","slug":"以monad栈替代parse类型","link":"#以monad栈替代parse类型","children":[]},{"level":3,"title":"练习","slug":"练习-1","link":"#练习-1","children":[]}]},{"level":2,"title":"注意变换器堆叠顺序","slug":"注意变换器堆叠顺序","link":"#注意变换器堆叠顺序","children":[]},{"level":2,"title":"纵观Monad与Monad变换器","slug":"纵观monad与monad变换器","link":"#纵观monad与monad变换器","children":[{"level":3,"title":"对纯代码的干涉","slug":"对纯代码的干涉","link":"#对纯代码的干涉","children":[]},{"level":3,"title":"对次序的过度限定","slug":"对次序的过度限定","link":"#对次序的过度限定","children":[]},{"level":3,"title":"运行时开销","slug":"运行时开销","link":"#运行时开销","children":[]},{"level":3,"title":"缺乏灵活性的接口","slug":"缺乏灵活性的接口","link":"#缺乏灵活性的接口","children":[]},{"level":3,"title":"综述","slug":"综述","link":"#综述","children":[]}]}],"git":{"createdTime":1708835943000,"updatedTime":1708835943000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":28.87,"words":8662},"filePathRelative":"学习/Haskell中文文档/18.md","localizedDate":"2024年2月25日","excerpt":"\\n<h2>动机： 避免样板代码</h2>\\n<p>Monad提供了一种强大途径以构建带效果的计算。虽然各个标准monad皆专一于其特定的任务，但在实际代码中，我们常常想同时使用多种效果。</p>\\n<p>比如，回忆在第十章中开发的 <code>Parse</code> 类型。在介绍monad之时，我们提到这个类型其实是乔装过的 <code>State</code> monad。事实上我们的monad比标准的 <code>State</code> monad 更加复杂：它同时也使用了\\n<code>Either</code>\\n类型来表达解析过程中可能的失败。在这个例子中，我们想在解析失败的时候就立刻停止这个过程，而不是以错误的状态继续执行解析。这个monad同时包含了带状态计算的效果和提早退出计算的效果。</p>","autoDesc":true}');export{k as comp,u as data};
