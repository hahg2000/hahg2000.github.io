const e=JSON.parse('{"key":"v-7c2c2150","path":"/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/6.html","title":"第 6 章：使用类型类","lang":"zh-CN","frontmatter":{"description":"第 6 章：使用类型类 类型类（typeclass）跻身于 Haskell 最强大功能之列：它们（typeclasses）允许你定义通用接口，而其（这些接口）为各种不同的类型（type）提供一组公共特性集。类型类是某些基本语言特性的核心，比如相等性测试（equalitytesting）和数值操作符（numeric operators）。在讨论到底类型类是什么之前，我想解释下他们的作用（the need for them）。 类型类的作用 假设因为某个原因， Haskell 语言的设计者拒绝实现相等性测试 == ，因此我们决定实现自己的 == 操作。 你的应用由一个简单的 Color 类型组成。 首先你尝试一下，像这样：","head":[["meta",{"property":"og:url","content":"https://hahg2000.github.io/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/6.html"}],["meta",{"property":"og:title","content":"第 6 章：使用类型类"}],["meta",{"property":"og:description","content":"第 6 章：使用类型类 类型类（typeclass）跻身于 Haskell 最强大功能之列：它们（typeclasses）允许你定义通用接口，而其（这些接口）为各种不同的类型（type）提供一组公共特性集。类型类是某些基本语言特性的核心，比如相等性测试（equalitytesting）和数值操作符（numeric operators）。在讨论到底类型类是什么之前，我想解释下他们的作用（the need for them）。 类型类的作用 假设因为某个原因， Haskell 语言的设计者拒绝实现相等性测试 == ，因此我们决定实现自己的 == 操作。 你的应用由一个简单的 Color 类型组成。 首先你尝试一下，像这样："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-03T04:25:33.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-03T04:25:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第 6 章：使用类型类\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-03T04:25:33.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"类型类的作用","slug":"the-need-for-typeclasses","link":"#the-need-for-typeclasses","children":[]},{"level":2,"title":"什么是类型类？","slug":"what-are-typeclasses","link":"#what-are-typeclasses","children":[]},{"level":2,"title":"定义类型类实例","slug":"declaring-typeclass-instances","link":"#declaring-typeclass-instances","children":[]},{"level":2,"title":"重要的内置类型类","slug":"important-built-in-typeclasses","link":"#important-built-in-typeclasses","children":[{"level":3,"title":"Show","slug":"show","link":"#show","children":[]},{"level":3,"title":"Read","slug":"read","link":"#read","children":[]},{"level":3,"title":"使用 Read 和 Show 进行序列化","slug":"使用-read-和-show-进行序列化","link":"#使用-read-和-show-进行序列化","children":[]},{"level":3,"title":"数值类型","slug":"numeric-types","link":"#numeric-types","children":[]},{"level":3,"title":"相等性，有序和对比","slug":"相等性-有序和对比","link":"#相等性-有序和对比","children":[]}]},{"level":2,"title":"自动派生","slug":"自动派生","link":"#自动派生","children":[]},{"level":2,"title":"类型类实战：让 JSON 更好用","slug":"类型类实战-让-json-更好用","link":"#类型类实战-让-json-更好用","children":[{"level":3,"title":"让错误信息更有用","slug":"more-helpful-errors","link":"#more-helpful-errors","children":[]},{"level":3,"title":"使用类型别名创建实例","slug":"making-an-instance-with-a-type-synonym","link":"#making-an-instance-with-a-type-synonym","children":[]}]},{"level":2,"title":"生活在开放世界","slug":"living-in-an-open-world","link":"#living-in-an-open-world","children":[{"level":3,"title":"什么时候重叠实例（Overlapping instances）会出问题？","slug":"when-do-overlapping-instances-cause-problems","link":"#when-do-overlapping-instances-cause-problems","children":[]},{"level":3,"title":"放松(relex)类型类的一些限制","slug":"relaxing-some-restrictions-on-typeclasses","link":"#relaxing-some-restrictions-on-typeclasses","children":[]},{"level":3,"title":"show是如何处理String的?","slug":"how-does-show-work-for-strings","link":"#how-does-show-work-for-strings","children":[]}]},{"level":2,"title":"如何给类型以新身份（new identity）","slug":"how-to-give-a-type-a-new-identity","link":"#how-to-give-a-type-a-new-identity","children":[{"level":3,"title":"data 和 newtype 声明之间的区别","slug":"data-and-newtype","link":"#data-and-newtype","children":[]},{"level":3,"title":"总结：三种命名类型的方式","slug":"summary-the-three-ways-of-naming-types","link":"#summary-the-three-ways-of-naming-types","children":[]}]},{"level":2,"title":"JSON类型类,不带有重叠实例","slug":"json_typeclasses_without_overlapping_instances","link":"#json_typeclasses_without_overlapping_instances","children":[{"level":3,"title":"练习题","slug":"练习题","link":"#练习题","children":[]}]},{"level":2,"title":"可怕的单一同态限定（monomorphism restriction）","slug":"the_dreaded_monomorphism_restriction","link":"#the_dreaded_monomorphism_restriction","children":[]},{"level":2,"title":"结论","slug":"conclusion","link":"#conclusion","children":[]}],"git":{"createdTime":1701514899000,"updatedTime":1701577533000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":2}]},"readingTime":{"minutes":49.13,"words":14738},"filePathRelative":"学习/Haskell中文文档/6.md","localizedDate":"2023年12月2日","excerpt":"<h1> 第 6 章：使用类型类</h1>\\n<p>类型类（typeclass）跻身于 <code>Haskell</code> 最强大功能之列：它们（typeclasses）允许你定义通用接口，而其（这些接口）为各种不同的类型（type）提供一组公共特性集。类型类是某些基本语言特性的核心，比如相等性测试（equalitytesting）和数值操作符（numeric operators）。在讨论到底类型类是什么之前，我想解释下他们的作用（the need for them）。</p>\\n<h2> 类型类的作用</h2>\\n<p>假设因为某个原因， <code>Haskell</code> 语言的设计者拒绝实现相等性测试 <code>==</code> ，因此我们决定实现自己的 <code>==</code> 操作。 你的应用由一个简单的 <code>Color</code> 类型组成。 首先你尝试一下，像这样：</p>","autoDesc":true}');export{e as data};
