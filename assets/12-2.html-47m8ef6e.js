import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as p,c as t,f as n,a,b as s}from"./app-Chw2KLnS.js";const o={},l=n(`<h2 id="finding-matching-digits" tabindex="-1"><a class="header-anchor" href="#finding-matching-digits"><span>寻找匹配的数字</span></a></h2><p>我们首先要面对的问题，是如何在某个 <em>可能</em> 编码了数字的位置把这个数字找出来。在此，我们要做一些简单的假设。第一个假设是我们处理的对象是图像中的单一行，第二个假设是我们明确知道条形码左边缘位置，这个位置即条形码的起始位置。</p><p>::: {#run-length-encoding} :::</p><h3 id="游程编码" tabindex="-1"><a class="header-anchor" href="#游程编码"><span>游程编码</span></a></h3><p>我们如何解决线条宽度的问题呢。答案就是对图像数据进行游程编码(run length encode)。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token keyword">type</span> <span class="token constant">Run</span> <span class="token operator">=</span> <span class="token constant">Int</span>
<span class="token keyword">type</span> <span class="token constant">RunLength</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Run</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token hvariable">runLength</span> <span class="token operator">::</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">RunLength</span> <span class="token hvariable">a</span>
<span class="token hvariable">runLength</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token hvariable">rle</span> <span class="token operator">.</span> <span class="token builtin">group</span>
    <span class="token keyword">where</span> <span class="token hvariable">rle</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token builtin">head</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>group</code> 函数会把一个列表中所有连续的相同元素分别放入一个子列表中。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token builtin">group</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的 <code>runLength</code> 函数将( <code>group</code> 返回的列表中的)每个子列表表示为子列表长度和首个元素组成的对。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span>  <span class="token builtin class-name">let</span> bits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1,1</span>,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1<span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span>  runLength bits
Loading package array-0.1.0.0 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
Loading package containers-0.1.0.1 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
Loading package bytestring-0.9.0.1 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2,1</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2,0</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2,1</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2,0</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">6,1</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2,0</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4,1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[译注：上述ghci输出的最后一行的列表中，每一个&quot;长度-值&quot;对就是一个&quot;游程&quot;]</p><p>由于我们进行游程编码的数据只包含0和1，因此编码的数字只会在0和1两个值之间变化。既然这样，我们就可以只保留长度而丢弃被编码数字，而不会丢失任何有用的信息。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">runLengths</span> <span class="token operator">::</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Run</span><span class="token punctuation">]</span>
<span class="token hvariable">runLengths</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">fst</span> <span class="token operator">.</span> <span class="token hvariable">runLength</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> runLengths bits
<span class="token punctuation">[</span><span class="token number">2,2</span>,2,2,6,4,4<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面给出的位模式并不是我们随便编出来的；而是上面我们捕获的图像中的某一行里面的编码的左侧保护序列和第一个编码数字。如果我们丢弃表示保护序列的条纹，游程编码后的值就是[2, 6, 4, 4]。我们怎样在&quot;引入数组&quot;一节中的编码表中找到匹配的位模式呢？</p>`,15),c=a("p",null,[s("[译注1：此处稍微做一下展开。首先，在 "),a("code",{class:"interpreted-text",role:"ref"},"greyscale-to-binary-and-type-safety"),s(" 一节中我们已经知道， "),a("code",null,"Zero"),s(" 才是代表黑色条纹的值。此处的0是与 "),a("code",null,"Zero"),s(" 对应的，它同样表示黑色条纹，相应的，1表示白色条纹，与 "),a("code",{class:"interpreted-text",role:"ref"},"ean-13-encoding"),s(" 一节中介绍EAN-13条码编码格式时约定的0/1所代表的颜色相反，再次请读者留心这点，因为接下来的内容都会遵守这个约定。]")],-1),i=n(`<p>[译注2：如果你实在看不出这个游程编码的值是如何表示之前捕获的图像中数字的，这里我们来详细解释一下。前文说过，由于条纹在照片中的实际宽度受到拍摄距离等因素的影响，因此我们不能对其有任何假设。而且一般来说，条形码中表示每1位的条纹所占的宽度几乎不可能只有1个像素，而是会由纵向上的复数个像素表示一位。比方说上面给出的序列，很明显就是用了两个像素来表示每个1个二进制位，其实际表示的二进制序列为&quot;01010001100&quot;(0为黑色，1为白色)，当&quot;以1为黑色，0为白色&quot;时，该序列即&quot;10101110011&quot;。这样就可以看出，该序列就是由&quot;101&quot;(左侧保护序列)和&quot;0111001&quot;(倒数第2位识别错误的&quot;7&quot;的奇校验编码)以及下一位数字的第一个二进制位&quot;0&quot;组成的了。]</p><p>::: {#scaling-run-lengths-and-finding-approximate-matches} :::</p><h3 id="缩放游程-查找相近的匹配" tabindex="-1"><a class="header-anchor" href="#缩放游程-查找相近的匹配"><span>缩放游程，查找相近的匹配</span></a></h3><p>一个合理的方法是缩放这些游程编码值，让它们的和为1。我们将使用 <code>Ratio Int</code> 类型替代一般的 <code>Double</code> 类型来保存这些缩放后的值，因为 <code>Ratio</code> 值在 <strong>ghci</strong> 的输出中可读性更好。这点可以为交互式调试与开发提供方便。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token keyword">type</span> <span class="token constant">Score</span> <span class="token operator">=</span> <span class="token constant">Ratio</span> <span class="token constant">Int</span>

<span class="token hvariable">scaleToOne</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Run</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Score</span><span class="token punctuation">]</span>
<span class="token hvariable">scaleToOne</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token hvariable">divide</span> <span class="token hvariable">xs</span>
    <span class="token keyword">where</span> <span class="token hvariable">divide</span> <span class="token hvariable">d</span> <span class="token operator">=</span> <span class="token builtin">fromIntegral</span> <span class="token hvariable">d</span> <span class="token operator">/</span> <span class="token hvariable">divisor</span>
        <span class="token hvariable">divisor</span> <span class="token operator">=</span> <span class="token builtin">fromIntegral</span> <span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
<span class="token comment">-- A more compact alternative that &quot;knows&quot; we&#39;re using Ratio Int:</span>
<span class="token comment">-- scaleToOne xs = map (% sum xs) xs</span>

<span class="token keyword">type</span> <span class="token constant">ScoreTable</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Score</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token comment">-- &quot;SRL&quot; means &quot;scaled run length&quot;.</span>
<span class="token hvariable">asSRL</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">ScoreTable</span>
<span class="token hvariable">asSRL</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token hvariable">scaleToOne</span> <span class="token operator">.</span> <span class="token hvariable">runLengths</span><span class="token punctuation">)</span>

<span class="token hvariable">leftOddSRL</span> <span class="token operator">=</span> <span class="token hvariable">asSRL</span> <span class="token hvariable">leftOddList</span>
<span class="token hvariable">leftEvenSRL</span> <span class="token operator">=</span> <span class="token hvariable">asSRL</span> <span class="token hvariable">leftEvenList</span>
<span class="token hvariable">rightSRL</span> <span class="token operator">=</span> <span class="token hvariable">asSRL</span> <span class="token hvariable">rightList</span>
<span class="token hvariable">paritySRL</span> <span class="token operator">=</span> <span class="token hvariable">asSRL</span> <span class="token hvariable">parityList</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们定义了类型别名 <code>Score</code>，这样其余的大部分代码就不需要关心 <code>Score</code> 底层的类型是什么。当我们的代码开发完毕，一头埋进 <strong>ghci</strong> 做后续调试的时候，只要我们愿意，我们还是能把&quot; <code>Score</code> &quot;对应的底层类型改为 <code>Double</code> ，而不需要修改其它代码。</p><p>我们可以用 <code>scalarToOne</code> 函数来缩放我们所要寻找的数字序列。我们解决了拍摄距离所导致的条纹宽度不能确定的问题。现在，在缩放后的游程编码表和从图像中的提取出游程编码序列间应该有十分接近的匹配。</p><p>接下来的问题是如何将直观感觉上的&quot;十分接近&quot;转化为对&quot;足够接近&quot;的度量。给出两个缩放过的长度序列，我们可以像下面这样计算出一个大概的&quot;差异度&quot;(distance)。</p><p>精确匹配的两个值之间的差异度是0，匹配程度越低，差异度的值就越大。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> group <span class="token operator">=</span> scaleToOne <span class="token punctuation">[</span><span class="token number">2,6</span>,4,4<span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> distance group <span class="token punctuation">(</span>head leftEvenSRL<span class="token punctuation">)</span>
<span class="token number">13</span>%28
ghci<span class="token operator">&gt;</span> distance group <span class="token punctuation">(</span>head leftOddSRL<span class="token punctuation">)</span>
<span class="token number">17</span>%28
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对给定的一个经过缩放的游程编码表，我们从中选择与输入序列最接近的几个匹配结果。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">bestScores</span> <span class="token operator">::</span> <span class="token constant">ScoreTable</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Run</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Score</span><span class="token punctuation">,</span> <span class="token constant">Digit</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">bestScores</span> <span class="token hvariable">srl</span> <span class="token hvariable">ps</span> <span class="token operator">=</span> <span class="token builtin">take</span> <span class="token number">3</span> <span class="token operator">.</span> <span class="token builtin">sort</span> <span class="token operator">$</span> <span class="token hvariable">scores</span>
    <span class="token keyword">where</span> <span class="token hvariable">scores</span> <span class="token operator">=</span> <span class="token builtin">zip</span> <span class="token punctuation">[</span><span class="token hvariable">distance</span> <span class="token hvariable">d</span> <span class="token punctuation">(</span><span class="token hvariable">scaleToOne</span> <span class="token hvariable">ps</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">d</span> <span class="token operator">&lt;-</span> <span class="token hvariable">srl</span><span class="token punctuation">]</span> <span class="token hvariable">digits</span>
          <span class="token hvariable">digits</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token number">9</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>::: {#list-comprehensions} :::</p><h3 id="列表推导式" tabindex="-1"><a class="header-anchor" href="#列表推导式"><span>列表推导式</span></a></h3><p>我们在上面的例子中引入的新表示法叫做 <em>列表推导式(list comprehension)</em> ，列表推导式可以以一个或多个列表为基础创建新列表。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span>a,b<span class="token punctuation">)</span> <span class="token operator">|</span> a <span class="token operator">&lt;</span>- <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span>, b <span class="token operator">&lt;</span>- <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&#39;c&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&#39;c&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>竖线右侧的每一个 <em>生成器表达式(generator expression)</em> 组合，都会代入到竖线左侧的表达式中求值。生成表达式绑定了左侧的变量a，a又用&quot;&lt;-&quot;绑定到右侧的元素列表。正如上面的例子展示的，生成表达式的组合将按照深度优先的顺序遍历：先是第一个列表的第一个元素分别与第二个列表中的每个元素分别组合，以此类推。</p><p>我们还可以在列表推导式的右侧为生成器指定guard。guard是一个 <code>Bool</code> 表达式。如果guard的值为 <code>False</code> , 则该元素被跳过。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span>a,b<span class="token punctuation">)</span> <span class="token operator">|</span> a <span class="token operator">&lt;</span>- <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">6</span><span class="token punctuation">]</span>, b <span class="token operator">&lt;</span>- <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">..</span><span class="token number">7</span><span class="token punctuation">]</span>, even <span class="token punctuation">(</span>a + b ^ <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1,5</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">1,7</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2,6</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3,5</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3,7</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4,6</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">5,5</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">5,7</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">6,6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中还可以用 <code>let</code> 表达式绑定本地变量(local variable)。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> vowel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable"><span class="token variable">\`</span>elem<span class="token variable">\`</span></span> <span class="token string">&quot;aeiou&quot;</span><span class="token punctuation">)</span>
ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span> x <span class="token operator">|</span> a <span class="token operator">&lt;</span>- <span class="token string">&quot;etaoin&quot;</span>, b <span class="token operator">&lt;</span>- <span class="token string">&quot;shrdlu&quot;</span>, <span class="token builtin class-name">let</span> x <span class="token operator">=</span> <span class="token punctuation">[</span>a,b<span class="token punctuation">]</span>, all vowel x <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">&quot;eu&quot;</span>,<span class="token string">&quot;au&quot;</span>,<span class="token string">&quot;ou&quot;</span>,<span class="token string">&quot;iu&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果生成器表达式中的某个模式匹配失败了，那么也不会有错误发生，只会跳过未匹配的列表元素。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span> a <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">3</span>,a<span class="token punctuation">)</span> <span class="token operator">&lt;</span>- <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&#39;y&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3</span>,<span class="token string">&#39;e&#39;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">5</span>,<span class="token string">&#39;p&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">]</span>
<span class="token string">&quot;e&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>列表推导式功能强大用法简洁，但可能不太容易看懂。如果能小心使用，它也可以让我们的代码更容易理解。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token comment">-- our original</span>
<span class="token builtin">zip</span> <span class="token punctuation">[</span><span class="token hvariable">distance</span> <span class="token hvariable">d</span> <span class="token punctuation">(</span><span class="token hvariable">scaleToOne</span> <span class="token hvariable">ps</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">d</span> <span class="token operator">&lt;-</span> <span class="token hvariable">srl</span><span class="token punctuation">]</span> <span class="token hvariable">digits</span>

<span class="token comment">-- the same expression, expressed without a list comprehension</span>
<span class="token builtin">zip</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">flip</span> <span class="token hvariable">distance</span> <span class="token punctuation">(</span><span class="token hvariable">scaleToOne</span> <span class="token hvariable">ps</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">srl</span><span class="token punctuation">)</span> <span class="token hvariable">digits</span>

<span class="token comment">-- the same expression, written entirely as a list comprehension</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">distance</span> <span class="token hvariable">d</span> <span class="token punctuation">(</span><span class="token hvariable">scaleToOne</span> <span class="token hvariable">ps</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">d</span> <span class="token operator">&lt;-</span> <span class="token hvariable">srl</span><span class="token punctuation">,</span> <span class="token hvariable">n</span> <span class="token operator">&lt;-</span> <span class="token hvariable">digits</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>::: {#remembering-a-matchs-parity} :::</p><h3 id="记录匹配数字的奇偶性" tabindex="-1"><a class="header-anchor" href="#记录匹配数字的奇偶性"><span>记录匹配数字的奇偶性</span></a></h3><p>对左侧分组数字的每一个匹配，我们必须记录它是在奇校验编码表还是偶校验编码表中匹配到的。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token keyword">data</span> <span class="token constant">Parity</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Even</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Odd</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">None</span> <span class="token hvariable">a</span>
                <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>

<span class="token hvariable">fromParity</span> <span class="token operator">::</span> <span class="token constant">Parity</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">fromParity</span> <span class="token punctuation">(</span><span class="token constant">Even</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">a</span>
<span class="token hvariable">fromParity</span> <span class="token punctuation">(</span><span class="token constant">Odd</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">a</span>
<span class="token hvariable">fromParity</span> <span class="token punctuation">(</span><span class="token constant">None</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">a</span>

<span class="token hvariable">parityMap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Parity</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Parity</span> <span class="token hvariable">b</span>
<span class="token hvariable">parityMap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Even</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Even</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">parityMap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Odd</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Odd</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">parityMap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">None</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">None</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>

<span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Parity</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">=</span> <span class="token hvariable">parityMap</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们将匹配到的数字包装在该数字的实际编码所采用的奇偶性内，并且使它成为一个 <code>Functor</code> 实体，这样我们就可以方便的操作奇偶编码值(parity-encoded values)了。</p><p>[译注：此处所说的&quot;奇偶编码值&quot;可以理解为&quot;对同一个数字同时具有奇校验编码和偶校验编码两种形式的编码值&quot;(即左分组中所有的编码值都是&quot;奇偶编码值&quot;)，为了简化描述，后文也会采用这种简称，请读者留意。]</p><p>我们可能需要对奇偶编码值按它们包含的数字进行排序。 <code>Data.Function</code> 模块提供的一个好用的组合子 <code>on</code> 可以帮助我们实现这个功能。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">on</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">c</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">on</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token operator">\`f\`</span> <span class="token hvariable">g</span> <span class="token hvariable">y</span>

<span class="token hvariable">compareWithoutParity</span> <span class="token operator">=</span> <span class="token builtin">compare</span> <span class="token operator">\`on\`</span> <span class="token hvariable">fromParity</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的作用可能不是很明确，你可以试着去想象这样一个函数：它接受两个参数f和g，返回值是一个函数，这个返回的函数也有两个参数，分别为 <code>x</code> 和 <code>y</code> 。 <code>on</code> 将 <code>g</code> 分别对 <code>x</code> 和 <code>y</code> 应用，然后将 <code>f</code> 应用于这两个结果(所以它的名字叫 <code>on</code> )。</p><p>把匹配数字装入奇偶性的方法一目了然。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token keyword">type</span> <span class="token constant">Digit</span> <span class="token operator">=</span> <span class="token constant">Word8</span>

<span class="token hvariable">bestLeft</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Run</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token punctuation">(</span><span class="token constant">Score</span><span class="token punctuation">,</span> <span class="token constant">Digit</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">bestLeft</span> <span class="token hvariable">ps</span> <span class="token operator">=</span> <span class="token hvariable">sortBy</span> <span class="token hvariable">compareWithoutParity</span>
          	<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token constant">Odd</span> <span class="token punctuation">(</span><span class="token hvariable">bestScores</span> <span class="token hvariable">leftOddSRL</span> <span class="token hvariable">ps</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span>
           		<span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token constant">Even</span> <span class="token punctuation">(</span><span class="token hvariable">bestScores</span> <span class="token hvariable">leftEvenSRL</span> <span class="token hvariable">ps</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token hvariable">bestRight</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Run</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token punctuation">(</span><span class="token constant">Score</span><span class="token punctuation">,</span> <span class="token constant">Digit</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">bestRight</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token constant">None</span> <span class="token operator">.</span> <span class="token hvariable">bestScores</span> <span class="token hvariable">rightSRL</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一旦在奇校验表或偶校验表里找到了左侧分组某个编码的几个最佳匹配，我们就可以将他们按照匹配的质量排序。</p><p>::: {#another-kind-of-laziness-of-keyboarding-variety} :::</p><h3 id="键盘惰性" tabindex="-1"><a class="header-anchor" href="#键盘惰性"><span>键盘惰性</span></a></h3><p>定义 <code>Parity</code> 类型时,我们可以使用haskell的记录( <code>record</code> )语法来避免手写formParity函数。也就是说，可以这么写：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token keyword">data</span> <span class="token constant">AltParity</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">AltEven</span> <span class="token punctuation">{</span><span class="token hvariable">fromAltParity</span> <span class="token operator">::</span> <span class="token hvariable">a</span><span class="token punctuation">}</span>
             	<span class="token operator">|</span> <span class="token constant">AltOdd</span>  <span class="token punctuation">{</span><span class="token hvariable">fromAltParity</span> <span class="token operator">::</span> <span class="token hvariable">a</span><span class="token punctuation">}</span>
             	<span class="token operator">|</span> <span class="token constant">AltNone</span> <span class="token punctuation">{</span><span class="token hvariable">fromAltParity</span> <span class="token operator">::</span> <span class="token hvariable">a</span><span class="token punctuation">}</span>
               	<span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那我们为什么没这么做呢？答案说起来有些丢人，而且与 <strong>ghci</strong> 的交互调试有关。当我们告诉GHC让它自动把一个类型派生为 <code>Show</code> 的实体时，GHC会根据我们是否使用记录语法来定义这个类型而生成不同的代码。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> show $ Even <span class="token number">1</span>
<span class="token string">&quot;Even 1&quot;</span>
ghci<span class="token operator">&gt;</span> show $ AltEven <span class="token number">1</span>
<span class="token string">&quot;AltEven {fromAltParity = 1}&quot;</span>
ghci<span class="token operator">&gt;</span> length <span class="token builtin class-name">.</span> show $ Even <span class="token number">1</span>
<span class="token number">6</span>
ghci<span class="token operator">&gt;</span> length <span class="token builtin class-name">.</span> show $ AltEven <span class="token number">1</span>
<span class="token number">27</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用记录语法定义生成的Show实体明显很&quot;啰嗦&quot;，同时这也会给调试带来很大的干扰。比方说在我们检查 <strong>ghci</strong> 输出的奇偶编码值列表的时候，这样的输出结果会特别长以至于我们不得不一行行地扫读输出结果。</p><p>当然我们可以手动实现干扰更少的Show实体。避开记录语法写起来也更简洁，而且通过编写我们自己的 <code>formParity</code> 函数可以让GHC帮我们派生输出更简洁的 <code>Show</code> 实例。其实也并不是非这么做不可，但是程序员的惰性有时也的确会为代码引入一些特别的做法。</p><h3 id="chunking-a-list" tabindex="-1"><a class="header-anchor" href="#chunking-a-list"><span>列表分块</span></a></h3><p>使用列表时常常需要对它进行分块(chunk)。例如，条形码中的每个数字都由四个连续的数字编码而成。我们可以将表示一个行的列表转换为如下这种包含四个元素的列表组成的列表。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">chunkWith</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">chunkWith</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">chunkWith</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">h</span><span class="token punctuation">,</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>
             	<span class="token keyword">in</span> <span class="token hvariable">h</span> <span class="token operator">:</span> <span class="token hvariable">chunkWith</span> <span class="token hvariable">f</span> <span class="token hvariable">t</span>

<span class="token hvariable">chunksOf</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">chunksOf</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token hvariable">chunkWith</span> <span class="token punctuation">(</span><span class="token builtin">splitAt</span> <span class="token hvariable">n</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>像这种需要手写泛型的列表操作函数的情况比较罕见。因为一般在 <code>Data.List</code> 模块里翻一翻就能找到完全符合要求或者基本满足需要的函数。</p><h3 id="generating-a-list-of-candidate-digits" tabindex="-1"><a class="header-anchor" href="#generating-a-list-of-candidate-digits"><span>生成候选数字列表</span></a></h3><p>这几个辅助函数一旦就绪，为每个数字分组生成候选匹配的函数也就很容易搞定了。首先，我们先得做一些前期的检查，来确定这些匹配是否都是有意义的。只有以黑色( <code>Zero</code> )条纹开始，并且条纹数量足够多的游程列表才是有意义的。下面是这个函数中的前几个等式。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">candidateDigits</span> <span class="token operator">::</span> <span class="token constant">RunLength</span> <span class="token constant">Bit</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token constant">Digit</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">candidateDigits</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token constant">One</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">candidateDigits</span> <span class="token hvariable">rle</span> <span class="token operator">|</span> <span class="token builtin">length</span> <span class="token hvariable">rle</span> <span class="token operator">&lt;</span> <span class="token number">59</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[译注：代码中的59表示条形码中的条纹数，它是这样求出的：3(左侧保护序列101)+4x6(每个数字的条纹数目4x左侧分组的数字数)+5(两个分组中间的保护序列10101)+4x6(同左分组)+3(右侧保护序列) = 59。]</p><p>只要任意一次 <code>bestLeft</code> 或 <code>bestRight</code> 的应用得到一个空列表，我们都不能返回有效结果。否则，我们将丢弃 <code>Score</code> 值，返回一个由标记了编码奇偶性的候选数字列表组成的列表。外部的列表有12个元素，每个元素都代表条形码中的一个数字。子列表中的每个数字都根据匹配质量排序。</p><p>下面给出这个函数的其余部分</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">candidateDigits</span> <span class="token hvariable">rle</span>
    <span class="token operator">|</span> <span class="token builtin">any</span> <span class="token builtin">null</span> <span class="token hvariable">match</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>      <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token builtin">snd</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">match</span>
  <span class="token keyword">where</span> <span class="token hvariable">match</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token hvariable">bestLeft</span> <span class="token hvariable">left</span> <span class="token operator">++</span> <span class="token builtin">map</span> <span class="token hvariable">bestRight</span> <span class="token hvariable">right</span>
        <span class="token hvariable">left</span> <span class="token operator">=</span> <span class="token hvariable">chunksOf</span> <span class="token number">4</span> <span class="token operator">.</span> <span class="token builtin">take</span> <span class="token number">24</span> <span class="token operator">.</span> <span class="token builtin">drop</span> <span class="token number">3</span> <span class="token operator">$</span> <span class="token hvariable">runLengths</span>
        <span class="token hvariable">right</span> <span class="token operator">=</span> <span class="token hvariable">chunksOf</span> <span class="token number">4</span> <span class="token operator">.</span> <span class="token builtin">take</span> <span class="token number">24</span> <span class="token operator">.</span> <span class="token builtin">drop</span> <span class="token number">32</span> <span class="token operator">$</span> <span class="token hvariable">runLengths</span>
        <span class="token hvariable">runLengths</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">fst</span> <span class="token hvariable">rle</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看一看从上面图像中提取出的每个线条分组(表示一个数字的四个线条算作一组)对应的候选数字。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token punctuation">\\</span><span class="token operator">&gt;</span> :type input input :: <span class="token punctuation">\\</span><span class="token punctuation">[</span><span class="token punctuation">(</span>Run, Bit<span class="token punctuation">)</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> ghci<span class="token punctuation">\\</span><span class="token operator">&gt;</span> take <span class="token number">7</span> input
<span class="token punctuation">\\</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span>,Zero<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,One<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,Zero<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,One<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">6</span>,Zero<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4</span>,One<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4</span>,Zero<span class="token punctuation">)</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> ghci<span class="token punctuation">\\</span><span class="token operator">&gt;</span>
mapM<span class="token punctuation">\\</span>_ print <span class="token punctuation">\\</span>$ candidateDigits input <span class="token punctuation">\\</span><span class="token punctuation">[</span>Even <span class="token number">1</span>,Even <span class="token number">5</span>,Odd <span class="token number">7</span>,Odd <span class="token number">1</span>,Even
<span class="token number">2</span>,Odd <span class="token number">5</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>Even <span class="token number">8</span>,Even <span class="token number">7</span>,Odd <span class="token number">1</span>,Odd <span class="token number">2</span>,Odd <span class="token number">0</span>,Even <span class="token number">6</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>Even <span class="token number">0</span>,Even <span class="token number">1</span>,Odd
<span class="token number">8</span>,Odd <span class="token number">2</span>,Odd <span class="token number">4</span>,Even <span class="token number">9</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>Odd <span class="token number">1</span>,Odd <span class="token number">0</span>,Even <span class="token number">8</span>,Odd <span class="token number">2</span>,Even <span class="token number">2</span>,Even <span class="token number">4</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>Even
<span class="token number">3</span>,Odd <span class="token number">4</span>,Odd <span class="token number">5</span>,Even <span class="token number">7</span>,Even <span class="token number">0</span>,Odd <span class="token number">2</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>Odd <span class="token number">2</span>,Odd <span class="token number">4</span>,Even <span class="token number">7</span>,Even <span class="token number">0</span>,Odd
<span class="token number">1</span>,Even <span class="token number">1</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>None <span class="token number">1</span>,None <span class="token number">5</span>,None <span class="token number">0</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>None <span class="token number">1</span>,None <span class="token number">5</span>,None <span class="token number">2</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>None
<span class="token number">4</span>,None <span class="token number">5</span>,None <span class="token number">2</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>None <span class="token number">6</span>,None <span class="token number">8</span>,None <span class="token number">2</span><span class="token punctuation">\\</span><span class="token punctuation">]</span> <span class="token punctuation">\\</span><span class="token punctuation">[</span>None <span class="token number">7</span>,None <span class="token number">8</span>,None <span class="token number">3</span><span class="token punctuation">\\</span><span class="token punctuation">]</span>
<span class="token punctuation">\\</span><span class="token punctuation">[</span>None <span class="token number">7</span>,None <span class="token number">3</span>,None <span class="token number">8</span><span class="token punctuation">\\</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="life-without-arrays-or-hash-tables" tabindex="-1"><a class="header-anchor" href="#life-without-arrays-or-hash-tables"><span>没有数组和散列表的日子</span></a></h2><p>在命令式语言中，数组的地位就像是Haskell中的列表或元组，不可或缺。命令式语言中的数组通常是可变的，即我们随时可以修改数组中的元素值，我们对这点也习以为常。</p><p>正如我们在&quot;修改数组元素&quot;一节中提到的一样，Haskell数组并不是可变的。这意味着如果要&quot;修改&quot;数组中的单个元素，整个数组都要被复制一次，被修改的元素将在复制的过程中被设置为新的值。显然，以这种方法&quot;修改&quot;数组不可能在性能比拼中获胜。</p><p>可变数组还被用来构建另一种命令式语言常见数据结构------散列表(hash table)。在散列表的典型实现中，数组扮演了&quot;脊柱&quot;的角色：数组中的每个元素都是一个列表。在散列表中添加一个元素时，我们通过对元素进行散列(hash)，确定这个元素在数组中的偏移，然后修改位于这个偏移的列表，把这个元素添加进去。</p><p>如果构造散列表所使用的数组不是可变的，那么如果要更新一个散列表的话，我们就不得不创建一个新的数组------先复制原数组，然后把一个新的列表放到由散列值确定的偏移位置上。我们不需要复制其他偏移位置上的列表，但是由于必须复制这个&quot;脊柱&quot;，性能方面已经遭到了致命打击。</p><p>不可变的数组一下就让我们的工具箱中两种命令式语言中的典型数据结构直接下岗。可见数组在纯Haskell代码中的确不像在许多别的语言中那么有用。不过，有很多涉及数组的代码都只是在构建阶段更新数组，构建完成后都将其当作只读的数组来使用。</p><p>[译注：此处的&quot;构建阶段(build phase)&quot;并不仅限于用 <code>listArray</code> 函数或者直接调用构造器函数，还包括&quot;原始的&quot;数组生成完毕，进行后续的值设置的过程，这些过程中可能包含对数组的修改(以及底层的复制)操作。]</p><h3 id="答案的森林" tabindex="-1"><a class="header-anchor" href="#答案的森林"><span>答案的森林</span></a></h3><p>但事实上，用不了可变的数组和散列表并没有想象中那么悲剧。数组和散列表经常被用作由键索引的值的集合，而在Haskell中，我们使用 <em>树</em> 来实现这个功能。</p><p>在Haskell中实现一个简单的树类型非常简单。不仅如此，更实用的树类型实现起来也是出奇的简单。比方说红黑树。红黑树这种自平衡结构，就是因为其平衡算法出了名的难写，才让几代CS在校生闻风丧胆。</p><p>综合运用Haskell的代数数据类型组合、模式匹配、guard等特性可以把最可怕的平衡操作的代码缩减至只有短短几行。但是我们先不急着构造树类型，先来关注为什么它们在纯函数式语言中特别有用。</p><p>对函数式程序员来说，树的吸引力在于修改代价低。我们不用打破不可变原则：树就和其他东西一样不可变。然而，我们修改一棵树的时候，可以在新旧两棵树之间共享大部分的结构。举例来说，有一颗有10000个节点的树，我们可能想要在里面添加或者移除一个节点，这种情况下，新旧两棵树能够共享大约9985个节点。换句话说，每次更新树的时候所需要修改的元素数目取决于树的高度，或者说是节点数的对数。</p><p>Haskell标准库提供了两种采用平衡树实现的集合类型：Data.Map用于键/值对，<code>Data.Set</code> 用于集合。鉴于在下一节会用到 <code>Data.Map</code>，我们就先简要地介绍一下这个模块。 <code>Data.Set</code> 与 <code>Data.Map</code> 很相似，相信你应该也能很快掌握。</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>关于性能</p><p>一个具有良好实现的纯函数式树结构与散列表在性能上应该是可以一较高下的。你不应该在你的代码会付出性能代价的假设下实现树类型。</p></div><p>::: {#a-brief-introduction-to-maps} :::</p><h3 id="map简介" tabindex="-1"><a class="header-anchor" href="#map简介"><span>map简介</span></a></h3><p><code>Data.Map</code> 模块提供了参数化类型 <code>Map k a</code> ，将键类型k映射到关联值类型a。尽管其内部为一个size-balanced tree，但是它的实现对我们是不可见的。</p><p>[译注1：Size-Balanced Tree（SBT）是一种通过大小(Size)域来保持平衡的二叉搜索树，因此得名。]</p><p>[译注2：原文对于value的使用有些混乱。为了明确表达，从此处开始，key都译为&quot;键&quot;，而value在表达&quot;map中由key所映射到的值&quot;时都译为&quot;映射值&quot;]</p><p><code>Map</code> 的键是严格求值的，但是映射值却是非严格求值。换句话说，map的 <em>脊柱</em> ，或者说结构，是一直在更新的，但是map中映射的值还是要等到我们强迫对它们求值的时候才被计算出来。</p><p>记住这点很重要，因为对于不期望内存泄漏的程序员来说， <code>Map</code> 类型对映射值采用的惰性求值策略往往是内存泄漏的源头。</p><p>由于 <code>Data.Map</code> 模块包含几个与 <code>Prelude</code> 模块中冲突的名字，所以它通常用限定形式导入。本章靠前的部分中，我们再导入它时添加了一个前缀 <code>M</code> 。</p><h3 id="type-constraints" tabindex="-1"><a class="header-anchor" href="#type-constraints"><span>类型约束</span></a></h3><p>Map类型并不对键值的类型做任何显式的约束，但是该模块中多数实用函数都要求键类型为 <code>Ord</code> 类型类的实体。需要强调的是，这里体现了Haskell中一个常见设计模式：类型约束的设置应该推迟到最终应用的地方，而不需要库作者为这种事情做额外劳动。</p><p><code>Map</code> 类型和该模块中的函数都没有对映射值的类型设置约束。</p><p>::: {#partial-application-awkwardness} :::</p><h3 id="部分应用时的尴尬" tabindex="-1"><a class="header-anchor" href="#部分应用时的尴尬"><span>部分应用时的尴尬</span></a></h3><p>由于某些原因，<code>Data.Map</code> 模块中的某些函数的类型签名并不便于部分应用。函数操作的map总是作为最后一个参数，但是它们是第一个参数才更便于局部应用。结果造成使用部分应用Map函数的代码几乎总得通过适配函数(adapter function)来调整参数顺序。</p><p>::: {#getting-started-with-the-api} :::</p><h3 id="map-api入门" tabindex="-1"><a class="header-anchor" href="#map-api入门"><span>map API入门</span></a></h3><p><code>Data.Map</code> 模块有一个巨大的&quot;暴露区&quot;(surface area)：它导出了很多函数。而其中只有为数不多的几个函数算得上是该模块中最常用的核心部分。</p><p>如果需要创建一个空的 <code>map</code> ,可以使用 <code>empty</code> 函数。如果要创建包含一个键/值对的 <code>map</code> ，则应该使用 <code>singleton</code> 函数。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> M.empty
Loading package array-0.1.0.0 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
Loading package containers-0.1.0.1 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
fromList <span class="token punctuation">[</span><span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> M.singleton <span class="token string">&quot;foo&quot;</span> True
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span>,True<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 <code>Map</code> 的实现对我们是透明的，我们就无法对 <code>Map</code> 类型的值进行模式匹配。不过，该模块提供了一些查找函数可供我们使用，其中有两个函数应用特别广泛。查找函数有一个稍微复杂的类型签名，但是不要着急，这些很快在第14章中都会弄明白的。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type M.lookup
M.lookup :: <span class="token punctuation">(</span>Ord k, Monad m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> k -<span class="token operator">&gt;</span> M.Map k a -<span class="token operator">&gt;</span> m a
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>返回值中的类型参数m通常是Maybe类型。话句话说，如果map中包含具有给定键的映射值，lookup函数会把映射值装入 <code>Just</code> 返回。否则返回 <code>Nothing</code> 。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> m <span class="token operator">=</span> M.singleton <span class="token string">&quot;foo&quot;</span> <span class="token number">1</span> :: M.Map String Int
ghci<span class="token operator">&gt;</span> <span class="token keyword">case</span> M.lookup <span class="token string">&quot;bar&quot;</span> m of <span class="token punctuation">{</span> Just <span class="token function">v</span> -<span class="token operator">&gt;</span> <span class="token string">&quot;yay&quot;</span><span class="token punctuation">;</span> Nothing -<span class="token operator">&gt;</span> <span class="token string">&quot;boo&quot;</span> <span class="token punctuation">}</span>
<span class="token string">&quot;boo&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>findWithDefault</code> 函数额外指定一个参数值，如果map中不包含查找的键，则返回该指定值。</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>小心部分应用函数！</p><p>有一个(!)运算符会查找键并且返回与该键关联的原始值（即，不是返回装在 <code>Maybe</code> 或者其他什么东西里的值)。不幸的是，这并不是一个全函数：如果该键在map中不存在的话，它会调用 <code>error</code> 。</p></div><p>要在map中添加一个键值对，最有用的函数是 <code>insert</code> 和 <code>insertWith’</code> 。insert函数就是简单的在map中插入键/值对，如果该键已经存在，则覆盖其关联的任何值。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type M.insert
M.insert :: <span class="token punctuation">(</span>Ord k<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> k -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> M.Map k a -<span class="token operator">&gt;</span> M.Map k a
ghci<span class="token operator">&gt;</span> M.insert <span class="token string">&quot;quux&quot;</span> <span class="token number">10</span> m
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span>,1<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">&quot;quux&quot;</span>,10<span class="token punctuation">)</span><span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> M.insert <span class="token string">&quot;foo&quot;</span> <span class="token number">9999</span> m
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span>,9999<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>insertWith&#39;</code> 函数会额外接受一个 <em>组合函数(combining function)</em> 。如果map中没有指定的键，就把该键/值对原封不动插入。否则，就先对新旧两个映射值应用组合函数，把应用的结果作为新的映射值更新到map中。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type M.insertWith<span class="token string">&#39;
M.insertWith&#39;</span> :: <span class="token punctuation">(</span>Ord k<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> a<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> k -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> M.Map k a -<span class="token operator">&gt;</span> M.Map k a
ghci<span class="token operator">&gt;</span> M.insertWith<span class="token string">&#39; (+) &quot;zippity&quot; 10 m
fromList [(&quot;foo&quot;,1),(&quot;zippity&quot;,10)]
ghci&gt; M.insertWith&#39;</span> <span class="token punctuation">(</span>+<span class="token punctuation">)</span> <span class="token string">&quot;foo&quot;</span> <span class="token number">9999</span> m
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span>,10000<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数名最后的钩号暗示我们 <code>insertWith&#39;</code> 将对组合函数严格求值。这个设计帮你避免了内存泄漏。该函数同时存在一个惰性的变种(即没有最后钩号的 <code>insertWith</code> )，但你大概永远用不到它。</p><p><code>delete</code> 函数从map中删除指定键。如果键不存在的话， <code>delete</code> 会将map原封不动返回。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type M.delete
M.delete :: <span class="token punctuation">(</span>Ord k<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> k -<span class="token operator">&gt;</span> M.Map k a -<span class="token operator">&gt;</span> M.Map k a
ghci<span class="token operator">&gt;</span> M.delete <span class="token string">&quot;foo&quot;</span> m
fromList <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，还有几个常用的函数用于在maps上进行类似集合的操作。例如，我们接下来会用到的 <code>union</code>。这个函数是&quot;左偏&quot;(left biased)的：如果两个map包含相同的键，返回map中将包含左侧map中对应的关联值。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> m <span class="token variable"><span class="token variable">\`</span>M.union<span class="token variable">\`</span></span> M.singleton <span class="token string">&quot;quux&quot;</span> <span class="token number">1</span>
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span>,1<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">&quot;quux&quot;</span>,1<span class="token punctuation">)</span><span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> m <span class="token variable"><span class="token variable">\`</span>M.union<span class="token variable">\`</span></span> M.singleton <span class="token string">&quot;foo&quot;</span> <span class="token number">0</span>

fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span>,1<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此我们仅仅讲到了Data.Map中百分之十的API。在第13章中我们会更加广泛深入的讲解其中的API。我们鼓励你自行浏览模块的文档，相信你会从中获得更多启发。这个模块滴水不漏的设计一定会让你印象深刻。</p><h3 id="further-reading" tabindex="-1"><a class="header-anchor" href="#further-reading"><span>延伸阅读</span></a></h3><p>[Okasaki99]一书将教我们如何优雅且严密地实现纯函数式数据结构，其中包括多种平衡树。该书还中还包含了作者对于纯函数式数据结构和惰性求值的宝贵思考。</p><p>我们把Okasaki这本书列为为函数式程序员的必读书目。如果你不方便翻阅Okasaki这本书，可以去看Okasaki的博士论文，[Okasaki96]是该书的一个不很完整的精简版本，在网上可以免费获得。</p><p>::: {#turning-digit-soup-into-an-answer} :::</p><h2 id="从成堆的数字中找出答案" tabindex="-1"><a class="header-anchor" href="#从成堆的数字中找出答案"><span>从成堆的数字中找出答案</span></a></h2><p>我们现在又有了新的问题要解决。后十二个数字还只是一堆候选数字；此外，我们需要根据这12个数字中的前6个数字的奇偶性信息来计算第一个数字。最后，我们还需要确认求出的校验码的有效性。</p><p>这看起来很有挑战！这一大堆不确定的数据；该拿它们怎么办？采用暴力搜索是一个很合理的提议。那么，如果候选数字就是上面的 <strong>ghci</strong> 会话中给出的那些，我们需要测试多少种组合？</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> product <span class="token builtin class-name">.</span> map length <span class="token builtin class-name">.</span> candidateDigits $ input
<span class="token number">34012224</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可见暴力搜索要检查的组合太多了。我们还是先着眼于一个知道如何解决的子问题，晚些时候在考虑剩下的的。</p><p>::: {#solving-for-check-digits-in-parallel} :::</p><h3 id="批量求解校验码" tabindex="-1"><a class="header-anchor" href="#批量求解校验码"><span>批量求解校验码</span></a></h3><p>我们暂时不考虑搜索的方案，先来关注如何计算校验码。条形码的校验码可以是十个数字中的任意一个。对于一个给定的校验码，怎样反推出它是从怎样的输入序列中计算出来的呢？</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token keyword">type</span> <span class="token constant">Map</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">M<span class="token punctuation">.</span>Map</span> <span class="token constant">Digit</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个map中，键值是一个校验码，映射值是一个可以计算出这个校验码的序列。以它为基础，我们进一步定义两种map类型。</p><p>我们将把这两种类型的map统称为&quot;答案map&quot;(solution map)，因为它们包含了&quot;求解&quot;每个校验码对应的各个数字序列。</p><p>给定一个数字，我们可以按如下方法更新一个给定的答案map</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">updateMap</span> <span class="token operator">::</span> <span class="token constant">Parity</span> <span class="token constant">Digit</span>       <span class="token comment">-- ^ new digit</span>
          <span class="token operator">-&gt;</span> <span class="token constant">Digit</span>              <span class="token comment">-- ^ existing key</span>
          <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token constant">Digit</span><span class="token punctuation">]</span>     <span class="token comment">-- ^ existing digit sequence</span>
          <span class="token operator">-&gt;</span> <span class="token constant">ParityMap</span>          <span class="token comment">-- ^ map to update</span>
          <span class="token operator">-&gt;</span> <span class="token constant">ParityMap</span>
<span class="token hvariable">updateMap</span> <span class="token hvariable">digit</span> <span class="token hvariable">key</span> <span class="token builtin">seq</span> <span class="token operator">=</span> <span class="token hvariable">insertMap</span> <span class="token hvariable">key</span> <span class="token punctuation">(</span><span class="token hvariable">fromParity</span> <span class="token hvariable">digit</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">digit</span><span class="token operator">:</span><span class="token builtin">seq</span><span class="token punctuation">)</span>

<span class="token hvariable">insertMap</span> <span class="token operator">::</span> <span class="token constant">Digit</span> <span class="token operator">-&gt;</span> <span class="token constant">Digit</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Map</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Map</span> <span class="token hvariable">a</span>
<span class="token hvariable">insertMap</span> <span class="token hvariable">key</span> <span class="token hvariable">digit</span> <span class="token hvariable">val</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">val</span> <span class="token operator">\`seq\`</span> <span class="token hvariable">M<span class="token punctuation">.</span>insert</span> <span class="token hvariable">key&#39;</span> <span class="token hvariable">val</span> <span class="token hvariable">m</span>
    <span class="token keyword">where</span> <span class="token hvariable">key&#39;</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">key</span> <span class="token operator">+</span> <span class="token hvariable">digit</span><span class="token punctuation">)</span> <span class="token operator">\`mod\`</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从map中取出一个既存的校验码，一个可以求出该校验码的序列，一个新的输入数字，这个函数将可以求出新的校验码的新序列更新至map。</p><p>这部分内容可能有点不太好消化，看一个例子应该会更明白。我们假设现在要查找数字是 <code>4</code> ，它是序列 <code>[1, 3]</code> 对应的校验码，我们想要添加到map的数字是 <code>8</code> 。<code>4+8</code> ，模10得 <code>2</code> ，那么 <code>2</code> 就是要插入到map中的键。能计算出新校验码 <code>2</code> 的序列就是 <code>[8, 1, 3]</code> ，这个序列就是要插入的映射值。</p><p>[译注： 在实际调用 <code>updateMap</code> 函数的时候， <code>digit</code> 是一个候选数字，key是指&quot;在插入候选数字 <code>new</code> 之前，由这个不完整的&#39;猜测&#39;序列算出的临时校验码&quot;， <code>seq</code> 就是 <code>key</code> 所对应的&quot;不完整的&#39;猜测&#39;序列(指条形码的编码数字序列)&quot;。 <code>updateMap</code> 的实际功能就是将 <code>digit</code> 插入到列表 <code>seq</code> 的最前面，然后由插入的seq再求出一个校验码的临时值。并以这个临时值和插入后的序列分别为键值和映射值，插入到指定的map中。这之中需要注意的地方是在 <code>insertMap</code> 函数中，<code>key&#39;</code> 表示新求出的临时校验码，这个校验码的算法与前文checkDigit的算法并不相同：没有对输入序列进行 <code>mapEveryOther (*3) (reverse ds)</code> 和类似 <code>(10 -)</code> 这样的计算。实际上，这两个操作只是被推迟了，并且由于校验码只有一位数，因此校验码的值与&quot;(10 - 校验码)&quot;的值也是一一对应的(即&quot;单射&quot;)，所以map中保存这个没有经过 <code>(10 - )</code> 操作的键值也是没有问题的，只要在需要提取真正的校验码时用10减去这个键值就可以了，除了这些之外，其计算方法与 <code>checkDigit</code> 函数中的方法是等价的。]</p><p>对候选数字序列中的每一个数字，我们都会通过当前数字和之前的map生成一个新的答案map。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">useDigit</span> <span class="token operator">::</span> <span class="token constant">ParityMap</span> <span class="token operator">-&gt;</span> <span class="token constant">ParityMap</span> <span class="token operator">-&gt;</span> <span class="token constant">Parity</span> <span class="token constant">Digit</span> <span class="token operator">-&gt;</span> <span class="token constant">ParityMap</span>
<span class="token hvariable">useDigit</span> <span class="token hvariable">old</span> <span class="token hvariable">new</span> <span class="token hvariable">digit</span> <span class="token operator">=</span>
    <span class="token hvariable">new</span> <span class="token operator">\`M.union\`</span> <span class="token hvariable">M<span class="token punctuation">.</span>foldWithKey</span> <span class="token punctuation">(</span><span class="token hvariable">updateMap</span> <span class="token hvariable">digit</span><span class="token punctuation">)</span> <span class="token hvariable">M<span class="token punctuation">.</span>empty</span> <span class="token hvariable">old</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们再通过一个例子演示这段代码的实际功能。这次，我们用ghci交互演示。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> single n <span class="token operator">=</span> M.singleton n <span class="token punctuation">[</span>Even n<span class="token punctuation">]</span> :: ParityMap
ghci<span class="token operator">&gt;</span> useDigit <span class="token punctuation">(</span>single <span class="token number">1</span><span class="token punctuation">)</span> M.empty <span class="token punctuation">(</span>Even <span class="token number">1</span><span class="token punctuation">)</span>
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span>,<span class="token punctuation">[</span>Even <span class="token number">1</span>,Even <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> useDigit <span class="token punctuation">(</span>single <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>single <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Even <span class="token number">2</span><span class="token punctuation">)</span>
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span>,<span class="token punctuation">[</span>Even <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3</span>,<span class="token punctuation">[</span>Even <span class="token number">2</span>,Even <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[译注：这个函数的参数中， <code>old</code> 代表上一候选数字应用此函数时产生的map，而 <code>old</code> 代表&quot;条形码中的上一个数字位置&quot;通过不断折叠应用此函数所产生的map，<code>digit</code> 表示当前考察的候选数字。这个函数的实际作用是在某个候选数字列表中遍历的过程中，当前考察的这个候选数字插入到给定map的每个映射值的最前方，并求得新的临时校验码，然后将这个临时校验码和插入后的序列作为键值对插入到map中，并与前一候选数字应用此函数的结果map做&quot;并集&quot;操作( <code>M.union</code> )，由于候选数字序列是按照匹配程度降序排列的，因此如果当前序列中的键值与前一候选数字产生的某个键值发生冲突，那么它就会被 <code>M.Union</code> 的&quot;左偏&quot;性质覆盖掉，而保留前一候选数字所产生的新序列。]</p><p>传给 <code>useDigits</code> 函数的新答案map(即参数 <code>new</code> 对应的map)最开始是空的。其值将通过在输入数字的序列上折叠 <code>useDigits</code> 函数来填充。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">incorporateDigits</span> <span class="token operator">::</span> <span class="token constant">ParityMap</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token constant">Digit</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">ParityMap</span>
<span class="token hvariable">incorporateDigits</span> <span class="token hvariable">old</span> <span class="token hvariable">digits</span> <span class="token operator">=</span> <span class="token builtin">foldl</span>&#39; <span class="token punctuation">(</span><span class="token hvariable">useDigit</span> <span class="token hvariable">old</span><span class="token punctuation">)</span> <span class="token hvariable">M<span class="token punctuation">.</span>empty</span> <span class="token hvariable">digits</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>incooperateDigit</code> 函数可以用旧的答案map生成完整的新的答案map。</p><pre><code>ghci&gt; incorporateDigits (M.singleton 0 []) [Even 1, Even 5]
fromList [(1,[Even 1]),(5,[Even 5])]
</code></pre><p>[译注： <code>incorporate</code> 函数中，参数 <code>old</code> 代表条码中上一个位置的数字组成的可能的数字逆序序列以及他们对应的临时校验码组成的map，参数digits表示该位置上的候选数字列表。]</p><p>最终，我们必须构造完整的答案map。我们先创建一个空的map，然后在条形码的数字序列上依次折叠。我们为每个位置生成一个包含截止到该位置的猜测序列的 <code>new</code> map。这个map将作为下一位置上的折叠过程的 <code>old</code> map出现。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">finalDigits</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token constant">Digit</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">ParityMap</span>
<span class="token hvariable">finalDigits</span> <span class="token operator">=</span> <span class="token builtin">foldl</span>&#39; <span class="token hvariable">incorporateDigits</span> <span class="token punctuation">(</span><span class="token hvariable">M<span class="token punctuation">.</span>singleton</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token operator">.</span> <span class="token hvariable">mapEveryOther</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(回想一下，我们在&quot;EAN-13编码&quot;一节中定义checkDigit函数的时候，要求计算校验码的之前，数字要每隔一位乘以3后再进行下一步处理。)</p><p><code>finalDigits</code> 函数接受的列表有多少个元素呢？我们还不知道数字序列的第一个数字是什么，所以很明显第一位数字不能计入，并且在调用<code>finalDigits</code> 时校验码还只是猜测值，我们也不该把它计入。所以这个输入列表应该有11个元素。</p><p>从 <code>finalDigits</code> 返回后，答案map必然还不完整，因为我们还没有确定首位数字是什么。</p><h3 id="completing-the-solution-map-with-the-first-digit" tabindex="-1"><a class="header-anchor" href="#completing-the-solution-map-with-the-first-digit"><span>用首位数字补全答案map</span></a></h3><p>我们还没说过如何从左侧分组的奇偶编码类型中提取出首位数字。其实只要直接重用我们前面编写的代码就可以了。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">firstDigit</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Digit</span>
<span class="token hvariable">firstDigit</span> <span class="token operator">=</span> <span class="token builtin">snd</span>
           <span class="token operator">.</span> <span class="token builtin">head</span>
           <span class="token operator">.</span> <span class="token hvariable">bestScores</span> <span class="token hvariable">paritySRL</span>
           <span class="token operator">.</span> <span class="token hvariable">runLengths</span>
           <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token hvariable">parityBit</span>
           <span class="token operator">.</span> <span class="token builtin">take</span> <span class="token number">6</span>
  <span class="token keyword">where</span> <span class="token hvariable">parityBit</span> <span class="token punctuation">(</span><span class="token constant">Even</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Zero</span>
        <span class="token hvariable">parityBit</span> <span class="token punctuation">(</span><span class="token constant">Odd</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">One</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在这个不完整的答案map中的每个元素都包含一个由数字和编码奇偶性信息组成的逆序的列表。接下来的任务就是通过计算每个序列的首位数字来创建一个完整的答案map，并通过它创建最终的答案map(即键值都是正确的校验码，映射值都是完整的12位正序列表的map)。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">addFirstDigit</span> <span class="token operator">::</span> <span class="token constant">ParityMap</span> <span class="token operator">-&gt;</span> <span class="token constant">DigitMap</span>
<span class="token hvariable">addFirstDigit</span> <span class="token operator">=</span> <span class="token hvariable">M<span class="token punctuation">.</span>foldWithKey</span> <span class="token hvariable">updateFirst</span> <span class="token hvariable">M<span class="token punctuation">.</span>empty</span>

<span class="token hvariable">updateFirst</span> <span class="token operator">::</span> <span class="token constant">Digit</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token constant">Digit</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">DigitMap</span> <span class="token operator">-&gt;</span> <span class="token constant">DigitMap</span>
<span class="token hvariable">updateFirst</span> <span class="token hvariable">key</span> <span class="token builtin">seq</span> <span class="token operator">=</span> <span class="token hvariable">insertMap</span> <span class="token hvariable">key</span> <span class="token hvariable">digit</span> <span class="token punctuation">(</span><span class="token hvariable">digit</span><span class="token operator">:</span><span class="token hvariable">renormalize</span> <span class="token hvariable">qes</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span> <span class="token hvariable">renormalize</span> <span class="token operator">=</span> <span class="token hvariable">mapEveryOther</span> <span class="token punctuation">(</span><span class="token operator">\`div\`</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token hvariable">fromParity</span>
        <span class="token hvariable">digit</span> <span class="token operator">=</span> <span class="token hvariable">firstDigit</span> <span class="token hvariable">qes</span>
        <span class="token hvariable">qes</span> <span class="token operator">=</span> <span class="token builtin">reverse</span> <span class="token builtin">seq</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[译注： <code>mapKeys</code> 将第一个参数指定的函数逐一应用于map中的每个key，并用结果替换掉原key值。]</p><p>如此往复，我们最终消去了Parity类型，并撤销了之前乘以3的操作。最后一步，就是完成校验码的计算。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">buildMap</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token constant">Digit</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">DigitMap</span>
<span class="token hvariable">buildMap</span> <span class="token operator">=</span> <span class="token hvariable">M<span class="token punctuation">.</span>mapKeys</span> <span class="token punctuation">(</span><span class="token hvariable">realCheckDigit</span><span class="token punctuation">)</span>
         <span class="token operator">.</span> <span class="token hvariable">addFirstDigit</span>
         <span class="token operator">.</span> <span class="token hvariable">finalDigits</span>
         	<span class="token keyword">where</span> <span class="token hvariable">realCheckDigit</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">-</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">\`mod\`</span> <span class="token number">10</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="finding-the-correct-sequence" tabindex="-1"><a class="header-anchor" href="#finding-the-correct-sequence"><span>找出正确的序列</span></a></h3><p>我们现在有一个包含了所有可能的校验码与对应序列映射的map。剩下的就是逐一验证我们对校验码的猜测值，检查在答案map中是否存在对应的键值。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">solve</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Parity</span> <span class="token constant">Digit</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Digit</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">solve</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">solve</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">catMaybes</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token hvariable">addCheckDigit</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token hvariable">checkDigits</span>
    <span class="token keyword">where</span> <span class="token hvariable">checkDigits</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token hvariable">fromParity</span> <span class="token punctuation">(</span><span class="token builtin">last</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
          <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">buildMap</span> <span class="token punctuation">(</span><span class="token builtin">init</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
          <span class="token hvariable">addCheckDigit</span> <span class="token hvariable">m</span> <span class="token hvariable">k</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">[</span><span class="token hvariable">k</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">M</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">k</span> <span class="token hvariable">m</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[译注：<code>catMaybes</code> 接受一个 <code>Maybe</code> 类型元素组成的列表，返回一个只由 <code>Just</code> 构造器的参数值构成的列表(即参数列表中的 <code>Nothing</code> 值会被直接忽略)。</p><p>我们用从照片上取下来的那一行来试验，看看能否得到正确的结果。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> listToMaybe <span class="token builtin class-name">.</span> solve <span class="token builtin class-name">.</span> candidateDigits $ input
Just <span class="token punctuation">[</span><span class="token number">9,7</span>,8,0,1,3,2,1,1,4,6,7,7<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>太棒了！这正是照片中编码的数字序列。</p><h2 id="working-with-row-data" tabindex="-1"><a class="header-anchor" href="#working-with-row-data"><span>处理行数据</span></a></h2><p>我们反复强调&quot;处理的是图像中的一行&quot;。下面是&quot;处理一行&quot;的具体的做法</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">withRow</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Pixmap</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">RunLength</span> <span class="token constant">Bit</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">withRow</span> <span class="token hvariable">n</span> <span class="token hvariable">greymap</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">runLength</span> <span class="token operator">.</span> <span class="token hvariable">elems</span> <span class="token operator">$</span> <span class="token hvariable">posterized</span>
    <span class="token keyword">where</span> <span class="token hvariable">posterized</span> <span class="token operator">=</span> <span class="token hvariable">threshold</span> <span class="token number">0.4</span> <span class="token operator">.</span> <span class="token builtin">fmap</span> <span class="token hvariable">luminance</span> <span class="token operator">.</span> <span class="token hvariable">row</span> <span class="token hvariable">n</span> <span class="token operator">$</span> <span class="token hvariable">greymap</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>withRow</code> 函数接受图像中的一行，将该行转换为黑白图像，然后对游程编码后的行数据应用指定函数。该函数通过 <code>row</code> 函数来获取行数据。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token hvariable">row</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ix</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Ix</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token constant">Array</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">-&gt;</span> <span class="token constant">Array</span> <span class="token hvariable">a</span> <span class="token hvariable">c</span>
<span class="token hvariable">row</span> <span class="token hvariable">j</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">ixmap</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span><span class="token hvariable">u</span><span class="token punctuation">)</span> <span class="token hvariable">project</span> <span class="token hvariable">a</span>
    <span class="token keyword">where</span> <span class="token hvariable">project</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">i</span><span class="token punctuation">,</span><span class="token hvariable">j</span><span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span><span class="token hvariable">_</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">u</span><span class="token punctuation">,</span><span class="token hvariable">_</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">bounds</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数需要稍作解释。我们知道 <code>fmap</code> 用来变换数组中的元素值，而此处的 <code>ixmap</code> 则用来变换数组中的索引值。这个强大的函数使我们可以任意地从数组取出&quot;切片&quot;。</p><p><code>ixmap</code> 的第一个参数是新数组的边界。边界可以与原数组有不同的维。比方说，我们可以从一个二维数组中取出一个一维数组表示的行。</p><p>[译注：此处所说的&quot;有不同的维&quot;包括维数不同、&quot;维的类型&quot;不同、以及两种都有的情况。]</p><p>第二个参数是一个映射函数。其参数为新数组的索引值，返回值为原数组的索引值。映射索引的值接下来会变为新数组原索引值处的值。例如，如果我们把2传给映射函数，它返回(2, 2)。这表示新数组中索引值为2的元素值将取自源数组中索引值为(2, 2)的元素。</p><h2 id="pulling-it-all-together" tabindex="-1"><a class="header-anchor" href="#pulling-it-all-together"><span>最终装配</span></a></h2><p><code>candidateDigits</code> 只要不是从条形码序列的起始处调用,就会返回一个空结果。使用下面的函数，我们可以轻松的扫描一整行，并得到匹配结果。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">findMatch</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Run</span><span class="token punctuation">,</span> <span class="token constant">Bit</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Digit</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">findMatch</span> <span class="token operator">=</span> <span class="token hvariable">listToMaybe</span>
          <span class="token operator">.</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token builtin">not</span> <span class="token operator">.</span> <span class="token builtin">null</span><span class="token punctuation">)</span>
          <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token hvariable">solve</span> <span class="token operator">.</span> <span class="token hvariable">candidateDigits</span><span class="token punctuation">)</span>
          <span class="token operator">.</span> <span class="token hvariable">tails</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>..FIXME: 应该是指的candidateDigits的惰性求值</p><p>这里，我们利用了惰性求值的优点。 <code>tails</code> 前面的map函数只会在产生非空列表的时候参会真正求值。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch12/Barcode.hs</span>
<span class="token hvariable">findEAN13</span> <span class="token operator">::</span> <span class="token constant">Pixmap</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Digit</span><span class="token punctuation">]</span>
<span class="token hvariable">findEAN13</span> <span class="token hvariable">pixmap</span> <span class="token operator">=</span> <span class="token hvariable">withRow</span> <span class="token hvariable">center</span> <span class="token hvariable">pixmap</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token hvariable">findMatch</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">maxX</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">bounds</span> <span class="token hvariable">pixmap</span>
        <span class="token hvariable">center</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">maxX</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">\`div\`</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，我们做了一个简单的封装，用来打印从命令行传入的netpbm图像文件中提取的条形码。</p><p>注意到在我们本章定义的超过30个函数中，只有 <code>main</code> 是涉及 <code>IO</code> 的。</p><h2 id="a-few-comments-on-development-style" tabindex="-1"><a class="header-anchor" href="#a-few-comments-on-development-style"><span>关于开发方式的一些意见</span></a></h2><p>你可能发现了，本章中给出的许多函数都是些放在源码顶部的小函数。这并非偶然。正如我们早些时候提到过的，当我们开始本章的撰写时，我们并不知道要怎样构造这个解决方案。</p><p>我们还经常需要找到问题域来明确解决问题的大方向。为了这个目的，我们耗费了大量的时间摆弄 <strong>ghci</strong> ，对各种函数做小测试。这需要函数定义在源文件的最上方，否则 <strong>ghci</strong> 就找不到它们了。</p><p>一旦我们对这些函数的功能和行为满意了，我们就开始将它们黏合在一起，继续通过 <strong>ghci</strong> 观察执行的结果。这就是添加类型签名的好处------如果某些函数没法组合到一起，我们可以通过类型签名尽早发现。</p><p>最后，我们有了一大堆短小的顶层函数，每个函数都有类型签名。这可能并不是最紧凑的形式；在搞定这些函数的逻辑之后，我们其实可以将其中很多函数放到 <code>let</code> 或者 <code>where</code> 块中。然而，我们发现这种更大的纵向空间，短小的函数体，以及类型签名，都使代码变得更易读了，所以我们也不再考虑拿这些函数玩儿什么&quot;golfing&quot;[^2] 了。</p><p>使用强静态类型的语言工作不会影响增量的流式的问题解决模式。我们发现这种&quot;先编写函数&quot;，再&quot;用*<em>ghci</em>* 测试，获取有用信息&quot;的模式非常快速；这为我们快速编写优质代码提供了巨大帮助。</p><p>[^1]: 该公式在ITU-R Recommendation 601中首次提及。 [^2]: 这个golfing的说法来源于Perl程序员们玩儿的一个游戏，即程序员尝试为某种目的编写最短的代码，敲键盘次数最少的获胜。</p>`,181),r=[l,c,i];function u(k,d){return p(),t("div",null,r)}const h=e(o,[["render",u],["__file","12-2.html.vue"]]),m=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/12-2.html","title":"","lang":"zh-CN","frontmatter":{"description":"寻找匹配的数字 我们首先要面对的问题，是如何在某个 可能 编码了数字的位置把这个数字找出来。在此，我们要做一些简单的假设。第一个假设是我们处理的对象是图像中的单一行，第二个假设是我们明确知道条形码左边缘位置，这个位置即条形码的起始位置。 ::: {#run-length-encoding} ::: 游程编码 我们如何解决线条宽度的问题呢。答案就是对图像...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/12-2.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:description","content":"寻找匹配的数字 我们首先要面对的问题，是如何在某个 可能 编码了数字的位置把这个数字找出来。在此，我们要做一些简单的假设。第一个假设是我们处理的对象是图像中的单一行，第二个假设是我们明确知道条形码左边缘位置，这个位置即条形码的起始位置。 ::: {#run-length-encoding} ::: 游程编码 我们如何解决线条宽度的问题呢。答案就是对图像..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-25T04:39:03.000Z"}],["meta",{"property":"article:author","content":"hahg"}],["meta",{"property":"article:modified_time","content":"2024-02-25T04:39:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-25T04:39:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hahg\\"}]}"]]},"headers":[{"level":2,"title":"寻找匹配的数字","slug":"finding-matching-digits","link":"#finding-matching-digits","children":[{"level":3,"title":"游程编码","slug":"游程编码","link":"#游程编码","children":[]},{"level":3,"title":"缩放游程，查找相近的匹配","slug":"缩放游程-查找相近的匹配","link":"#缩放游程-查找相近的匹配","children":[]},{"level":3,"title":"列表推导式","slug":"列表推导式","link":"#列表推导式","children":[]},{"level":3,"title":"记录匹配数字的奇偶性","slug":"记录匹配数字的奇偶性","link":"#记录匹配数字的奇偶性","children":[]},{"level":3,"title":"键盘惰性","slug":"键盘惰性","link":"#键盘惰性","children":[]},{"level":3,"title":"列表分块","slug":"chunking-a-list","link":"#chunking-a-list","children":[]},{"level":3,"title":"生成候选数字列表","slug":"generating-a-list-of-candidate-digits","link":"#generating-a-list-of-candidate-digits","children":[]}]},{"level":2,"title":"没有数组和散列表的日子","slug":"life-without-arrays-or-hash-tables","link":"#life-without-arrays-or-hash-tables","children":[{"level":3,"title":"答案的森林","slug":"答案的森林","link":"#答案的森林","children":[]},{"level":3,"title":"map简介","slug":"map简介","link":"#map简介","children":[]},{"level":3,"title":"类型约束","slug":"type-constraints","link":"#type-constraints","children":[]},{"level":3,"title":"部分应用时的尴尬","slug":"部分应用时的尴尬","link":"#部分应用时的尴尬","children":[]},{"level":3,"title":"map API入门","slug":"map-api入门","link":"#map-api入门","children":[]},{"level":3,"title":"延伸阅读","slug":"further-reading","link":"#further-reading","children":[]}]},{"level":2,"title":"从成堆的数字中找出答案","slug":"从成堆的数字中找出答案","link":"#从成堆的数字中找出答案","children":[{"level":3,"title":"批量求解校验码","slug":"批量求解校验码","link":"#批量求解校验码","children":[]},{"level":3,"title":"用首位数字补全答案map","slug":"completing-the-solution-map-with-the-first-digit","link":"#completing-the-solution-map-with-the-first-digit","children":[]},{"level":3,"title":"找出正确的序列","slug":"finding-the-correct-sequence","link":"#finding-the-correct-sequence","children":[]}]},{"level":2,"title":"处理行数据","slug":"working-with-row-data","link":"#working-with-row-data","children":[]},{"level":2,"title":"最终装配","slug":"pulling-it-all-together","link":"#pulling-it-all-together","children":[]},{"level":2,"title":"关于开发方式的一些意见","slug":"a-few-comments-on-development-style","link":"#a-few-comments-on-development-style","children":[]}],"git":{"createdTime":1708835943000,"updatedTime":1708835943000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":33.04,"words":9911},"filePathRelative":"学习/Haskell中文文档/12-2.md","localizedDate":"2024年2月25日","excerpt":"<h2>寻找匹配的数字</h2>\\n<p>我们首先要面对的问题，是如何在某个 <em>可能</em> 编码了数字的位置把这个数字找出来。在此，我们要做一些简单的假设。第一个假设是我们处理的对象是图像中的单一行，第二个假设是我们明确知道条形码左边缘位置，这个位置即条形码的起始位置。</p>\\n<p>::: {#run-length-encoding}\\n:::</p>\\n<h3>游程编码</h3>\\n<p>我们如何解决线条宽度的问题呢。答案就是对图像数据进行游程编码(run length encode)。</p>\\n<div class=\\"language-haskell\\" data-ext=\\"haskell\\" data-title=\\"haskell\\"><pre class=\\"language-haskell\\"><code><span class=\\"token comment\\">-- file: ch12/Barcode.hs</span>\\n<span class=\\"token keyword\\">type</span> <span class=\\"token constant\\">Run</span> <span class=\\"token operator\\">=</span> <span class=\\"token constant\\">Int</span>\\n<span class=\\"token keyword\\">type</span> <span class=\\"token constant\\">RunLength</span> <span class=\\"token hvariable\\">a</span> <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">(</span><span class=\\"token constant\\">Run</span><span class=\\"token punctuation\\">,</span> <span class=\\"token hvariable\\">a</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">]</span>\\n\\n<span class=\\"token hvariable\\">runLength</span> <span class=\\"token operator\\">::</span> <span class=\\"token constant\\">Eq</span> <span class=\\"token hvariable\\">a</span> <span class=\\"token operator\\">=&gt;</span> <span class=\\"token punctuation\\">[</span><span class=\\"token hvariable\\">a</span><span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">-&gt;</span> <span class=\\"token constant\\">RunLength</span> <span class=\\"token hvariable\\">a</span>\\n<span class=\\"token hvariable\\">runLength</span> <span class=\\"token operator\\">=</span> <span class=\\"token builtin\\">map</span> <span class=\\"token hvariable\\">rle</span> <span class=\\"token operator\\">.</span> <span class=\\"token builtin\\">group</span>\\n    <span class=\\"token keyword\\">where</span> <span class=\\"token hvariable\\">rle</span> <span class=\\"token hvariable\\">xs</span> <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">(</span><span class=\\"token builtin\\">length</span> <span class=\\"token hvariable\\">xs</span><span class=\\"token punctuation\\">,</span> <span class=\\"token builtin\\">head</span> <span class=\\"token hvariable\\">xs</span><span class=\\"token punctuation\\">)</span>\\n</code></pre></div>","autoDesc":true}');export{h as comp,m as data};
