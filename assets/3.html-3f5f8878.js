const e=JSON.parse('{"key":"v-8669350a","path":"/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/3.html","title":"第 3 章：定义类型并简化函数","lang":"zh-CN","frontmatter":{"description":"第 3 章：定义类型并简化函数 定义新的数据类型 尽管列表和元组都非常有用，但是，定义新的数据类型也是一种常见的需求，这种能力使得我们可以为程序中的值添加结构。 而且比起使用元组，对一簇相关的值赋予一个名字和一个独一无二的类型显得更有用一些。 定义新的数据类型也提升了代码的安全性：Haskell 不会允许我们混用两个结构相同但类型不同的值。 本章将以一个在线书店为例子，展示如何去进行类型定义。 使用 data 关键字可以定义新的数据类型： -- file: ch03/BookStore.hs data BookInfo = Book Int String [String] deriving (Show)","head":[["meta",{"property":"og:url","content":"https://hahg2000.github.io/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/3.html"}],["meta",{"property":"og:title","content":"第 3 章：定义类型并简化函数"}],["meta",{"property":"og:description","content":"第 3 章：定义类型并简化函数 定义新的数据类型 尽管列表和元组都非常有用，但是，定义新的数据类型也是一种常见的需求，这种能力使得我们可以为程序中的值添加结构。 而且比起使用元组，对一簇相关的值赋予一个名字和一个独一无二的类型显得更有用一些。 定义新的数据类型也提升了代码的安全性：Haskell 不会允许我们混用两个结构相同但类型不同的值。 本章将以一个在线书店为例子，展示如何去进行类型定义。 使用 data 关键字可以定义新的数据类型： -- file: ch03/BookStore.hs data BookInfo = Book Int String [String] deriving (Show)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-22T03:39:13.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-22T03:39:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第 3 章：定义类型并简化函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-22T03:39:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"定义新的数据类型","slug":"定义新的数据类型","link":"#定义新的数据类型","children":[{"level":3,"title":"类型构造器和值构造器的命名","slug":"类型构造器和值构造器的命名","link":"#类型构造器和值构造器的命名","children":[]}]},{"level":2,"title":"类型别名","slug":"类型别名","link":"#类型别名","children":[]},{"level":2,"title":"代数数据类型","slug":"代数数据类型","link":"#代数数据类型","children":[{"level":3,"title":"什么情况下该用元组，而什么情况下又该用代数数据类型？","slug":"什么情况下该用元组-而什么情况下又该用代数数据类型","link":"#什么情况下该用元组-而什么情况下又该用代数数据类型","children":[]},{"level":3,"title":"其他语言里类似代数数据类型的东西","slug":"其他语言里类似代数数据类型的东西","link":"#其他语言里类似代数数据类型的东西","children":[]}]},{"level":2,"title":"模式匹配","slug":"模式匹配","link":"#模式匹配","children":[{"level":3,"title":"组成和解构","slug":"组成和解构","link":"#组成和解构","children":[]},{"level":3,"title":"更进一步","slug":"更进一步","link":"#更进一步","children":[]},{"level":3,"title":"模式匹配中的变量名命名","slug":"模式匹配中的变量名命名","link":"#模式匹配中的变量名命名","children":[]},{"level":3,"title":"通配符模式匹配","slug":"通配符模式匹配","link":"#通配符模式匹配","children":[]},{"level":3,"title":"穷举匹配模式和通配符","slug":"穷举匹配模式和通配符","link":"#穷举匹配模式和通配符","children":[]}]},{"level":2,"title":"记录语法","slug":"记录语法","link":"#记录语法","children":[]},{"level":2,"title":"参数化类型","slug":"参数化类型","link":"#参数化类型","children":[]},{"level":2,"title":"递归类型","slug":"递归类型","link":"#递归类型","children":[{"level":3,"title":"练习","slug":"练习","link":"#练习","children":[]}]},{"level":2,"title":"报告错误","slug":"报告错误","link":"#报告错误","children":[{"level":3,"title":"让过程更可控的方法","slug":"让过程更可控的方法","link":"#让过程更可控的方法","children":[]}]},{"level":2,"title":"引入局部变量","slug":"引入局部变量","link":"#引入局部变量","children":[{"level":3,"title":"屏蔽","slug":"屏蔽","link":"#屏蔽","children":[]},{"level":3,"title":"where 从句","slug":"where-从句","link":"#where-从句","children":[]},{"level":3,"title":"局部函数与全局变量","slug":"局部函数与全局变量","link":"#局部函数与全局变量","children":[]}]},{"level":2,"title":"表达式里的缩进规则和空白字符","slug":"表达式里的缩进规则和空白字符","link":"#表达式里的缩进规则和空白字符","children":[{"level":3,"title":"对制表符和空格说两句","slug":"对制表符和空格说两句","link":"#对制表符和空格说两句","children":[]},{"level":3,"title":"缩进规则并不是必需","slug":"the-offside-rule-is-not-mandatory","link":"#the-offside-rule-is-not-mandatory","children":[]}]},{"level":2,"title":"Case 表达式","slug":"case-表达式","link":"#case-表达式","children":[]},{"level":2,"title":"新手在使用模式时常见的问题","slug":"新手在使用模式时常见的问题","link":"#新手在使用模式时常见的问题","children":[{"level":3,"title":"错误地对变量进行匹配","slug":"错误地对变量进行匹配","link":"#错误地对变量进行匹配","children":[]},{"level":3,"title":"进行了错误的相等比较","slug":"进行了错误的相等比较","link":"#进行了错误的相等比较","children":[]}]},{"level":2,"title":"使用守卫实现条件求值","slug":"使用守卫实现条件求值","link":"#使用守卫实现条件求值","children":[]},{"level":2,"title":"练习","slug":"练习-1","link":"#练习-1","children":[]}],"git":{"createdTime":1689997153000,"updatedTime":1689997153000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":47.26,"words":14177},"filePathRelative":"学习/Haskell中文文档/3.md","localizedDate":"2023年7月22日","excerpt":"<h1> 第 3 章：定义类型并简化函数</h1>\\n<h2> 定义新的数据类型</h2>\\n<p>尽管列表和元组都非常有用，但是，定义新的数据类型也是一种常见的需求，这种能力使得我们可以为程序中的值添加结构。</p>\\n<p>而且比起使用元组，对一簇相关的值赋予一个名字和一个独一无二的类型显得更有用一些。</p>\\n<p>定义新的数据类型也提升了代码的安全性：Haskell\\n不会允许我们混用两个结构相同但类型不同的值。</p>\\n<p>本章将以一个在线书店为例子，展示如何去进行类型定义。</p>\\n<p>使用 <code>data</code> 关键字可以定义新的数据类型：</p>\\n<pre><code>-- file: ch03/BookStore.hs\\ndata BookInfo = Book Int String [String]\\n                deriving (Show)\\n</code></pre>","autoDesc":true}');export{e as data};
