const e=JSON.parse('{"key":"v-0145782c","path":"/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9FJS/ES6-%E4%B8%AD.html","title":"ES6-中","lang":"zh-CN","frontmatter":{"description":"ES6-中 一、Promise 1.1 简介 Promise 是异步编程的一种解决方案，其解决了回调地狱问题。 回调地狱（Callback Hell）指的是回调函数里面又套了一层回调函数，使得代码可读性很差，就像下图所示。 所谓 Promise，简单说就是 一个容器，里面保存着 某个未来才会结束 的事件（通常是一个异步操作）的结果。有了 Promise 对象，就可以 将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。","head":[["meta",{"property":"og:url","content":"https://hahg2000.github.io/%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%94%9FJS/ES6-%E4%B8%AD.html"}],["meta",{"property":"og:title","content":"ES6-中"}],["meta",{"property":"og:description","content":"ES6-中 一、Promise 1.1 简介 Promise 是异步编程的一种解决方案，其解决了回调地狱问题。 回调地狱（Callback Hell）指的是回调函数里面又套了一层回调函数，使得代码可读性很差，就像下图所示。 所谓 Promise，简单说就是 一个容器，里面保存着 某个未来才会结束 的事件（通常是一个异步操作）的结果。有了 Promise 对象，就可以 将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-12T04:21:01.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-12T04:21:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ES6-中\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-12T04:21:01.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"一、Promise","slug":"一、promise","link":"#一、promise","children":[{"level":3,"title":"1.1 简介","slug":"_1-1-简介","link":"#_1-1-简介","children":[]},{"level":3,"title":"1.2 基本用法","slug":"_1-2-基本用法","link":"#_1-2-基本用法","children":[]},{"level":3,"title":"1.3 执行时机","slug":"_1-3-执行时机","link":"#_1-3-执行时机","children":[]},{"level":3,"title":"1.4 使用场景","slug":"_1-4-使用场景","link":"#_1-4-使用场景","children":[]},{"level":3,"title":"1.5 特殊的用法","slug":"_1-5-特殊的用法","link":"#_1-5-特殊的用法","children":[]},{"level":3,"title":"1.6 then方法","slug":"_1-6-then方法","link":"#_1-6-then方法","children":[]},{"level":3,"title":"1.7 catch方法","slug":"_1-7-catch方法","link":"#_1-7-catch方法","children":[]},{"level":3,"title":"1.8 finally方法","slug":"_1-8-finally方法","link":"#_1-8-finally方法","children":[]},{"level":3,"title":"1.9 all方法","slug":"_1-9-all方法","link":"#_1-9-all方法","children":[]},{"level":3,"title":"1.10 any方法","slug":"_1-10-any方法","link":"#_1-10-any方法","children":[]},{"level":3,"title":"1.11 race方法","slug":"_1-11-race方法","link":"#_1-11-race方法","children":[]},{"level":3,"title":"1.12 resolve方法","slug":"_1-12-resolve方法","link":"#_1-12-resolve方法","children":[]}]},{"level":2,"title":"二、Symbol","slug":"二、symbol","link":"#二、symbol","children":[{"level":3,"title":"2.1 简介","slug":"_2-1-简介","link":"#_2-1-简介","children":[]},{"level":3,"title":"2.2 基本用法","slug":"_2-2-基本用法","link":"#_2-2-基本用法","children":[]},{"level":3,"title":"2.3 description","slug":"_2-3-description","link":"#_2-3-description","children":[]},{"level":3,"title":"2.4 作为属性名","slug":"_2-4-作为属性名","link":"#_2-4-作为属性名","children":[]},{"level":3,"title":"2.5 消除魔术字符串","slug":"_2-5-消除魔术字符串","link":"#_2-5-消除魔术字符串","children":[]},{"level":3,"title":"2.6 属性名的遍历","slug":"_2-6-属性名的遍历","link":"#_2-6-属性名的遍历","children":[]},{"level":3,"title":"2.7 for方法","slug":"_2-7-for方法","link":"#_2-7-for方法","children":[]}]}],"git":{"createdTime":1678594861000,"updatedTime":1678594861000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":24.22,"words":7267},"filePathRelative":"学习/前端/原生JS/ES6-中.md","localizedDate":"2023年3月12日","excerpt":"<h1> ES6-中</h1>\\n<h2> 一、Promise</h2>\\n<h3> 1.1 简介</h3>\\n<p>Promise 是异步编程的一种解决方案，其解决了回调地狱问题。</p>\\n<p>回调地狱（Callback Hell）指的是回调函数里面又套了一层回调函数，使得代码可读性很差，就像下图所示。</p>\\n<img src=\\"https://raw.githubusercontent.com/hahg2000/picture/Senior-JS/回调地狱示例.png\\" style=\\"zoom:50%;\\">\\n<p>所谓 <code>Promise</code>，简单说就是 <strong>一个容器</strong>，里面保存着 <strong>某个未来才会结束</strong> 的事件（通常是一个异步操作）的结果。有了 <code>Promise</code> 对象，就可以 <strong>将异步操作以同步操作的流程表达出来</strong>，避免了层层嵌套的回调函数。</p>","autoDesc":true}');export{e as data};
