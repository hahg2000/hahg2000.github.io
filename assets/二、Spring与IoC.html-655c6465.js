const e=JSON.parse('{"key":"v-7682dfb0","path":"/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/SSM%E6%A1%86%E6%9E%B6/Spring4/%E4%BA%8C%E3%80%81Spring%E4%B8%8EIoC.html","title":"二、Spring与IoC","lang":"zh-CN","frontmatter":{"description":"二、Spring与IoC ​\\t控制反转（IOC，Inversion of Control），是一个概念，是一种思想。 ​\\t指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。 ​\\tIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。 依赖查找：Dependency Lookup，DL，容器提供回调接口和上下文环境给组件，程序代码则 需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。 依赖注入：Dependency Injection，DI，程序代码不做定位查询，这些工作由容器自行完成。","head":[["meta",{"property":"og:url","content":"https://hahg2000.github.io/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/SSM%E6%A1%86%E6%9E%B6/Spring4/%E4%BA%8C%E3%80%81Spring%E4%B8%8EIoC.html"}],["meta",{"property":"og:title","content":"二、Spring与IoC"}],["meta",{"property":"og:description","content":"二、Spring与IoC ​\\t控制反转（IOC，Inversion of Control），是一个概念，是一种思想。 ​\\t指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。 ​\\tIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。 依赖查找：Dependency Lookup，DL，容器提供回调接口和上下文环境给组件，程序代码则 需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。 依赖注入：Dependency Injection，DI，程序代码不做定位查询，这些工作由容器自行完成。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-12T04:21:01.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-12T04:21:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二、Spring与IoC\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-12T04:21:01.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"2.1 Spring 程序开发","slug":"_2-1-spring-程序开发","link":"#_2-1-spring-程序开发","children":[{"level":3,"title":"2.1.1 导入Jar包","slug":"_2-1-1-导入jar包","link":"#_2-1-1-导入jar包","children":[]},{"level":3,"title":"2.1.2 定义接口与实现类","slug":"_2-1-2-定义接口与实现类","link":"#_2-1-2-定义接口与实现类","children":[]},{"level":3,"title":"2.1.3 创建 Spring 配置文件","slug":"_2-1-3-创建-spring-配置文件","link":"#_2-1-3-创建-spring-配置文件","children":[]},{"level":3,"title":"2.1.4 定义测试类","slug":"_2-1-4-定义测试类","link":"#_2-1-4-定义测试类","children":[]},{"level":3,"title":"2.1.5 对象的创建","slug":"_2-1-5-对象的创建","link":"#_2-1-5-对象的创建","children":[]}]},{"level":2,"title":"2.2 Bean 的装配","slug":"_2-2-bean-的装配","link":"#_2-2-bean-的装配","children":[{"level":3,"title":"2.2.1 默认装配方式","slug":"_2-2-1-默认装配方式","link":"#_2-2-1-默认装配方式","children":[]},{"level":3,"title":"2.2.2 动态工厂 Bean","slug":"_2-2-2-动态工厂-bean","link":"#_2-2-2-动态工厂-bean","children":[]},{"level":3,"title":"2.2.3 静态工厂 Bean","slug":"_2-2-3-静态工厂-bean","link":"#_2-2-3-静态工厂-bean","children":[]},{"level":3,"title":"2.2.4 容器中 Bean 的作用域","slug":"_2-2-4-容器中-bean-的作用域","link":"#_2-2-4-容器中-bean-的作用域","children":[]},{"level":3,"title":"2.2.5 Bean 后处理器","slug":"_2-2-5-bean-后处理器","link":"#_2-2-5-bean-后处理器","children":[]},{"level":3,"title":"2.2.6 定制 Bean 的生命始末","slug":"_2-2-6-定制-bean-的生命始末","link":"#_2-2-6-定制-bean-的生命始末","children":[]},{"level":3,"title":"2.2.7 Bean 的生命周期","slug":"_2-2-7-bean-的生命周期","link":"#_2-2-7-bean-的生命周期","children":[]},{"level":3,"title":"2.2.8 标签的 id 属性与 name 属性","slug":"_2-2-8-标签的-id-属性与-name-属性","link":"#_2-2-8-标签的-id-属性与-name-属性","children":[]}]},{"level":2,"title":"2.3 基于 XML 的 DI","slug":"_2-3-基于-xml-的-di","link":"#_2-3-基于-xml-的-di","children":[{"level":3,"title":"2.3.1 注入分类","slug":"_2-3-1-注入分类","link":"#_2-3-1-注入分类","children":[]},{"level":3,"title":"2.3.2 命名空间注入（了解）","slug":"_2-3-2-命名空间注入-了解","link":"#_2-3-2-命名空间注入-了解","children":[]},{"level":3,"title":"2.3.3 集合属性注入","slug":"_2-3-3-集合属性注入","link":"#_2-3-3-集合属性注入","children":[]},{"level":3,"title":"2.3.4 对于域属性的自动注入","slug":"_2-3-4-对于域属性的自动注入","link":"#_2-3-4-对于域属性的自动注入","children":[]},{"level":3,"title":"2.3.5 使用 SPEL 注入","slug":"_2-3-5-使用-spel-注入","link":"#_2-3-5-使用-spel-注入","children":[]},{"level":3,"title":"2.3.6 使用内部 Bean 注入","slug":"_2-3-6-使用内部-bean-注入","link":"#_2-3-6-使用内部-bean-注入","children":[]},{"level":3,"title":"2.3.7 使用同类抽象 Bean 注入","slug":"_2-3-7-使用同类抽象-bean-注入","link":"#_2-3-7-使用同类抽象-bean-注入","children":[]},{"level":3,"title":"2.3.8 使用异类抽象 Bean 注入","slug":"_2-3-8-使用异类抽象-bean-注入","link":"#_2-3-8-使用异类抽象-bean-注入","children":[]},{"level":3,"title":"2.3.9 为应用指定多个 Spring 配置文件","slug":"_2-3-9-为应用指定多个-spring-配置文件","link":"#_2-3-9-为应用指定多个-spring-配置文件","children":[]}]},{"level":2,"title":"2.4 基于注解的 DI","slug":"_2-4-基于注解的-di","link":"#_2-4-基于注解的-di","children":[{"level":3,"title":"2.4.2 Bean 的作用域 @Scope","slug":"_2-4-2-bean-的作用域-scope","link":"#_2-4-2-bean-的作用域-scope","children":[]},{"level":3,"title":"2.4.3 基本类型属性注入 @Value","slug":"_2-4-3-基本类型属性注入-value","link":"#_2-4-3-基本类型属性注入-value","children":[]},{"level":3,"title":"2.4.4 按类型注入域属性@Autowired","slug":"_2-4-4-按类型注入域属性-autowired","link":"#_2-4-4-按类型注入域属性-autowired","children":[]},{"level":3,"title":"2.4.5 按名称注入域属性 @Autowired 与 @Qualifier","slug":"_2-4-5-按名称注入域属性-autowired-与-qualifier","link":"#_2-4-5-按名称注入域属性-autowired-与-qualifier","children":[]},{"level":3,"title":"2.4.6 域属性注解@Resource","slug":"_2-4-6-域属性注解-resource","link":"#_2-4-6-域属性注解-resource","children":[]},{"level":3,"title":"2.4.7 Bean 的生命始末 @PostConstruct 与 @PreDestroy","slug":"_2-4-7-bean-的生命始末-postconstruct-与-predestroy","link":"#_2-4-7-bean-的生命始末-postconstruct-与-predestroy","children":[]},{"level":3,"title":"2.4.8 使用 JavaConfig 进行配置（了解）","slug":"_2-4-8-使用-javaconfig-进行配置-了解","link":"#_2-4-8-使用-javaconfig-进行配置-了解","children":[]},{"level":3,"title":"2.4.9 使用 JUnit4 测试 Spring（了解）","slug":"_2-4-9-使用-junit4-测试-spring-了解","link":"#_2-4-9-使用-junit4-测试-spring-了解","children":[]},{"level":3,"title":"2.4.10 注解与 XML 共同使用","slug":"_2-4-10-注解与-xml-共同使用","link":"#_2-4-10-注解与-xml-共同使用","children":[]}]}],"git":{"createdTime":1678594861000,"updatedTime":1678594861000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":34.83,"words":10450},"filePathRelative":"学习/后端/SSM框架/Spring4/二、Spring与IoC.md","localizedDate":"2023年3月12日","excerpt":"<h1> 二、Spring与IoC</h1>\\n<p>​\\t控制反转（IOC，Inversion of Control），<span style=\\"color:red\\">是一个概念，是一种思想。</span></p>\\n<p>​\\t指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。</p>\\n<p>​\\tIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。</p>\\n<ul>\\n<li>依赖查找：Dependency  Lookup，DL，容器提供回调接口和上下文环境给组件，程序代码则 <strong>需要提供具体的查找方式</strong>。比较典型的是依赖于 JNDI 系统的查找。</li>\\n<li>依赖注入：Dependency Injection，DI，程序代码不做定位查询，这些工作<strong>由容器自行完成</strong>。</li>\\n</ul>","autoDesc":true}');export{e as data};
