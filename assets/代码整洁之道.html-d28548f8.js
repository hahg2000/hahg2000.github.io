import{_ as a,W as n,X as e,a2 as s}from"./framework-0bc3c581.js";const i={},l=s(`<h1 id="代码整洁之道" tabindex="-1"><a class="header-anchor" href="#代码整洁之道" aria-hidden="true">#</a> 代码整洁之道</h1><h2 id="_3-1-短小" tabindex="-1"><a class="header-anchor" href="#_3-1-短小" aria-hidden="true">#</a> 3.1 短小</h2><p>函数应该要短小。</p><p>作者在 Kent Beck 家中拜访的时候，看到了一个有趣的Swing程序（Swing 是一个为Java设计的GUI工具包），这个程序运行时会在鼠标的位置爆发出火花特效，然后火花就掉落在窗口底部。然后肯特给我看代码的时候，我对于代码中函数的小尺寸而惊讶，因为我看惯了Swing程序中一大串的函数。里面的函数只有三行左右长，每个函数都一目了然，而且每个函数都会依序把你带到下一个函数。</p><p>像 <code>if</code> 语句、<code>else</code> 语句或者 <code>while</code> 语句等，其中的代码块应该只有一行，不仅保持函数短小，也能易于阅读和理解。</p><h2 id="_3-2-只做一件事" tabindex="-1"><a class="header-anchor" href="#_3-2-只做一件事" aria-hidden="true">#</a> 3.2 只做一件事</h2><p>函数应该做一件事。做好这件事。只做这一件事。</p><p>要判断函数是否不止做了一件事，就是看是否能再拆出一个函数，或者是否能切分出多个区段。</p><h2 id="_3-3-每个函数一个抽象层级" tabindex="-1"><a class="header-anchor" href="#_3-3-每个函数一个抽象层级" aria-hidden="true">#</a> 3.3 每个函数一个抽象层级</h2><p>想要函数只有一个抽象层级需要让代码拥有自顶向下的阅读顺序。这个规则也称为向下规则。</p><p>最开头：</p><ul><li><strong>要容纳设置步骤</strong></li><li>纳入测试页面内容</li><li>纳入分拆步骤</li></ul><p>然后对 <strong>容纳设置步骤</strong> 进行拆解</p><ul><li>要容纳设置步骤 <ul><li>如果是套件，就纳入 <strong>套件设置步骤</strong></li><li>然后再纳入普通设置步骤</li></ul></li></ul><p>然后对 <strong>套件设置步骤</strong> 进行拆解</p><ul><li>要容纳套件设置步骤 <ul><li>先搜索 “SuiteSetup” 页面的上级继承关系</li><li>再添加一个包括该页面路径的语句</li></ul></li></ul><h2 id="_3-4-switch语句" tabindex="-1"><a class="header-anchor" href="#_3-4-switch语句" aria-hidden="true">#</a> 3.4 switch语句</h2><p>这是一段代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Money</span> <span class="token function">calculatePay</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InvalidEmployeeType</span><span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token constant">COMMISSIONED</span><span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token function">calculateCommissionedPay</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">HOURLY</span><span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token function">calculateCommissionedPay</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">SALARIED</span><span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token function">calculateCommissionedPay</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果要添加新的类型</span>
        <span class="token comment">// case xxxxxx:</span>
        <span class="token comment">//   return </span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidEmployeeType</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该代码有几个问题：</p><ul><li>当雇员类型增多时，<code>switch</code> 的长度会变得更长</li><li>违反了单一权责原则（如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责），例如当某个类型改变了，需要改变 <code>case</code> 的判断条件。</li><li>违反了开放闭合原则（软件实体应该是可扩展，而不可修改的）。每次新增类型时，就必须到函数里修改</li><li></li></ul><h2 id="_3-5-使用描述性的名称" tabindex="-1"><a class="header-anchor" href="#_3-5-使用描述性的名称" aria-hidden="true">#</a> 3.5 使用描述性的名称</h2><ul><li>函数名称需要具有描述性</li><li>别害怕长名称</li><li>命名方式要保持一直</li></ul><h2 id="_3-6-函数参数" tabindex="-1"><a class="header-anchor" href="#_3-6-函数参数" aria-hidden="true">#</a> 3.6 函数参数</h2><p>最理想的参数数量时零，其次是一，再次是二，应尽量避免三。</p><h3 id="_3-6-1-一元函数" tabindex="-1"><a class="header-anchor" href="#_3-6-1-一元函数" aria-hidden="true">#</a> 3.6.1 一元函数</h3><ul><li>向函数传入单个参数有两种极普遍的理由 <ul><li>处理参数：传入一个参数，然后处理完成后，<strong>返回一个参数</strong></li><li>触发事件：传入一个参数，触发相对应的事件，<strong>不返回参数</strong></li></ul></li><li>避免不编写除了上面两种的一元函数</li><li>不要向函数传入布尔值</li></ul><h3 id="_3-6-3-二元函数" tabindex="-1"><a class="header-anchor" href="#_3-6-3-二元函数" aria-hidden="true">#</a> 3.6.3 二元函数</h3><ul><li>二元函数比一元函数更难懂，更不明了</li><li>如果有自然的组合和自然的排序可以使用两元函数，例如用于表示一个点的 <code>x</code> 值和 <code>y</code>值</li><li>如果没有自然顺序的二元函数，需要进一步的小心</li><li>可以使用一些机制将二元函数转换成一元函数。例如将 <code>writeField(outputStream, name)</code> 转换成 <code>outputStream.writeField(name)</code></li></ul><h3 id="_3-6-4-三元函数" tabindex="-1"><a class="header-anchor" href="#_3-6-4-三元函数" aria-hidden="true">#</a> 3.6.4 三元函数</h3><ul><li>三元函数里参数的排序、琢磨和忽略的问题都会加倍</li><li>在写三元函数前一定要想清楚</li></ul><h3 id="_3-6-5-参数对象" tabindex="-1"><a class="header-anchor" href="#_3-6-5-参数对象" aria-hidden="true">#</a> 3.6.5 参数对象</h3><ul><li>如果函数看来需要两个、三个或者三个以上的参数，就说明其中一些参数应该封装为类。</li></ul><h3 id="_3-6-6-参数列表" tabindex="-1"><a class="header-anchor" href="#_3-6-6-参数列表" aria-hidden="true">#</a> 3.6.6 参数列表</h3><ul><li>如果使用可变变量，不变数量的参数最好少于等于两个</li></ul><h3 id="_3-6-7-动词与关键词" tabindex="-1"><a class="header-anchor" href="#_3-6-7-动词与关键词" aria-hidden="true">#</a> 3.6.7 动词与关键词</h3><ul><li>对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。例如 <code>write(name)</code> ，我们不知道 <code>name</code> 是什么，如果写成 <code>writeField(name)</code> ，我们就知道 <code>name</code> 是个 <code>Field</code></li><li>如果能把参数名称编码成了函数名。例如 <code>assertEqual</code> 改成 <code>assertExpectedEqualsActual(expected, actual)</code> ，就很明显知道第一个参数是 <code>Expected</code> ，第二个参数是 <code>actual</code></li></ul><h2 id="_3-7-无副作用" tabindex="-1"><a class="header-anchor" href="#_3-7-无副作用" aria-hidden="true">#</a> 3.7 无副作用</h2><ul><li>在函数调用时，不要更改当前系统的状态。</li><li>在面向对象编程中，函数尽量不要有输出值。</li></ul><h2 id="_3-8-分隔指令与询问" tabindex="-1"><a class="header-anchor" href="#_3-8-分隔指令与询问" aria-hidden="true">#</a> 3.8 分隔指令与询问</h2><ul><li>要把指令与询问分隔开来，例如判断后再处理，而不是处理完后再根据处理结果进行判断</li></ul><h2 id="_3-9-使用异常替代返回错误码" tabindex="-1"><a class="header-anchor" href="#_3-9-使用异常替代返回错误码" aria-hidden="true">#</a> 3.9 使用异常替代返回错误码</h2><ul><li>使用异常替代返回错误码有几个好处 <ol><li>不会导致更深层次的嵌套结果</li><li>错误处理代码可以从主路径代码中分离出来</li><li>错误码通常是某个类或者枚举，当修改时，导入和使用它的类都需要重新编译和部署，这就对Error类造成了负面压力</li><li>在使用 <code>Try/Catch</code> 代码块的时候可以从主体部分抽离出来</li><li>抽离出来后函数可以单独只处理错误这一件事</li></ol></li></ul><h2 id="_3-10-别重复自己" tabindex="-1"><a class="header-anchor" href="#_3-10-别重复自己" aria-hidden="true">#</a> 3.10 别重复自己</h2><p>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。</p><h2 id="_3-11-结构化编程" tabindex="-1"><a class="header-anchor" href="#_3-11-结构化编程" aria-hidden="true">#</a> 3.11 结构化编程</h2><p>Dijkstra 认为，每个函数、函数中的每个代码块都应该有一个入口、一哥出口。</p><p>意味着在每个函数只该有一个 <code>return</code> 语句，循环中不能有 <code>break</code> 或者 <code>continue</code> 语句，不能有 <code>goto</code> 语句</p>`,48),c=[l];function t(o,d){return n(),e("div",null,c)}const p=a(i,[["render",t],["__file","代码整洁之道.html.vue"]]);export{p as default};
