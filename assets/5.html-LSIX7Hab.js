import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c as l,a as s,b as a,d as e,f as c}from"./app-BVqESlQI.js";const i={},r=s("h1",{id:"第-5-章-编写-json-库",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#第-5-章-编写-json-库"},[s("span",null,"第 5 章：编写 JSON 库")])],-1),d=s("h2",{id:"json-简介",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#json-简介"},[s("span",null,"JSON 简介")])],-1),u=s("p",null,"在这一章，我们将开发一个小而完整的 Haskell 库，这个库用于处理和序列化 JSON 数据。",-1),k=s("a",{href:"www.json.org"},"www.json.org",-1),v={href:"http://www.ietf.org/rfc/rfc4627.txt",target:"_blank",rel:"noopener noreferrer"},b=c(`<p>JSON 支持四种基本类型值：字符串、数字、布尔值和一个特殊值， <code>null</code> 。</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token string">&quot;a string&quot;</span>

<span class="token number">12345</span>

<span class="token boolean">true</span>

<span class="token null keyword">null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>JSON 还提供了两种复合类型：<em>数组</em>是值的有序序列，而<em>对象</em>则是&quot;名字/值&quot;对的无序集合（unordered collection of name/value pairs）。其中对象的名字必须是字符串，而对象和数组的值则可以是任何 JSON 类型。</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">[</span><span class="token number">-3.14</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token null keyword">null</span><span class="token punctuation">,</span> <span class="token string">&quot;a string&quot;</span><span class="token punctuation">]</span>

<span class="token punctuation">{</span><span class="token property">&quot;numbers&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">&quot;useful&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="representing-json-data-in-haskell" tabindex="-1"><a class="header-anchor" href="#representing-json-data-in-haskell"><span>在 Haskell 中表示 JSON 数据</span></a></h2><p>要在 Haskell 中处理 JSON 数据，可以用一个代数数据类型来表示 JSON 的各个数据类型：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/SimpleJSON.hs</span>
<span class="token keyword">data</span> <span class="token constant">JValue</span> <span class="token operator">=</span> <span class="token constant">JString</span> <span class="token constant">String</span>
            <span class="token operator">|</span> <span class="token constant">JNumber</span> <span class="token constant">Double</span>
            <span class="token operator">|</span> <span class="token constant">JBool</span> <span class="token constant">Bool</span>
            <span class="token operator">|</span> <span class="token constant">JNull</span>
            <span class="token operator">|</span> <span class="token constant">JObject</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">JValue</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token operator">|</span> <span class="token constant">JArray</span> <span class="token punctuation">[</span><span class="token constant">JValue</span><span class="token punctuation">]</span>
              <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[译注：这里的 <code>JObject [(String, JValue)]</code> 不能改为 <code>JObject [(JString, JValue)]</code> ，因为值构造器里面声明的是类构造器，不能是值构造器。</p><p>另外，严格来说， <code>JObject</code> 并不是完全无序的，因为它的定义使用了列表来包围，在书本的后面会介绍 <code>Map</code> 类型，它可以创建一个无序的键-值对结构。]</p><p>对于每个 JSON 类型，代码都定义了一个单独的值构造器。部分构造器带有参数，比如说，如果你要创建一个 JSON 字符串，那么就要给 <code>JString</code> 值构造器传入一个 <code>String</code> 类型值作为参数。</p><p>将这些定义载入到 ghci 试试看：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude<span class="token operator">&gt;</span> :load SimpleJSON
<span class="token punctuation">[</span><span class="token number">1</span> of <span class="token number">1</span><span class="token punctuation">]</span> Compiling Main             <span class="token punctuation">(</span> SimpleJSON.hs, interpreted <span class="token punctuation">)</span>
Ok, modules loaded: Main.

*Main<span class="token operator">&gt;</span> JString <span class="token string">&quot;the quick brown fox&quot;</span>
JString <span class="token string">&quot;the quick brown fox&quot;</span>

*Main<span class="token operator">&gt;</span> JNumber <span class="token number">3.14</span>
JNumber <span class="token number">3.14</span>

*Main<span class="token operator">&gt;</span> JBool True
JBool True

*Main<span class="token operator">&gt;</span> JNull
JNull

*Main<span class="token operator">&gt;</span> JObject <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;language&quot;</span>, JString <span class="token string">&quot;Haskell&quot;</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token string">&quot;complier&quot;</span>, JString <span class="token string">&quot;GHC&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
JObject <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;language&quot;</span>,JString <span class="token string">&quot;Haskell&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">&quot;complier&quot;</span>,JString <span class="token string">&quot;GHC&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

*Main<span class="token operator">&gt;</span> JArray <span class="token punctuation">[</span>JString <span class="token string">&quot;Haskell&quot;</span>, JString <span class="token string">&quot;Clojure&quot;</span>, JString <span class="token string">&quot;Python&quot;</span><span class="token punctuation">]</span>
JArray <span class="token punctuation">[</span>JString <span class="token string">&quot;Haskell&quot;</span>,JString <span class="token string">&quot;Clojure&quot;</span>,JString <span class="token string">&quot;Python&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面代码中的构造器将一个 Haskell 值转换为一个 <code>JValue</code> 。反过来，同样可以通过模式匹配，从 <code>JValue</code> 中取出 Haskell 值。</p><p>以下函数试图从一个 <code>JString</code> 值中取出一个 Haskell 字符串：如果 <code>JValue</code> 真的包含一个字符串，那么程序返回一个用 <code>Just</code> 构造器包裹的字符串；否则，它返回一个 <code>Nothing</code> 。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/SimpleJSON.hs</span>
<span class="token hvariable">getString</span> <span class="token operator">::</span> <span class="token constant">JValue</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token hvariable">getString</span> <span class="token punctuation">(</span><span class="token constant">JString</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">s</span>
<span class="token hvariable">getString</span> <span class="token hvariable">_</span>           <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保存修改过的源码文件，然后使用 <code>:reload</code> 命令重新载入 <code>SimpleJSON.hs</code> 文件（<code>:reload</code> 会自动记忆最近一次载入的文件）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>*Main<span class="token operator">&gt;</span> :reload
<span class="token punctuation">[</span><span class="token number">1</span> of <span class="token number">1</span><span class="token punctuation">]</span> Compiling Main             <span class="token punctuation">(</span> SimpleJSON.hs, interpreted <span class="token punctuation">)</span>
Ok, modules loaded: Main.

*Main<span class="token operator">&gt;</span> getString <span class="token punctuation">(</span>JString <span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
Just <span class="token string">&quot;hello&quot;</span>

*Main<span class="token operator">&gt;</span> getString <span class="token punctuation">(</span>JNumber <span class="token number">3</span><span class="token punctuation">)</span>
Nothing
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再加上一些其他函数，初步完成一些基本功能：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/SimpleJSON.hs</span>
<span class="token hvariable">getInt</span> <span class="token punctuation">(</span><span class="token constant">JNumber</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">truncate</span> <span class="token hvariable">n</span><span class="token punctuation">)</span>
<span class="token hvariable">getInt</span> <span class="token hvariable">_</span>           <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">getDouble</span> <span class="token punctuation">(</span><span class="token constant">JNumber</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">n</span>
<span class="token hvariable">getDouble</span> <span class="token hvariable">_</span>           <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">getBool</span> <span class="token punctuation">(</span><span class="token constant">JBool</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">b</span>
<span class="token hvariable">getBool</span> <span class="token hvariable">_</span>         <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">getObject</span> <span class="token punctuation">(</span><span class="token constant">JObject</span> <span class="token hvariable">o</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">o</span>
<span class="token hvariable">getObject</span> <span class="token hvariable">_</span>           <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">getArray</span> <span class="token punctuation">(</span><span class="token constant">JArray</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>
<span class="token hvariable">getArray</span> <span class="token hvariable">_</span>          <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">isNull</span> <span class="token hvariable">v</span>            <span class="token operator">=</span> <span class="token hvariable">v</span> <span class="token operator">==</span> <span class="token constant">JNull</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>truncate</code> 函数返回浮点数或者有理数的整数部分：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude<span class="token operator">&gt;</span> truncate <span class="token number">5.8</span>
<span class="token number">5</span>

Prelude<span class="token operator">&gt;</span> :module +Data.Ratio

Prelude Data.Ratio<span class="token operator">&gt;</span> truncate <span class="token punctuation">(</span><span class="token number">22</span> % <span class="token number">7</span><span class="token punctuation">)</span>
<span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="haskell-模块" tabindex="-1"><a class="header-anchor" href="#haskell-模块"><span>Haskell 模块</span></a></h2><p>一个 Haskell 文件可以包含一个模块定义，模块可以决定模块中的哪些名字可以被外部访问。</p><p>模块的定义必须放在其它定义之前：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/SimpleJSON.hs</span>
<span class="token keyword">module</span> <span class="token constant">SimpleJSON</span>
    <span class="token punctuation">(</span>
        <span class="token constant">JValue</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span>   <span class="token hvariable">getString</span>
    <span class="token punctuation">,</span>   <span class="token hvariable">getInt</span>
    <span class="token punctuation">,</span>   <span class="token hvariable">getDouble</span>
    <span class="token punctuation">,</span>   <span class="token hvariable">getBool</span>
    <span class="token punctuation">,</span>   <span class="token hvariable">getObject</span>
    <span class="token punctuation">,</span>   <span class="token hvariable">getArray</span>
    <span class="token punctuation">,</span>   <span class="token hvariable">isNull</span>
    <span class="token punctuation">)</span> <span class="token keyword">where</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>单词 <code>module</code> 是保留字，跟在它之后的是模块的名字：模块名字必须以大写字母开头，并且它必须和包含这个模块的文件的基础名（不包含后缀的文件名）一致。比如上面定义的模块就以 <code>SimpleJSON</code> 命名，因为包含它的文件名为 <code>SimpleJSON.hs</code> 。</p><p>在模块名之后，用括号包围的是<em>导出</em>列表（list of exports）。 <code>where</code> 关键字之后的内容为模块的体。</p><p>导出列表决定模块中的哪些名字对于外部模块是可见的，使得私有代码可以隐藏在模块的内部。跟在 <code>JValue</code> 之后的 <code>(..)</code> 符号表示导出 <code>JValue</code> 类型以及它的所有值构造器。</p><p>事实上，模块甚至可以只导出类型的名字（类构造器），而不导出这个类型的值构造器。这种能力非常重要：它允许模块对用户隐藏类型的细节，将一个类型变得<em>抽象</em>。如果用户看不见类型的值构造器，他就没办法对类型的值进行模式匹配，也不能使用值构造器显式创建这种类型的值[译注：只能通过相应的 API 来创建这种类型的值]。本章稍后会说明，在什么情况下，我们需要将一个类型变得抽象。</p><p>如果省略掉模块定义中的导出部分，那么所有名字都会被导出：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token keyword">module</span> <span class="token constant">ExportEverything</span> <span class="token keyword">where</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果不想导出模块中的任何名字（通常不会这么用），那么可以将导出列表留空，仅保留一对括号：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token keyword">module</span> <span class="token constant">ExportNothing</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="编译-haskell-代码" tabindex="-1"><a class="header-anchor" href="#编译-haskell-代码"><span>编译 Haskell 代码</span></a></h2><p>除了 ghci 之外， GHC 还包括一个生成本地码（native code）的编译器： ghc。如果你熟悉 gcc 或者 cl （微软 Visual Studio 使用的 C++ 编译器组件）之类的编译器，那么你对 ghc 应该不会感到陌生。</p><p>编译一个 Haskell 源码文件可以通过 <code>ghc</code> 命令来完成：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ ghc <span class="token parameter variable">-c</span> SimpleJSON.hs 

$ <span class="token function">ls</span>
SimpleJSON.hi  SimpleJSON.hs  SimpleJSON.o
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-c</code> 表示让 ghc 只生成目标代码。如果省略 <code>-c</code> 选项，那么 ghc 就会试图生成一个完整的可执行文件，这会失败，因为目前的 <code>SimpleJSON.hs</code> 还没有定义 <code>main</code> 函数，而 GHC 在执行一个独立程序时会调用这个 <code>main</code> 函数。</p><p>在编译完成之后，会生成两个新文件。其中 <code>SimpleJSON.hi</code> 是<em>接口文件</em>（interface file）， ghc 以机器可读的格式，将模块中导出名字的信息保存在这个文件。而 <code>SimpleJSON.o</code> 则是<em>目标文件</em>（object file），它包含了已生成的机器码。</p><h2 id="载入模块和生成可执行文件" tabindex="-1"><a class="header-anchor" href="#载入模块和生成可执行文件"><span>载入模块和生成可执行文件</span></a></h2><p>既然已经成功编译了 <code>SimpleJSON</code> 库，是时候写个小程序来执行它了。打开编辑器，将以下内容保存为 <code>Main.hs</code> ：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Main.hs</span>

<span class="token keyword">module</span> <span class="token constant">Main</span> <span class="token punctuation">(</span><span class="token hvariable">main</span><span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token import-statement"><span class="token keyword">import</span> SimpleJSON</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token constant">JObject</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token constant">JNumber</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span> <span class="token constant">JBool</span> <span class="token constant">False</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[译注：原文说，可以不导出 <code>main</code> 函数，但是实际中测试这种做法并不能通过编译。]</p><p>放在模块定义之后的 <code>import</code> 表示载入所有 <code>SimpleJSON</code> 模块导出的名字，使得它们在 <code>Main</code> 模块中可用。</p><p>所有 <code>import</code> 指令（directive）都必须出现在模块的开头，并且位于其他模块代码之前。不可以随意摆放 <code>import</code> 。</p><p><code>Main.hs</code> 的名字和 <code>main</code> 函数的命名是有特别含义的，要创建一个可执行文件， ghc 需要一个命名为 <code>Main</code> 的模块，并且这个模块里面还要有一个 <code>main</code> 函数，而 <code>main</code> 函数在程序执行时会被调用。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghc <span class="token parameter variable">-o</span> simple Main.hs
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这次编译没有使用 <code>-c</code> 选项，因此 ghc 会尝试生成一个可执行程序，这个过程被称为<em>链接</em>（linking）。ghc 可以在一条命令中同时完成编译和链接的任务。</p><p><code>-o</code> 选项用于指定可执行程序的名字。在 Windows 平台下，它会生成一个 <code>.exe</code> 后缀的文件，而 UNIX 平台的文件则没有后缀。</p><p>ghc 会自动找到所需的文件，进行编译和链接，然后产生可执行文件，我们唯一要做的就是提供 <code>Main.hs</code> 文件。</p><p>[译注：在原文中说到，编译时必须手动列出所有相关文件，但是在新版 GHC 中，编译时提供 <code>Main.hs</code> 就可以了，编译器会自动找到、编译和链接相关代码。因此，本段内容做了相应的修改。]</p><p>一旦编译完成，就可以运行编译所得的可执行文件了：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ ./simple 
JObject <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span>,JNumber <span class="token number">1.0</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">&quot;bar&quot;</span>,JBool False<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="打印-json-数据" tabindex="-1"><a class="header-anchor" href="#打印-json-数据"><span>打印 JSON 数据</span></a></h2><p>SimpleJSON 模块已经有了 JSON 类型的表示了，那么下一步要做的就是将 Haskell 值翻译（render）成 JSON 数据。</p><p>有好几种方法可以将 Haskell 值翻译成 JSON 数据，最直接的一种是编写翻译函数，以 JSON 格式来打印 Haskell 值。稍后会介绍完成这个任务的其他更有趣方法。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>-- file: ch05/PutJSON.hs
module PutJSON where

<span class="token function">import</span> Data.List <span class="token punctuation">(</span>intercalate<span class="token punctuation">)</span>
<span class="token function">import</span> SimpleJSON

renderJValue :: JValue -<span class="token operator">&gt;</span> String

renderJValue <span class="token punctuation">(</span>JString s<span class="token punctuation">)</span>   <span class="token operator">=</span> show s
renderJValue <span class="token punctuation">(</span>JNumber n<span class="token punctuation">)</span>   <span class="token operator">=</span> show n
renderJValue <span class="token punctuation">(</span>JBool True<span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span>
renderJValue <span class="token punctuation">(</span>JBool False<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;false&quot;</span>
renderJValue JNull         <span class="token operator">=</span> <span class="token string">&quot;null&quot;</span>

renderJValue <span class="token punctuation">(</span>JObject o<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> ++ pairs o ++ <span class="token string">&quot;}&quot;</span>
  where pairs <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
    pairs <span class="token function">ps</span> <span class="token operator">=</span> intercalate <span class="token string">&quot;, &quot;</span> <span class="token punctuation">(</span>map renderPair <span class="token function">ps</span><span class="token punctuation">)</span>
    renderPair <span class="token punctuation">(</span>k,v<span class="token punctuation">)</span>   <span class="token operator">=</span> show k ++ <span class="token string">&quot;: &quot;</span> ++ renderJValue <span class="token function">v</span>

renderJValue <span class="token punctuation">(</span>JArray a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> ++ values a ++ <span class="token string">&quot;]&quot;</span>
  where values <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
    values vs <span class="token operator">=</span> intercalate <span class="token string">&quot;, &quot;</span> <span class="token punctuation">(</span>map renderJValue vs<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分割纯代码和带有 IO 的代码是一种良好的 Haskell 风格。这里我们用 <code>putJValue</code> 来进行打印操作，这样就不会影响 <code>renderJValue</code> 的纯洁性：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token hvariable">putJValue</span> <span class="token operator">::</span> <span class="token constant">JValue</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">putJValue</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">renderJValue</span> <span class="token hvariable">v</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在打印 JSON 值变得容易得多了：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token constant">Prelude</span> <span class="token constant">SimpleJSON</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">load</span> <span class="token constant">PutJSON</span>
<span class="token punctuation">[</span><span class="token number">2</span> <span class="token keyword">of</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token constant">Compiling</span> <span class="token constant">PutJSON</span>          <span class="token punctuation">(</span> <span class="token hvariable">PutJSON<span class="token punctuation">.</span>hs</span><span class="token punctuation">,</span> <span class="token hvariable">interpreted</span> <span class="token punctuation">)</span>
<span class="token constant">Ok</span><span class="token punctuation">,</span> <span class="token hvariable">modules</span> <span class="token hvariable">loaded</span><span class="token operator">:</span> <span class="token constant">PutJSON</span><span class="token punctuation">,</span> <span class="token constant">SimpleJSON</span><span class="token punctuation">.</span>

<span class="token operator">*</span><span class="token constant">PutJSON</span><span class="token operator">&gt;</span> <span class="token hvariable">putJValue</span> <span class="token punctuation">(</span><span class="token constant">JString</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span>
<span class="token string">&quot;a&quot;</span>

<span class="token operator">*</span><span class="token constant">PutJSON</span><span class="token operator">&gt;</span> <span class="token hvariable">putJValue</span> <span class="token punctuation">(</span><span class="token constant">JBool</span> <span class="token constant">True</span><span class="token punctuation">)</span>
<span class="token hvariable">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了风格上的考虑之外，将翻译代码和实际打印代码分开，也有助于提升灵活性。比如说，如果想在数据写出之前进行压缩，那么只需要修改 <code>putJValue</code> 就可以了，不必改动整个 <code>renderJValue</code> 函数。</p><p>将纯代码和不纯代码分离的理念非常强大，并且在 Haskell 代码中无处不在。现有的一些 Haskell 压缩模块，它们都拥有简单的接口：压缩函数接受一个未压缩的字符串，并返回一个压缩后的字符串。通过组合使用不同的函数，可以在打印 JSON 值之前，对数据进行各种不同的处理。</p><h2 id="type-inference-is-a-double-edge-sword" tabindex="-1"><a class="header-anchor" href="#type-inference-is-a-double-edge-sword"><span>类型推导是一把双刃剑</span></a></h2><p>Haskell 编译器的类型推导能力非常强大也非常有价值。在刚开始的时候，我们通常会倾向于尽可能地省略所有类型签名，让类型推导去决定所有函数的类型定义。</p><p>但是，这种做法是有缺陷的，它通常是 Haskell 新手引发类型错误的主要来源。</p><p>如果我们省略显式的类型信息时，那么编译器就必须猜测我们的意图：它会推导出合乎逻辑且相容的（consistent）类型，但是，这些类型可能并不是我们想要的。一旦程序员和编译器之间的想法产生了分歧，那么寻找 bug 的工作就会变得更困难。</p><p>作为例子，假设有一个函数，它预计会返回 <code>String</code> 类型的值，但是没有显式地为它编写类型签名：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Trouble.hs</span>

<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span> <span class="token punctuation">(</span><span class="token builtin">toUpper</span><span class="token punctuation">)</span>

<span class="token hvariable">upcaseFirst</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">toUpper</span> <span class="token hvariable">c</span>  <span class="token comment">-- 这里忘记了 &quot;:cs&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数试图将输入单词的第一个字母设置为大写，但是它在设置之后，忘记了重新拼接字符串的后续部分 <code>cs</code> 。在我们的预想中，这个函数的类型应该是 <code>String -&gt; String</code> ，但编译器推导出的类型却是 <code>String -&gt; Char</code> 。</p><p>现在，有另一个函数调用这个 <code>upcaseFirst</code> 函数：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Trouble.hs</span>

<span class="token hvariable">camelCase</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">camelCase</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">upcaseFirst</span> <span class="token punctuation">(</span><span class="token builtin">words</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码在载入 ghci 时会发生错误：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude<span class="token operator">&gt;</span> :load Trouble.hs
<span class="token punctuation">[</span><span class="token number">1</span> of <span class="token number">1</span><span class="token punctuation">]</span> Compiling Main             <span class="token punctuation">(</span> Trouble.hs, interpreted <span class="token punctuation">)</span>

Trouble.hs:8:28:
    Couldn<span class="token string">&#39;t match expected type \`[Char]&#39;</span> with actual <span class="token builtin class-name">type</span> <span class="token variable"><span class="token variable">\`</span>Char&#39;
    Expected type: <span class="token punctuation">[</span>Char<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>Char<span class="token punctuation">]</span>
        Actual type: <span class="token punctuation">[</span>Char<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Char
    In the first argument of <span class="token variable">\`</span></span>map<span class="token string">&#39;, namely \`upcaseFirst&#39;</span>
    In the first argument of <span class="token variable"><span class="token variable">\`</span>concat&#39;, namely            <span class="token variable">\`</span></span><span class="token punctuation">(</span>map upcaseFirst <span class="token punctuation">(</span>words xs<span class="token punctuation">))</span>&#39;
Failed, modules loaded: none.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，如果不是 <code>upcaseFirst</code> 被其他函数所调用的话，它的错误可能并不会被发现！相反，如果我们之前为 <code>upcaseFirst</code> 编写了类型签名的话，那么 <code>upcaseFirst</code> 的类型错误就会立即被捕捉到，并且可以即刻定位出错误发生的位置。</p><p>为函数编写类型签名，既可以移除我们实际想要的类型和编译器推导出的类型之间的分歧，也可以作为函数的一种文档，帮助阅读和理解函数的行为。</p><p>这并不是说要巨细无遗地为所有函数都编写类型签名。不过，为所有顶层（top-level）函数添加类型签名通常是一种不错的做法。在刚开始的时候最好尽可能地为函数添加类型签名，然后随着对类型系统了解的加深，逐步放松要求。</p><h2 id="a-more-general-look-at-rendering" tabindex="-1"><a class="header-anchor" href="#a-more-general-look-at-rendering"><span>更通用的转换方式</span></a></h2><p>在前面构造 SimpleJSON 库时，我们的目标主要是按照 JSON 的格式，将 Haskell 数据转换为 JSON 值。而这些转换所得值的输出可能并不是那么适合人去阅读。有一些被称为美观打印器（pretty printer）的库，它们的输出既适合机器读入，也适合人类阅读。我们这就来编写一个美观打印器，学习库设计和函数式编程的相关技术。</p><p>这个美观打印器库命名为 Prettify ，它被包含在 <code>Prettify.hs</code> 文件里。为了让 Prettify 适用于实际需求，我们先编写一个新的 JSON 转换器，它使用 Prettify 提供的 API 。等完成这个 JSON 转换器之后，再转过头来补充 Prettify 模块的细节。</p><p>和前面的 SimpleJSON 模块不同，Prettify 模块将数据转换为一种称为 <code>Doc</code> 类型的抽象数据，而不是字符串：抽象类型允许我们随意选择不同的实现，最大化灵活性和效率，而且在更改实现时，不会影响到用户。</p><p>新的 JSON 转换模块被命名为 <code>PrettyJSON.hs</code> ，转换的工作依然由 <code>renderJValue</code> 函数进行，它的定义和之前一样简单直观：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/PrettyJSON.hs</span>
<span class="token hvariable">renderJValue</span> <span class="token operator">::</span> <span class="token constant">JValue</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">renderJValue</span> <span class="token punctuation">(</span><span class="token constant">JBool</span> <span class="token constant">True</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token hvariable">text</span> <span class="token string">&quot;true&quot;</span>
<span class="token hvariable">renderJValue</span> <span class="token punctuation">(</span><span class="token constant">JBool</span> <span class="token constant">False</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">text</span> <span class="token string">&quot;false&quot;</span>
<span class="token hvariable">renderJValue</span> <span class="token constant">JNull</span>         <span class="token operator">=</span> <span class="token hvariable">text</span> <span class="token string">&quot;null&quot;</span>
<span class="token hvariable">renderJValue</span> <span class="token punctuation">(</span><span class="token constant">JNumber</span> <span class="token hvariable">num</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">double</span> <span class="token hvariable">num</span>
<span class="token hvariable">renderJValue</span> <span class="token punctuation">(</span><span class="token constant">JString</span> <span class="token hvariable">str</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">string</span> <span class="token hvariable">str</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>text</code> 、 <code>double</code> 和 <code>string</code> 都由 Prettify 模块提供。</p><h2 id="developing-haskell-code-without-going-nuts" tabindex="-1"><a class="header-anchor" href="#developing-haskell-code-without-going-nuts"><span>Haskell 开发诀窍</span></a></h2><p>在刚开始进行 Haskell 开发的时候，通常需要面对大量崭新、不熟悉的概念，要一次性完成程序的编写，并顺利通过编译器检查，难度非常的高。</p><p>在每次完成一个功能点时，花几分钟停下来，对程序进行编译，是非常有益的：因为 Haskell 是强类型语言，如果程序能成功通过编译，那么说明程序和我们预想中的目标相去不远。</p><p>编写函数和类型的占位符（placeholder）版本，对于快速原型开发非常有效。举个例子，前文断言， <code>string</code> 、 <code>text</code> 和 <code>double</code> 函数都由 <code>Prettify</code> 模块提供，如果 <code>Prettify</code> 模块里不定义这些函数，或者不定义 <code>Doc</code> 类型，那么对程序的编译就会失败，我们的&quot;早编译，常编译&quot;战术就没有办法施展。通过编写占位符代码，可以避免这些问题：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/PrettyStub.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> SimpleJSON</span>

<span class="token keyword">data</span> <span class="token constant">Doc</span> <span class="token operator">=</span> <span class="token constant">ToBeDefined</span>
         <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>

 <span class="token hvariable">string</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
 <span class="token hvariable">string</span> <span class="token hvariable">str</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>

 <span class="token hvariable">text</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
 <span class="token hvariable">text</span> <span class="token hvariable">str</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>

 <span class="token hvariable">double</span> <span class="token operator">::</span> <span class="token constant">Double</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
 <span class="token hvariable">double</span> <span class="token hvariable">num</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>特殊值 <code>undefined</code> 的类型为 <code>a</code> ，因此它可以让代码顺利通过类型检查。因为它只是一个占位符，没有什么实际作用，所以对它进行求值只会产生错误：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>*Main<span class="token operator">&gt;</span> :type undefined
undefined :: a

*Main<span class="token operator">&gt;</span> undefined
*** Exception: Prelude.undefined

*Main<span class="token operator">&gt;</span> :load PrettyStub.hs
<span class="token punctuation">[</span><span class="token number">2</span> of <span class="token number">2</span><span class="token punctuation">]</span> Compiling Main             <span class="token punctuation">(</span> PrettyStub.hs, interpreted <span class="token punctuation">)</span>
Ok, modules loaded: Main, SimpleJSON.

*Main<span class="token operator">&gt;</span> :type double
double :: Double -<span class="token operator">&gt;</span> Doc

*Main<span class="token operator">&gt;</span> double <span class="token number">3.14</span>
*** Exception: Prelude.undefined
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尽管程序里还没有任何实际可执行的代码，但是编译器的类型检查器可以保证程序中类型的正确性，这为接下来的进一步开发奠定了良好基础。</p><p>[译注：原文中 <code>PrettyStub.hs</code> 和 <code>Prettify.hs</code> 混合使用，给读者阅读带来了很大麻烦。为了避免混淆，下文统一在 <code>Prettify.hs</code> 中书写代码，并列出编译通过所需要的占位符代码。随着文章进行，读者只要不断将占位符版本替换为可用版本即可。]</p><h2 id="pretty-printing-a-string" tabindex="-1"><a class="header-anchor" href="#pretty-printing-a-string"><span>美观打印字符串</span></a></h2><p>当需要美观地打印字符串时，我们需要遵守 JSON 的转义规则。字符串，顾名思义，仅仅是一串被包含在引号中的字符而已。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">string</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">string</span> <span class="token operator">=</span> <span class="token hvariable">enclose</span> <span class="token char string">&#39;&quot;&#39;</span> <span class="token char string">&#39;&quot;&#39;</span> <span class="token operator">.</span> <span class="token hvariable">hcat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token hvariable">oneChar</span>

<span class="token hvariable">enclose</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">enclose</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>

<span class="token hvariable">hcat</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Doc</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">hcat</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>

<span class="token hvariable">oneChar</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">oneChar</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>enclose</code> 函数把一个 <code>Doc</code> 值用起始字符和终止字符包起来。 <code>(&lt;&gt;)</code> 函数将两个 <code>Doc</code> 值拼接起来。也就是说，它是 <code>Doc</code> 中的 <code>++</code> 函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">enclose</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">enclose</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">char</span> <span class="token hvariable">left</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">x</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">char</span> <span class="token hvariable">right</span>

<span class="token punctuation">(</span><span class="token operator">&lt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">a</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>

<span class="token hvariable">char</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">char</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>hcat</code> 函数将多个 <code>Doc</code> 值拼接成一个，类似列表中的 <code>concat</code> 函数。</p><p><code>string</code> 函数将 <code>oneChar</code> 函数应用于字符串的每一个字符，然后把拼接起来的结果放入引号中。 <code>oneChar</code> 函数将一个单独的字符进行转义（escape）或转换（render）。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">oneChar</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">oneChar</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token builtin">lookup</span> <span class="token hvariable">c</span> <span class="token hvariable">simpleEscapes</span> <span class="token keyword">of</span>
              <span class="token constant">Just</span> <span class="token hvariable">r</span> <span class="token operator">-&gt;</span> <span class="token hvariable">text</span> <span class="token hvariable">r</span>
              <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token hvariable">mustEscape</span> <span class="token hvariable">c</span> <span class="token operator">-&gt;</span> <span class="token hvariable">hexEscape</span> <span class="token hvariable">c</span>
                      <span class="token operator">|</span> <span class="token builtin">otherwise</span>    <span class="token operator">-&gt;</span> <span class="token hvariable">char</span> <span class="token hvariable">c</span>
    <span class="token keyword">where</span> <span class="token hvariable">mustEscape</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span> <span class="token operator">&lt;</span> <span class="token char string">&#39; &#39;</span> <span class="token operator">||</span> <span class="token hvariable">c</span> <span class="token operator">==</span> <span class="token char string">&#39;\\x7f&#39;</span> <span class="token operator">||</span> <span class="token hvariable">c</span> <span class="token operator">&gt;</span> <span class="token char string">&#39;\\xff&#39;</span>

<span class="token hvariable">simpleEscapes</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Char</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">simpleEscapes</span> <span class="token operator">=</span> <span class="token builtin">zipWith</span> <span class="token hvariable">ch</span> <span class="token string">&quot;\\b\\n\\f\\r\\t\\\\\\&quot;/&quot;</span> <span class="token string">&quot;bnfrt\\\\\\&quot;/&quot;</span>
    <span class="token keyword">where</span> <span class="token hvariable">ch</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token char string">&#39;\\\\&#39;</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token hvariable">hexEscape</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">hexEscape</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>simpleEscapes</code> 是一个序对组成的列表。我们把由序对组成的列表称为<em>关联列表（association list）</em>，或简称为<em>alist</em>。我们的 alist 将字符和其对应的转义形式关联起来。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :l Prettify.hs
ghci<span class="token operator">&gt;</span> take <span class="token number">4</span> simpleEscapes
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&#39;\\b&#39;</span>,<span class="token string">&quot;<span class="token entity" title="\\\\">\\\\</span>b&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">&#39;\\n&#39;</span>,<span class="token string">&quot;<span class="token entity" title="\\\\">\\\\</span>n&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">&#39;\\f&#39;</span>,<span class="token string">&quot;<span class="token entity" title="\\\\">\\\\</span>f&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">&#39;\\r&#39;</span>,<span class="token string">&quot;<span class="token entity" title="\\\\">\\\\</span>r&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>case</code> 表达式试图确定一个字符是否存在于 alist 当中。如果存在，我们就返回它对应的转义形式，否则我们就要用更复杂的方法来转义它。当两种转义都不需要时我们返回字符本身。保守地说，我们返回的非转义字符只包含可打印的 ASCII 字符。</p><p>上文提到的复杂的转义是指将一个 Unicode 字符转为一个 &quot;<em>\\u</em>&quot; 加上四个表示它编码16进制数字。</p><p>[译注：<code>smallHex</code> 函数为 <code>hexEscape</code> 函数的一部分，只处理较为简单的一种情况。]</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> Numeric</span> <span class="token punctuation">(</span><span class="token hvariable">showHex</span><span class="token punctuation">)</span>

<span class="token hvariable">smallHex</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">smallHex</span> <span class="token hvariable">x</span>  <span class="token operator">=</span> <span class="token hvariable">text</span> <span class="token string">&quot;\\\\u&quot;</span>
           <span class="token operator">&lt;&gt;</span> <span class="token hvariable">text</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">-</span> <span class="token builtin">length</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token char string">&#39;0&#39;</span><span class="token punctuation">)</span>
           <span class="token operator">&lt;&gt;</span> <span class="token hvariable">text</span> <span class="token hvariable">h</span>
    <span class="token keyword">where</span> <span class="token hvariable">h</span> <span class="token operator">=</span> <span class="token hvariable">showHex</span> <span class="token hvariable">x</span> <span class="token string">&quot;&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>showHex</code> 函数来自于 <code>Numeric</code> 库（需要在 <code>Prettify.hs</code> 开头载入)，它返回一个数字的16进制表示。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> showHex <span class="token number">114111</span> <span class="token string">&quot;&quot;</span>
<span class="token string">&quot;1bdbf&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>replicate</code> 函数由 <code>Prelude</code> 提供，它创建一个长度确定的重复列表。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> replicate <span class="token number">5</span> <span class="token string">&quot;foo&quot;</span>
<span class="token punctuation">[</span><span class="token string">&quot;foo&quot;</span>,<span class="token string">&quot;foo&quot;</span>,<span class="token string">&quot;foo&quot;</span>,<span class="token string">&quot;foo&quot;</span>,<span class="token string">&quot;foo&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>有一点需要注意： <code>smallHex</code> 提供的4位数字编码仅能够表示 <code>0xffff</code> 范围之内的 Unicode 字符。而合法的 Unicode 字符范围可达 <code>0x10ffff</code> 。为了使用 JSON 字符串表示这部分字符，我们需要遵循一些复杂的规则将它们一分为二。这使得我们有机会对 Haskell 数字进行一些位操作(bit-level manipulation)。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Bits</span> <span class="token punctuation">(</span><span class="token hvariable">shiftR</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">.&amp;.</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token hvariable">astral</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">astral</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token hvariable">smallHex</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token number">0xd800</span><span class="token punctuation">)</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">smallHex</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">+</span> <span class="token number">0xdc00</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">\`shiftR\`</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">.&amp;.</span> <span class="token number">0x3ff</span>
          <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">n</span> <span class="token operator">.&amp;.</span> <span class="token number">0x3ff</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>shiftR</code> 函数来自 <code>Data.Bits</code> 模块，它把一个数字右移一位。同样来自于 <code>Data.Bits</code> 模块的 <code>(.&amp;.)</code> 函数将两个数字进行按位与操作。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> 0x10000 <span class="token variable"><span class="token variable">\`</span>shiftR<span class="token variable">\`</span></span> <span class="token number">4</span>   :: Int
<span class="token number">4096</span>
ghci<span class="token operator">&gt;</span> <span class="token number">7</span> <span class="token builtin class-name">.</span><span class="token operator">&amp;</span><span class="token builtin class-name">.</span> <span class="token number">2</span>   :: Int
<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了 <code>smallHex</code> 和 <code>astral</code> ，我们可以如下定义 <code>hexEscape</code> ：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span> <span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">)</span>

<span class="token hvariable">hexEscape</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">hexEscape</span> <span class="token hvariable">c</span> <span class="token operator">|</span> <span class="token hvariable">d</span> <span class="token operator">&lt;</span> <span class="token number">0x10000</span> <span class="token operator">=</span> <span class="token hvariable">smallHex</span> <span class="token hvariable">d</span>
            <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token hvariable">astral</span> <span class="token punctuation">(</span><span class="token hvariable">d</span> <span class="token operator">-</span> <span class="token number">0x10000</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span> <span class="token hvariable">d</span> <span class="token operator">=</span> <span class="token builtin">ord</span> <span class="token hvariable">c</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="arrays-and-objects-and-the-module-header" tabindex="-1"><a class="header-anchor" href="#arrays-and-objects-and-the-module-header"><span>数组和对象</span></a></h2><p>跟字符串比起来，美观打印数组和对象就简单多了。我们已经知道它们两个看起来很像：以起始字符开头，中间是用逗号隔开的一系列值，以终止字符结束。我们写个函数来体现它们的共同特点：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">series</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">series</span> <span class="token hvariable">open</span> <span class="token hvariable">close</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">enclose</span> <span class="token hvariable">open</span> <span class="token hvariable">close</span>
                    <span class="token operator">.</span> <span class="token hvariable">fsep</span> <span class="token operator">.</span> <span class="token hvariable">punctuate</span> <span class="token punctuation">(</span><span class="token hvariable">char</span> <span class="token char string">&#39;,&#39;</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token hvariable">f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们来解释这个函数的类型。它的参数是一个起始字符和一个终止字符，然后是一个知道怎样打印未知类型 <code>a</code> 的函数，接着是一个包含 <code>a</code> 类型数据的列表，最后返回一个 <code>Doc</code> 类型的值。</p><p>尽管函数的类型签名有4个参数，我们在函数定义中只列出了3个。这跟我们把 <code>myLength xs = length xs</code> 简化成 <code>myLength = length</code> 是一个道理。</p><p>我们已经有了把 <code>Doc</code> 包在起始字符和终止字符之间的 <code>enclose</code> 函数。<code>fsep</code> 会在 <code>Prettify</code> 模块中定义。它将多个 <code>Doc</code> 值拼接成一个，并且在需要的时候换行。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">fsep</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Doc</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">fsep</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>punctuate</code> 函数也会在 <code>Prettify</code> 中定义。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">punctuate</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Doc</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Doc</span><span class="token punctuation">]</span>
<span class="token hvariable">punctuate</span> <span class="token hvariable">p</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">punctuate</span> <span class="token hvariable">p</span> <span class="token punctuation">[</span><span class="token hvariable">d</span><span class="token punctuation">]</span>    <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">d</span><span class="token punctuation">]</span>
<span class="token hvariable">punctuate</span> <span class="token hvariable">p</span> <span class="token punctuation">(</span><span class="token hvariable">d</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">d</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">p</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">punctuate</span> <span class="token hvariable">p</span> <span class="token hvariable">ds</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了 <code>series</code>，美观打印数组就非常直观了。我们在 <code>renderJValue</code> 的定义的最后加上下面一行。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/PrettyJSON.hs</span>
<span class="token hvariable">renderJValue</span> <span class="token punctuation">(</span><span class="token constant">JArray</span> <span class="token hvariable">ary</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">series</span> <span class="token char string">&#39;[&#39;</span> <span class="token char string">&#39;]&#39;</span> <span class="token hvariable">renderJValue</span> <span class="token hvariable">ary</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>美观打印对象稍微麻烦一点：对于每个元素，我们还要额外处理名字和值。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/PrettyJSON.hs</span>
<span class="token hvariable">renderJValue</span> <span class="token punctuation">(</span><span class="token constant">JObject</span> <span class="token hvariable">obj</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">series</span> <span class="token char string">&#39;{&#39;</span> <span class="token char string">&#39;}&#39;</span> <span class="token hvariable">field</span> <span class="token hvariable">obj</span>
    <span class="token keyword">where</span> <span class="token hvariable">field</span> <span class="token punctuation">(</span><span class="token hvariable">name</span><span class="token punctuation">,</span><span class="token hvariable">val</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">string</span> <span class="token hvariable">name</span>
                          <span class="token operator">&lt;&gt;</span> <span class="token hvariable">text</span> <span class="token string">&quot;: &quot;</span>
                          <span class="token operator">&lt;&gt;</span> <span class="token hvariable">renderJValue</span> <span class="token hvariable">val</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="writing-a-module-header" tabindex="-1"><a class="header-anchor" href="#writing-a-module-header"><span>书写模块头</span></a></h2><p><code>PrettyJSON.hs</code> 文件写得差不多了，我们现在回到文件顶部书写模块声明。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/PrettyJSON.hs</span>
<span class="token keyword">module</span> <span class="token constant">PrettyJSON</span>
    <span class="token punctuation">(</span>
      <span class="token hvariable">renderJValue</span>
    <span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token import-statement"><span class="token keyword">import</span> SimpleJSON</span> <span class="token punctuation">(</span><span class="token constant">JValue</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token import-statement"><span class="token keyword">import</span> Prettify</span> <span class="token punctuation">(</span><span class="token constant">Doc</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">char</span><span class="token punctuation">,</span> <span class="token hvariable">double</span><span class="token punctuation">,</span> <span class="token hvariable">fsep</span><span class="token punctuation">,</span> <span class="token hvariable">hcat</span><span class="token punctuation">,</span> <span class="token hvariable">punctuate</span><span class="token punctuation">,</span> <span class="token hvariable">text</span><span class="token punctuation">,</span> <span class="token hvariable">compact</span><span class="token punctuation">,</span> <span class="token hvariable">pretty</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[译注：<code>compact</code> 和 <code>pretty</code> 函数会在稍后介绍。]</p><p>我们只从这个模块导出了一个函数，<code>renderJValue</code>，也就是我们的 JSON 转换函数。其它的函数只是为了支持 <code>renderJValue</code>，因此没必要对其它模块可见。</p><p>关于载入部分，<code>Numeric</code> 和 <code>Data.Bits</code> 模块是 GHC 内置的。我们已经写好了 <code>SimpleJSON</code> 模块，<code>Prettify</code> 模块的框架也搭好了。可以看出载入标准模块和我们自己写的模块没什么区别。</p><p>[译注：原文在 <code>PrettyJSON.hs</code> 头部载入了 <code>Numeric</code> 和 <code>Data.Bits</code> 模块。但事实上并无必要，因此在译文中删除。此处作者的说明部分未作改动。]</p><p>在每个 <code>import</code> 命令中，我们都显式地列出了名字，用以引入我们模块的命名空间。这并非强制：如果省略这些名字，我们就可以使用一个模块导出的所有名字。然而，通常来讲显式地载入更好。</p><ul><li>一个显式列表清楚地表明了我们从哪里载入了哪个名字。如果读者碰到了不熟悉的函数，这便于他们查看文档。</li><li>有时候库的维护者会删除或者重命名函数。一个函数很可能在我们写完模块很久之后才从第三方库中消失并导致编译错误。显式列表提醒我们消失的名字是从哪儿载入的，有助于我们更快找到问题。</li><li>另外一种情况是库的维护者在模块中加入的函数与我们代码中现有的函数名字一样。如果不用显式列表，这个函数就会在我们的模块中出现两次。当我们用这个函数的时候，GHC 就会报告歧义错误。</li></ul><p>通常情况下使用显式列表更好，但这并不是硬性规定。有的时候，我们需要一个模块中的很多名字，一一列举会非常麻烦。有的时候，有些模块已经被广泛使用，有经验的 Hashell 程序员会知道哪个名字来自那些模块。</p><h2 id="fleshing-out-the-pretty-printing-library" tabindex="-1"><a class="header-anchor" href="#fleshing-out-the-pretty-printing-library"><span>完成美观打印库</span></a></h2><p>在 <code>Prettify</code> 模块中，我们用代数数据类型来表示 <code>Doc</code> 类型。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token keyword">data</span> <span class="token constant">Doc</span> <span class="token operator">=</span> <span class="token constant">Empty</span>
         <span class="token operator">|</span> <span class="token constant">Char</span> <span class="token constant">Char</span>
         <span class="token operator">|</span> <span class="token constant">Text</span> <span class="token constant">String</span>
         <span class="token operator">|</span> <span class="token constant">Line</span>
         <span class="token operator">|</span> <span class="token constant">Concat</span> <span class="token constant">Doc</span> <span class="token constant">Doc</span>
         <span class="token operator">|</span> <span class="token constant">Union</span> <span class="token constant">Doc</span> <span class="token constant">Doc</span>
           <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span><span class="token constant">Eq</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出 <code>Doc</code> 类型其实是一棵树。<code>Concat</code> 和 <code>Union</code> 构造器以两个 <code>Doc</code> 值构造一个内部节点，<code>Empty</code> 和其它简单的构造器构造叶子。</p><p>在模块头中，我们导出了这个类型的名字，但是不包含任何它的构造器：这样可以保证使用这个类型的模块无法创建 Doc 值和对其进行模式匹配。</p><p>如果想创建 Doc，<code>Prettify</code> 模块的用户可以调用我们提供的函数。下面是一些简单的构造函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">empty</span> <span class="token operator">::</span> <span class="token constant">Doc</span>
<span class="token hvariable">empty</span> <span class="token operator">=</span> <span class="token constant">Empty</span>

<span class="token hvariable">char</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">char</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token constant">Char</span> <span class="token hvariable">c</span>

<span class="token hvariable">text</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">text</span> <span class="token string">&quot;&quot;</span> <span class="token operator">=</span> <span class="token constant">Empty</span>
<span class="token hvariable">text</span> <span class="token hvariable">s</span>  <span class="token operator">=</span> <span class="token constant">Text</span> <span class="token hvariable">s</span>

<span class="token hvariable">double</span> <span class="token operator">::</span> <span class="token constant">Double</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">double</span> <span class="token hvariable">d</span> <span class="token operator">=</span> <span class="token hvariable">text</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">d</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Line</code> 构造器表示一个换行。<code>line</code> 函数创建一个<em>硬</em>换行，它总是出现在美观打印器的输出中。有时候我们想要一个<em>软</em>换行，只有在行太宽，一个窗口或一页放不下的时候才用。稍后我们就会介绍这个 <code>softline</code> 函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">line</span> <span class="token operator">::</span> <span class="token constant">Doc</span>
<span class="token hvariable">line</span> <span class="token operator">=</span> <span class="token constant">Line</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是 <code>(&lt;&gt;)</code> 函数的实现。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token punctuation">(</span><span class="token operator">&lt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token constant">Empty</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">y</span>
<span class="token hvariable">x</span> <span class="token operator">&lt;&gt;</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
<span class="token hvariable">x</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> \`<span class="token constant">Concat</span>\` <span class="token hvariable">y</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用 <code>Empty</code> 进行模式匹配。将一个 <code>Empty</code> 拼接在一个 <code>Doc</code> 值的左侧或右侧都不会有效果。这样可以帮助我们的树减少一些无意义信息。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">text</span> <span class="token string">&quot;foo&quot;</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">text</span> <span class="token string">&quot;bar&quot;</span>
<span class="token constant">Concat</span> <span class="token punctuation">(</span><span class="token constant">Text</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Text</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">text</span> <span class="token string">&quot;foo&quot;</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">empty</span>
<span class="token constant">Text</span> <span class="token string">&quot;foo&quot;</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">empty</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">text</span> <span class="token string">&quot;bar&quot;</span>
<span class="token constant">Text</span> <span class="token string">&quot;bar&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">Note</p><p>来思考下数学 从数学的角度来看，<code>Empty</code> 是拼接操作(concatenation)的单位元，因为任何 <code>Doc</code> 值和 <code>Empty</code> 拼接后都不变。 同理，0是加法的单位元，1是乘法的单位元。从数学的角度来看问题有非常实用的价值，我们在本书后面还会多次看到此类情况。</p></div><p>我们的 <code>hcat</code> 和 <code>fsep</code> 函数将 <code>Doc</code> 列表拼接成一个 <code>Doc</code> 值。 在之前的一道题目里（fix link），我们提到了可以用 <code>foldr</code> 来定义列表拼接。 [译注：这个例子只是为了回顾，本章代码并没有用到。]</p><pre><code>concat :: [[a]] -&gt; [a]
concat = foldr (++) []
</code></pre><p>因为 <code>(&lt;&gt;)</code> 类比于 <code>(++)</code>，<code>empty</code> 类比于 <code>[]</code>，我们可以用同样的方法来定义 <code>hcat</code> 和 <code>fsep</code> 函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">hcat</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Doc</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">hcat</span> <span class="token operator">=</span> <span class="token hvariable">fold</span> <span class="token punctuation">(</span><span class="token operator">&lt;&gt;</span><span class="token punctuation">)</span>

<span class="token hvariable">fold</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Doc</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">fold</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token hvariable">f</span> <span class="token hvariable">empty</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>fsep</code> 的定义依赖于其它几个函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">fsep</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Doc</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">fsep</span> <span class="token operator">=</span> <span class="token hvariable">fold</span> <span class="token punctuation">(</span><span class="token operator">&lt;/&gt;</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token operator">&lt;/&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">x</span> <span class="token operator">&lt;/&gt;</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">softline</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">y</span>

<span class="token hvariable">softline</span> <span class="token operator">::</span> <span class="token constant">Doc</span>
<span class="token hvariable">softline</span> <span class="token operator">=</span> <span class="token builtin">group</span> <span class="token hvariable">line</span>

<span class="token builtin">group</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token builtin">group</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>稍微来解释一下。如果当前行变得太长，<code>softline</code> 函数就插入一个新行，否则就插入一个空格。 <code>Doc</code> 并没有包含&quot;怎样才算太长&quot;的信息，这该怎么实现呢？ 答案是每次碰到这种情况，我们使用 <code>Union</code> 构造器来用两种不同的方式保存文档。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token builtin">group</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token builtin">group</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">flatten</span> <span class="token hvariable">x</span> \`<span class="token constant">Union</span>\` <span class="token hvariable">x</span>

<span class="token hvariable">flatten</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">flatten</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>flatten</code> 函数将 <code>Line</code> 替换为一个空格，把两行变成一行。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">flatten</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
<span class="token hvariable">flatten</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> \`<span class="token constant">Concat</span>\` <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">flatten</span> <span class="token hvariable">x</span> \`<span class="token constant">Concat</span>\` <span class="token hvariable">flatten</span> <span class="token hvariable">y</span>
<span class="token hvariable">flatten</span> <span class="token constant">Line</span>           <span class="token operator">=</span> <span class="token constant">Char</span> <span class="token char string">&#39; &#39;</span>
<span class="token hvariable">flatten</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> \`<span class="token constant">Union</span>\` <span class="token hvariable">_</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token hvariable">flatten</span> <span class="token hvariable">x</span>
<span class="token hvariable">flatten</span> <span class="token hvariable">other</span>          <span class="token operator">=</span> <span class="token hvariable">other</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们只在 <code>Union</code> 左侧的元素上调用 <code>flatten</code>： <code>Union</code> 左侧元素的长度总是大于等于右侧元素的长度。 下面的转换函数会用到这一性质。</p><h3 id="compact-rendering" tabindex="-1"><a class="header-anchor" href="#compact-rendering"><span>紧凑转换</span></a></h3><p>我们经常希望一段数据占用的字符数越少越好。例如，如果我们想通过网络传输 JSON 数据，就没必要把它弄得很漂亮：另外一端的软件并不关心它漂不漂亮，而使布局变漂亮的空格会增加额外开销。</p><p>在这种情况下，我们提供一个最基本的紧凑转换函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">compact</span> <span class="token operator">::</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">compact</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">transform</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token keyword">where</span> <span class="token hvariable">transform</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
          <span class="token hvariable">transform</span> <span class="token punctuation">(</span><span class="token hvariable">d</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token operator">=</span>
                <span class="token keyword">case</span> <span class="token hvariable">d</span> <span class="token keyword">of</span>
                    <span class="token constant">Empty</span>        <span class="token operator">-&gt;</span> <span class="token hvariable">transform</span> <span class="token hvariable">ds</span>
                    <span class="token constant">Char</span> <span class="token hvariable">c</span>       <span class="token operator">-&gt;</span> <span class="token hvariable">c</span> <span class="token operator">:</span> <span class="token hvariable">transform</span> <span class="token hvariable">ds</span>
                    <span class="token constant">Text</span> <span class="token hvariable">s</span>       <span class="token operator">-&gt;</span> <span class="token hvariable">s</span> <span class="token operator">++</span> <span class="token hvariable">transform</span> <span class="token hvariable">ds</span>
                    <span class="token constant">Line</span>         <span class="token operator">-&gt;</span> <span class="token char string">&#39;\\n&#39;</span> <span class="token operator">:</span> <span class="token hvariable">transform</span> <span class="token hvariable">ds</span>
                    <span class="token hvariable">a</span> \`<span class="token constant">Concat</span>\` <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">transform</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">:</span><span class="token hvariable">b</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span>
                    <span class="token hvariable">_</span> \`<span class="token constant">Union</span>\` <span class="token hvariable">b</span>  <span class="token operator">-&gt;</span> <span class="token hvariable">transform</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>compact</code> 函数把它的参数放进一个列表里，然后再对它应用 <code>transform</code> 辅助函数。 <code>transform</code> 函数把参数当做栈来处理，列表的第一个元素即为栈顶。</p><p><code>transform</code> 函数的 <code>(d:ds)</code> 模式将栈分为头 <code>d</code> 和剩余部分 <code>ds</code>。 在 <code>case</code> 表达式里，前几个分支在 <code>ds</code> 上递归，每次处理一个栈顶的元素。 最后两个分支在 <code>ds</code> 前面加了东西：<code>Concat</code> 分支把两个元素都加到栈里，<code>Union</code> 分支忽略左侧元素（我们对它调用了 <code>flatten</code> ），只把右侧元素加进栈里。</p><p>现在我们终于可以在 <strong>ghci</strong> 里试试 <code>compact</code> 函数了。[译注：这里要对 <code>PrettyJSON.hs</code> 里 <code>import Prettify</code> 部分作一下修改才能使 <code>PrettyJSON.hs</code> 编译。 包括去掉还未实现的 <code>pretty</code> 函数，增加缺少的 <code>string</code>, <code>series</code> 函数等。一个可以编译的版本如下。]</p><p>[</p><p>我(sancao2)还是不能编译成功,报错:</p><pre><code>Prelude&gt; :l PrettyJSON.hs

Prettify.hs:1:1:
    File name does not match module name:
    Saw: \`Main&#39;
    Expected: \`Prettify&#39;
Failed, modules loaded: none.
</code></pre><p>在开头加上 <code>module Prettify where</code>.就能编译通过了.</p><pre><code>Prelude&gt; :l PrettyJSON
[1 of 3] Compiling SimpleJSON       ( SimpleJSON.hs, interpreted )
[2 of 3] Compiling Prettify         ( Prettify.hs, interpreted )
[3 of 3] Compiling PrettyJSON       ( PrettyJSON.hs, interpreted )
Ok, modules loaded: PrettyJSON, SimpleJSON, Prettify.
</code></pre><p>]</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/PrettyJSON.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> Prettify</span> <span class="token punctuation">(</span><span class="token constant">Doc</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">string</span><span class="token punctuation">,</span> <span class="token hvariable">series</span><span class="token punctuation">,</span> <span class="token hvariable">char</span><span class="token punctuation">,</span> <span class="token hvariable">double</span><span class="token punctuation">,</span> <span class="token hvariable">fsep</span><span class="token punctuation">,</span> <span class="token hvariable">hcat</span><span class="token punctuation">,</span> <span class="token hvariable">punctuate</span><span class="token punctuation">,</span> <span class="token hvariable">text</span><span class="token punctuation">,</span> <span class="token hvariable">compact</span><span class="token punctuation">)</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">value</span> <span class="token operator">=</span> <span class="token hvariable">renderJValue</span> <span class="token punctuation">(</span><span class="token constant">JObject</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;f&quot;</span><span class="token punctuation">,</span> <span class="token constant">JNumber</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;q&quot;</span><span class="token punctuation">,</span> <span class="token constant">JBool</span> <span class="token constant">True</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token keyword">type</span> <span class="token hvariable">value</span>
<span class="token hvariable">value</span> <span class="token operator">::</span> <span class="token constant">Doc</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">compact</span> <span class="token hvariable">value</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">&quot;f&quot;</span><span class="token operator">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span>
<span class="token string">&quot;q&quot;</span><span class="token operator">:</span> <span class="token hvariable">true</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了更好地理解代码，我们来分析一个更简单的例子。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">char</span> <span class="token char string">&#39;f&#39;</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">text</span> <span class="token string">&quot;oo&quot;</span>
<span class="token constant">Concat</span> <span class="token punctuation">(</span><span class="token constant">Char</span> <span class="token char string">&#39;f&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Text</span> <span class="token string">&quot;oo&quot;</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">compact</span> <span class="token punctuation">(</span><span class="token hvariable">char</span> <span class="token char string">&#39;f&#39;</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">text</span> <span class="token string">&quot;oo&quot;</span><span class="token punctuation">)</span>
<span class="token string">&quot;foo&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们调用 <code>compact</code> 时，它把参数转成一个列表并应用 <code>transform</code>。</p><ul><li><p><code>transform</code> 函数的参数是一个单元素列表，匹配 <code>(d:ds)</code> 模式。因此 <code>d</code> 是 <code>Concat (Char &#39;f&#39;) (Text &quot;oo&quot;)</code>，<code>ds</code> 是个空列表，<code>[]</code>。</p><p>因为 <code>d</code> 的构造器是 <code>Concat</code>，<code>case</code> 表达式匹配到了 <code>Concat</code> 分支。我们把 <code>Char &#39;f&#39;</code> 和 <code>Text &quot;oo&quot;</code> 放进栈里，并递归调用 <code>transform</code>。</p><ul><li><p>这次 <code>transform</code> 的参数是一个二元素列表，匹配 <code>(d:ds)</code> 模式。变量 <code>d</code> 被绑定到 <code>Char &#39;f&#39;</code>，<code>ds</code> 被绑定到 <code>[Text &quot;oo&quot;]</code>。 <code>case</code> 表达式匹配到 <code>Char</code> 分支。因此我们用 <code>(:)</code> 构造一个列表，它的头是 <code>&#39;f&#39;</code>，剩余部分是对 <code>transform</code> 进行递归调用的结果。</p><ul><li><p>这次递归调用的参数是一个单元素列表，变量 <code>d</code> 被绑定到 <code>Text &quot;oo&quot;</code>，<code>ds</code> 被绑定到 <code>[]</code>。 <code>case</code> 表达式匹配到 <code>Text</code> 分支。我们用 <code>(++)</code> 拼接 <code>&quot;oo&quot;</code> 和下次递归调用的结果。</p><ul><li>最后一次调用，<code>transform</code> 的参数是一个空列表，因此返回一个空字符串。</li></ul></li><li><p>结果是 <code>&quot;oo&quot; ++ &quot;&quot;</code>。</p></li></ul></li><li><p>结果是 <code>&#39;f&#39; : &quot;oo&quot; ++ &quot;&quot;</code>。</p></li></ul></li></ul><h3 id="true-pretty-printing" tabindex="-1"><a class="header-anchor" href="#true-pretty-printing"><span>真正的美观打印</span></a></h3><p>我们的 <code>compact</code> 方便了机器之间的交流，人阅读起来却非常困难。我们写一个 <code>pretty</code> 函数来产生可读性较强的输出。 跟 <code>compact</code> 相比, <code>pretty</code> 多了一个参数：每行的最大宽度(有几列)。(假设我们使用等宽字体。)</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">pretty</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">pretty</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更准确地说，这个 <code>Int</code> 参数控制了 <code>pretty</code> 遇到 <code>softline</code> 时的行为。只有碰到 <code>softline</code> 时，<code>pretty</code> 才能选择继续当前行还是新开一行。别的地方，我们必须严格遵守已有的打印规则。</p><p>下面是这个函数的核心部分。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">pretty</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">pretty</span> <span class="token hvariable">width</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">best</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token keyword">where</span> <span class="token hvariable">best</span> <span class="token hvariable">col</span> <span class="token punctuation">(</span><span class="token hvariable">d</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token operator">=</span>
        <span class="token keyword">case</span> <span class="token hvariable">d</span> <span class="token keyword">of</span>
            <span class="token constant">Empty</span>        <span class="token operator">-&gt;</span> <span class="token hvariable">best</span> <span class="token hvariable">col</span> <span class="token hvariable">ds</span>
            <span class="token constant">Char</span> <span class="token hvariable">c</span>       <span class="token operator">-&gt;</span> <span class="token hvariable">c</span> <span class="token operator">:</span>  <span class="token hvariable">best</span> <span class="token punctuation">(</span><span class="token hvariable">col</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">ds</span>
            <span class="token constant">Text</span> <span class="token hvariable">s</span>       <span class="token operator">-&gt;</span> <span class="token hvariable">s</span> <span class="token operator">++</span> <span class="token hvariable">best</span> <span class="token punctuation">(</span><span class="token hvariable">col</span> <span class="token operator">+</span> <span class="token builtin">length</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token hvariable">ds</span>
            <span class="token constant">Line</span>         <span class="token operator">-&gt;</span> <span class="token char string">&#39;\\n&#39;</span> <span class="token operator">:</span> <span class="token hvariable">best</span> <span class="token number">0</span> <span class="token hvariable">ds</span>
            <span class="token hvariable">a</span> \`<span class="token constant">Concat</span>\` <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">best</span> <span class="token hvariable">col</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">:</span><span class="token hvariable">b</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span>
            <span class="token hvariable">a</span> \`<span class="token constant">Union</span>\` <span class="token hvariable">b</span>  <span class="token operator">-&gt;</span> <span class="token hvariable">nicest</span> <span class="token hvariable">col</span> <span class="token punctuation">(</span><span class="token hvariable">best</span> <span class="token hvariable">col</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                                       <span class="token punctuation">(</span><span class="token hvariable">best</span> <span class="token hvariable">col</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token hvariable">best</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>

      <span class="token hvariable">nicest</span> <span class="token hvariable">col</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">width</span> <span class="token operator">-</span> <span class="token hvariable">least</span><span class="token punctuation">)</span> <span class="token operator">\`fits\`</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">a</span>
                     <span class="token operator">|</span> <span class="token builtin">otherwise</span>                <span class="token operator">=</span> <span class="token hvariable">b</span>
                     <span class="token keyword">where</span> <span class="token hvariable">least</span> <span class="token operator">=</span> <span class="token builtin">min</span> <span class="token hvariable">width</span> <span class="token hvariable">col</span>

<span class="token hvariable">fits</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">fits</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>辅助函数 <code>best</code> 接受两个参数：当前行已经走过的列数和剩余需要处理的 <code>Doc</code> 列表。 一般情况下，<code>best</code> 会简单地消耗输入更新 <code>col</code>。即使 <code>Concat</code> 这种情况也显而易见：我们把拼接好的两个元素放进栈里，保持 <code>col</code> 不变。</p><p>有趣的是涉及到 <code>Union</code> 构造器的情况。回想一下，我们将 <code>flatten</code> 应用到了左侧元素，右侧不变。 并且，<code>flatten</code> 把换行替换成了空格。因此，我们的任务是看看两种布局中，哪一种（如果有的话）能满足我们的 <code>width</code> 限制。</p><p>我们还需要一个小的辅助函数来确定某一行已经被转换的 <code>Doc</code> 值是否能放进给定的宽度中。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">fits</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">w</span> <span class="token operator">\`fits\`</span> <span class="token hvariable">_</span> <span class="token operator">|</span> <span class="token hvariable">w</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token constant">False</span>
<span class="token hvariable">w</span> <span class="token operator">\`fits\`</span> <span class="token string">&quot;&quot;</span>        <span class="token operator">=</span> <span class="token constant">True</span>
<span class="token hvariable">w</span> <span class="token operator">\`fits\`</span> <span class="token punctuation">(</span><span class="token char string">&#39;\\n&#39;</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token constant">True</span>
<span class="token hvariable">w</span> <span class="token operator">\`fits\`</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">:</span><span class="token hvariable">cs</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">w</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">\`fits\`</span> <span class="token hvariable">cs</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="following-the-pretty-printer" tabindex="-1"><a class="header-anchor" href="#following-the-pretty-printer"><span>理解美观打印器</span></a></h3><p>为了理解这段代码是如何工作的，我们首先来考虑一个简单的 <code>Doc</code> 值。[译注：<code>PrettyJSON.hs</code> 并未载入 <code>empty</code> 和 <code>&lt;/&gt;</code>。需要读者自行载入。]</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> empty <span class="token operator">&lt;</span>/<span class="token operator">&gt;</span> char <span class="token string">&#39;a&#39;</span>
Concat <span class="token punctuation">(</span>Union <span class="token punctuation">(</span>Char <span class="token string">&#39; &#39;</span><span class="token punctuation">)</span> Line<span class="token punctuation">)</span> <span class="token punctuation">(</span>Char <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会将 <code>pretty 2</code> 应用到这个值上。第一次应用 <code>best</code> 时，<code>col</code> 的值是0。 它匹配到了 <code>Concat</code> 分支，于是把 <code>Union (Char &#39; &#39;) Line</code> 和 <code>Char &#39;a&#39;</code> 放进栈里，继续递归。 在递归调用时，它匹配到了 <code>Union</code> 分支。</p><p>这个时候，我们忽略 Haskell 通常的求值顺序。这使得在不影响结果的情况下，我们的解释最容易被理解。现在我们有两个子表达式：<code>best 0 [Char &#39; &#39;, Char &#39;a&#39;]</code> 和 <code>best 0 [Line, Char &#39;a&#39;]</code>。 第一个被求值成 <code>&quot; a&quot;</code>，第二个被求值成 <code>&quot;\\na&quot;</code>。 我们把这些值替换进函数得到 <code>nicest 0 &quot; a&quot; &quot;\\na&quot;</code>。</p><p>为了弄清 <code>nicest</code> 的结果是什么，我们再做点替换。<code>width</code> 和 <code>col</code> 的值分别是0和2，所以 <code>least</code> 是0，<code>width - least</code> 是2。 我们在 <strong>ghci</strong> 里试试 <code>2 \`fits\` &quot; a&quot;</code> 的结果是什么。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token variable"><span class="token variable">\`</span>fits<span class="token variable">\`</span></span> <span class="token string">&quot; a&quot;</span>
True
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于求值结果为 <code>True</code>，<code>nicest</code> 的结果是 <code>&quot; a&quot;</code>。</p><p>如果我们将 <code>pretty</code> 函数应用到之前的 JSON 上，我们可以看到随着我们给它的宽度不同，它产生了不同的结果。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> putStrLn <span class="token punctuation">(</span>pretty <span class="token number">10</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">&quot;f&quot;</span><span class="token builtin class-name">:</span> <span class="token number">1.0</span>,
<span class="token string">&quot;q&quot;</span><span class="token builtin class-name">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
ghci<span class="token operator">&gt;</span> putStrLn <span class="token punctuation">(</span>pretty <span class="token number">20</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">&quot;f&quot;</span><span class="token builtin class-name">:</span> <span class="token number">1.0</span>, <span class="token string">&quot;q&quot;</span><span class="token builtin class-name">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
ghci<span class="token operator">&gt;</span> putStrLn <span class="token punctuation">(</span>pretty <span class="token number">30</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">&quot;f&quot;</span><span class="token builtin class-name">:</span> <span class="token number">1.0</span>, <span class="token string">&quot;q&quot;</span><span class="token builtin class-name">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="练习" tabindex="-1"><a class="header-anchor" href="#练习"><span>练习</span></a></h3><p>我们现有的美观打印器已经可以满足一定的空间限制要求，我们还可以对它做更多改进。</p><ol><li><p>用下面的类型签名写一个函数 <code>fill</code>。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">fill</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>它应该给文档添加空格直到指定宽度。如果宽度已经超过指定值，则不加。</p></li><li><p>我们的美观打印器并未考虑嵌套（nesting）这种情况。当左括号（无论是小括号，中括号，还是大括号）出现时， 之后的行应该缩进，直到对应的右括号出现为止。</p><p>实现这个功能，缩进量应该可控。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Prettify.hs</span>
<span class="token hvariable">nest</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span> <span class="token operator">-&gt;</span> <span class="token constant">Doc</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="creating-a-package" tabindex="-1"><a class="header-anchor" href="#creating-a-package"><span>创建包</span></a></h2><p>Cabal 是 Haskell 社区用来构建，安装和发布软件的一套标准工具。Cabal 将软件组织为<em>包（package）</em>。一个包有且只能有一个库，但可以有多个可执行程序。</p><h3 id="为包添加描述" tabindex="-1"><a class="header-anchor" href="#为包添加描述"><span>为包添加描述</span></a></h3><p>Cabal 要求你给每个包添加描述。这些描述放在一个以 <code>.cabal</code> 结尾的文件当中。这个文件需要放在你项目的顶层目录里。它的格式很简单，下面我们就来介绍它。</p><p>每个 Cabal 包都需要有个名字。通常来说，包的名字和 <code>.cabal</code> 文件的名字相同。如果我们的包叫做 <code>mypretty</code> ，那我们的文件就是 <code>mypretty.cabal</code> 。通常，包含 <code>.cabal</code> 文件的目录名字和包名字相同，如 <code>mypretty</code> 。</p><p>放在包描述开头的是一些全局属性，它们适用于包里所有的库和可执行程序。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token constant">Name</span><span class="token operator">:</span>          <span class="token hvariable">mypretty</span>
<span class="token constant">Version</span><span class="token operator">:</span>       <span class="token number">0.1</span>

<span class="token comment">-- This is a comment.  It stretches to the end of the line.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>包的名字必须独一无二。如果你创建安装的包和你系统里已经存在的某个包名字相同，GHC 会搞不清楚用哪个。</p><p>全局属性中的很多信息都是给人而不是 Cabal 自己来读的。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token constant">Synopsis</span><span class="token operator">:</span>      <span class="token constant">My</span> <span class="token hvariable">pretty</span> <span class="token hvariable">printing</span> <span class="token hvariable">library</span><span class="token punctuation">,</span> <span class="token hvariable">with</span> <span class="token constant">JSON</span> <span class="token hvariable">support</span>
<span class="token constant">Description</span><span class="token operator">:</span>
    <span class="token constant">A</span> <span class="token hvariable">simple</span> <span class="token hvariable">pretty</span> <span class="token hvariable">printing</span> <span class="token hvariable">library</span> <span class="token hvariable">that</span> <span class="token hvariable">illustrates</span> <span class="token hvariable">how</span> <span class="token hvariable">to</span>
    <span class="token hvariable">develop</span> <span class="token hvariable">a</span> <span class="token constant">Haskell</span> <span class="token hvariable">library</span><span class="token punctuation">.</span>
<span class="token constant">Author</span><span class="token operator">:</span>        <span class="token constant">Real</span> <span class="token constant">World</span> <span class="token constant">Haskell</span>
<span class="token constant">Maintainer</span><span class="token operator">:</span>    <span class="token hvariable">somebody</span><span class="token operator">@</span><span class="token hvariable">realworldhaskell</span><span class="token punctuation">.</span><span class="token hvariable">org</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如 <code>Description</code> 所示，一个字段可以有多行，只要缩进即可。</p><p>许可协议也被放在全局属性中。大部分 Haskell 包使用 BSD 协议，Cabal 称之为 <code>BSD3</code>。（当然，你可以随意选择合适的协议。） 我们可以在 <code>License-File</code> 这个非强制字段中加入许可协议文件，这个文件包含了我们的包所使用的协议的全部协议条款。</p><p>Cabal 所支持的功能会不断变化，因此，指定我们期望兼容的 Cabal 版本是非常明智的。我们增加的功能可以被 Cabal 1.2及以上的版本支持。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token constant">Cabal</span><span class="token operator">-</span><span class="token constant">Version</span><span class="token operator">:</span> <span class="token operator">&gt;=</span> <span class="token number">1.2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们使用 <em>library</em> 区域来描述包中单独的库。缩进的使用非常重要：处于一个区域中的内容必须缩进。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token hvariable">library</span>
    <span class="token constant">Exposed</span><span class="token operator">-</span><span class="token constant">Modules</span><span class="token operator">:</span> <span class="token constant">Prettify</span>
                     <span class="token constant">PrettyJSON</span>
                     <span class="token constant">SimpleJSON</span>
    <span class="token constant">Build</span><span class="token operator">-</span><span class="token constant">Depends</span><span class="token operator">:</span>   <span class="token hvariable">base</span> <span class="token operator">&gt;=</span> <span class="token number">2.0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Exposed-Modules</code> 列出了本包中用户可用的模块。可选字段字段 <code>Other-Modules</code> 列出了<em>内部模块</em>。这些内部模块用来支持这个库的功能，然而对用户不可见。</p><p><code>Build-Depends</code> 包含了构建我们库所需要的包，它们之间用逗号分开。对于每一个包，我们可以选择性地说明这个库可以与之工作的版本号范围。 <code>base</code> 包包含了很多 Haskell 的核心模块，如Prelude，因此实际上它总是被需要的。</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>处理依赖关系</p><p>我们并不需要猜测或者调查我们依赖于哪些包。如果我们在构建包的时候没有包含 <code>Build-Depends</code> 字段，编译会失败，并返回一条有用的错误信息。我们可以试试把 <code>base</code> 注释掉会发生什么。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ runghc Setup build
Preprocessing library mypretty-0.1<span class="token punctuation">..</span>.
Building mypretty-0.1<span class="token punctuation">..</span>.

PrettyJSON.hs:8:7:
    Could not <span class="token function">find</span> module \`Data.Bits&#39;:
        it is a member of package base, <span class="token function">which</span> is hidden
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>错误信息清楚地表明我们需要增加 <code>base</code> 包，尽管它已经被安装了。强制我们显式地列出所有包有一个实际好处：<code>cabal-install</code> 这个命令行工具会自动下载，构建并安装一个包和所有它依赖的包。</p><p>[译注，在运行 <code>runghc Setup build</code> 之前，Cabal 会首先要求你运行 <code>configure</code>。具体方法见下文。]</p></div><h3 id="ghc-的包管理器" tabindex="-1"><a class="header-anchor" href="#ghc-的包管理器"><span>GHC 的包管理器</span></a></h3><p>GHC 内置了一个简单的包管理器用来记录安装了哪些包以及它们的版本号。我们可以使用 <strong>ghc-pkg</strong> 命令来查看包数据库。</p><p>我们说<em>数据库</em>，是因为 GHC 区分所有用户都能使用的<em>系统包（system-wide packages）<em>和只有当前用户才能使用的</em>用户包（per-user packages）</em>。 用户数据库（per-user database）使我们没有管理员权限也可以安装包。</p><p><strong>ghc-pkg</strong> 命令为不同的任务提供了不同的子命令。大多数时间，我们只用到两个。 <code>ghc-pkg list</code> 命令列出已安装的包。当我们想要卸载一个包时，<code>ghc-pkg unregister</code> 告诉 GHC 我们不再用这个包了。 （我们需要手动删除已安装的文件。）</p><h3 id="配置-构建和安装" tabindex="-1"><a class="header-anchor" href="#配置-构建和安装"><span>配置，构建和安装</span></a></h3><p>除了 <code>.cabal</code> 文件，每个包还必须包含一个 <em>setup</em> 文件。 这使得 Cabal 可以在需要的时候自定义构建过程。一个最简单的配置文件如下所示。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch05/Setup.hs</span>
<span class="token operator">#!/</span><span class="token hvariable">usr</span><span class="token operator">/</span><span class="token hvariable">bin</span><span class="token operator">/</span><span class="token hvariable">env</span> <span class="token hvariable">runhaskell</span>
<span class="token import-statement"><span class="token keyword">import</span> Distribution<span class="token punctuation">.</span>Simple</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">defaultMain</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们把这个文件保存为 <code>Setup.hs</code>。</p><p>有了 <code>.cabal</code> 和 <code>Setup.hs</code> 文件之后，我们只有三步之遥。</p><p>我们用一个简单的命令告诉 Cabal 如何构建一个包以及往哪里安装这个包。</p><p>[译注：运行此命令时，Cabal 提示我没有指定 <code>build-type</code>。于是我按照提示在 <code>.cabal</code> 文件里加了 <code>build-type: Simple</code> 字段。]</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ runghc Setup configure
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令保证了我们的包可用，并且保存设置让后续的 Cabal 命令使用。</p><p>如果我们不给 configure 提供任何参数，Cabal 会把我们的包安装在系统包数据库里。如果想安装在指定目录下和用户包数据库内，我们需要提供更多的信息。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ runghc Setup configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span><span class="token environment constant">$HOME</span> <span class="token parameter variable">--user</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>完成之后，我们来构建这个包。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ runghc Setup build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>成功之后，我们就可以安装包了。我们不需要告诉 Cabal 装在哪儿，它会使用我们在第一步里提供的信息。它会把包装在我们指定的目录下然后更新 GHC 的用户包数据库。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ runghc Setup <span class="token function">install</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="practical-pointers-and-further-reading" tabindex="-1"><a class="header-anchor" href="#practical-pointers-and-further-reading"><span>实用链接和扩展阅读</span></a></h2><p>GHC 内置了一个美观打印库，<code>Text.PrettyPrint.HughesPJ</code>。它提供的 API 和我们的例子相同并且有更丰富有用的美观打印函数。与自己实现相比，我们更推荐使用它。</p>`,246),h={href:"https://book.realworldhaskell.org/read/bibliography.html#bib.hughes95",target:"_blank",rel:"noopener noreferrer"},m=s("code",null,"HughesPJ",-1),g={href:"https://book.realworldhaskell.org/read/bibliography.html#bib.wadler98",target:"_blank",rel:"noopener noreferrer"},f=s("code",null,"wl-pprint",-1),y=s("strong",null,"cabal",-1),J=s("strong",null,"cabal install wl-pprint",-1);function S(q,x){const n=p("ExternalLinkIcon");return o(),l("div",null,[r,d,u,s("p",null,[a("JSON （JavaScript 对象符号）是一种小型、表示简单、便于存储和发送的语言。它通常用于从 web 服务向基于浏览器的 JavaScript 程序传送数据。JSON 的格式由 "),k,a(" 描述，而细节由 "),s("a",v,[a("RFC 4627"),e(n)]),a(" 补充。")]),b,s("p",null,[a("John Hughes 在 "),s("a",h,[a("Hughes95"),e(n)]),a(" 中介绍了 "),m,a(" 美观打印器的设计。这个库后来被 Simon Peyton Jones 改进，也因此得名。 Hughes 的论文很长，但他对怎样设计 Haskell 库的讨论非常值得一读。")]),s("p",null,[a("本章介绍的美观打印库基于 Philip Wadler 在 "),s("a",g,[a("Wadler98"),e(n)]),a(" 中描述的一个更简单的系统。 Daan Leijen 扩展了这个库，扩展之后的版本可以从 Hackage 里下载： "),f,a("。 如果你用 "),y,a(" 命令行工具，一个命令即可完成下载，构建和安装："),J,a("。")])])}const O=t(i,[["render",S],["__file","5.html.vue"]]),D=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/5.html","title":"第 5 章：编写 JSON 库","lang":"zh-CN","frontmatter":{"description":"第 5 章：编写 JSON 库 JSON 简介 在这一章，我们将开发一个小而完整的 Haskell 库，这个库用于处理和序列化 JSON 数据。 JSON （JavaScript 对象符号）是一种小型、表示简单、便于存储和发送的语言。它通常用于从 web 服务向基于浏览器的 JavaScript 程序传送数据。JSON 的格式由 www.json.or...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/5.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"第 5 章：编写 JSON 库"}],["meta",{"property":"og:description","content":"第 5 章：编写 JSON 库 JSON 简介 在这一章，我们将开发一个小而完整的 Haskell 库，这个库用于处理和序列化 JSON 数据。 JSON （JavaScript 对象符号）是一种小型、表示简单、便于存储和发送的语言。它通常用于从 web 服务向基于浏览器的 JavaScript 程序传送数据。JSON 的格式由 www.json.or..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-24T04:33:47.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2024-02-24T04:33:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第 5 章：编写 JSON 库\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-24T04:33:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"JSON 简介","slug":"json-简介","link":"#json-简介","children":[]},{"level":2,"title":"在 Haskell 中表示 JSON 数据","slug":"representing-json-data-in-haskell","link":"#representing-json-data-in-haskell","children":[]},{"level":2,"title":"Haskell 模块","slug":"haskell-模块","link":"#haskell-模块","children":[]},{"level":2,"title":"编译 Haskell 代码","slug":"编译-haskell-代码","link":"#编译-haskell-代码","children":[]},{"level":2,"title":"载入模块和生成可执行文件","slug":"载入模块和生成可执行文件","link":"#载入模块和生成可执行文件","children":[]},{"level":2,"title":"打印 JSON 数据","slug":"打印-json-数据","link":"#打印-json-数据","children":[]},{"level":2,"title":"类型推导是一把双刃剑","slug":"type-inference-is-a-double-edge-sword","link":"#type-inference-is-a-double-edge-sword","children":[]},{"level":2,"title":"更通用的转换方式","slug":"a-more-general-look-at-rendering","link":"#a-more-general-look-at-rendering","children":[]},{"level":2,"title":"Haskell 开发诀窍","slug":"developing-haskell-code-without-going-nuts","link":"#developing-haskell-code-without-going-nuts","children":[]},{"level":2,"title":"美观打印字符串","slug":"pretty-printing-a-string","link":"#pretty-printing-a-string","children":[]},{"level":2,"title":"数组和对象","slug":"arrays-and-objects-and-the-module-header","link":"#arrays-and-objects-and-the-module-header","children":[]},{"level":2,"title":"书写模块头","slug":"writing-a-module-header","link":"#writing-a-module-header","children":[]},{"level":2,"title":"完成美观打印库","slug":"fleshing-out-the-pretty-printing-library","link":"#fleshing-out-the-pretty-printing-library","children":[{"level":3,"title":"紧凑转换","slug":"compact-rendering","link":"#compact-rendering","children":[]},{"level":3,"title":"真正的美观打印","slug":"true-pretty-printing","link":"#true-pretty-printing","children":[]},{"level":3,"title":"理解美观打印器","slug":"following-the-pretty-printer","link":"#following-the-pretty-printer","children":[]},{"level":3,"title":"练习","slug":"练习","link":"#练习","children":[]}]},{"level":2,"title":"创建包","slug":"creating-a-package","link":"#creating-a-package","children":[{"level":3,"title":"为包添加描述","slug":"为包添加描述","link":"#为包添加描述","children":[]},{"level":3,"title":"GHC 的包管理器","slug":"ghc-的包管理器","link":"#ghc-的包管理器","children":[]},{"level":3,"title":"配置，构建和安装","slug":"配置-构建和安装","link":"#配置-构建和安装","children":[]}]},{"level":2,"title":"实用链接和扩展阅读","slug":"practical-pointers-and-further-reading","link":"#practical-pointers-and-further-reading","children":[]}],"git":{"createdTime":1708749227000,"updatedTime":1708749227000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":34.2,"words":10260},"filePathRelative":"学习/Haskell中文文档/5.md","localizedDate":"2024年2月24日","excerpt":"\\n<h2>JSON 简介</h2>\\n<p>在这一章，我们将开发一个小而完整的 Haskell 库，这个库用于处理和序列化\\nJSON 数据。</p>\\n<p>JSON （JavaScript 对象符号）是一种小型、表示简单、便于存储和发送的语言。它通常用于从 web 服务向基于浏览器的 JavaScript 程序传送数据。JSON 的格式由 <a href=\\"www.json.org\\">www.json.org</a> 描述，而细节由 <a href=\\"http://www.ietf.org/rfc/rfc4627.txt\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">RFC\\n4627</a> 补充。</p>","autoDesc":true}');export{O as comp,D as data};
