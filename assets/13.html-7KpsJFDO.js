import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as p,f as a,a as s,b as n}from"./app-Chw2KLnS.js";const o={},l=a(`<h1 id="第-13-章-数据结构" tabindex="-1"><a class="header-anchor" href="#第-13-章-数据结构"><span>第 13 章：数据结构</span></a></h1><h2 id="association-lists" tabindex="-1"><a class="header-anchor" href="#association-lists"><span>关联列表</span></a></h2><p>我们常常会跟一些以键为索引的无序数据打交道。</p><p>举个例子，UNIX 管理猿可能需要这么一个列表，它包含系统中所有用户的 UID，以及和这个 UID 相对应的用户名。这个列表根据 UID 而不是数据的位置来查找相应的用户名。换句话来说， UID 就是这个数据集的键。</p><p>Haskell 里有几种不同的方法来处理这种结构的数据，最常用的两个是关联列表（association list）和 <code>Data.Map</code> 模块提供的 <code>Map</code> 类型。</p><p>关联列表非常简单，易于使用。由于关联列表由 Haskell 列表构成，因此所有列表操作函数都可以用于处理关联列表。</p><p>另一方面， <code>Map</code> 类型在处理大数据集时，性能比关联列表要好。</p><p>本章将同时介绍这两种数据结构。</p><p>关联列表就是包含一个或多个 <code>(key, value)</code> 元组的列表， <code>key</code> 和 <code>value</code> 可以是任意类型。一个处理 UID 和用户名映射的关联列表的类型可能是 <code>[(Integer, String)]</code> 。</p><p>[注：关联列表的 <code>key</code> 必须是 <code>Eq</code> 类型的成员。]</p><p>关联列表的构建方式和普通列表一样。Haskell 提供了一个 <code>Data.List.lookup</code> 函数，用于在关联列表中查找数据。这个函数的类型签名为 <code>Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b</code> 。它的使用方式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> al <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token number">2</span>, <span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token number">3</span>, <span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token number">4</span>, <span class="token string">&quot;four&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

Prelude<span class="token operator">&gt;</span> lookup <span class="token number">1</span> al
Just <span class="token string">&quot;one&quot;</span>

Prelude<span class="token operator">&gt;</span> lookup <span class="token number">5</span> al
Nothing
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>lookup</code> 函数的定义如下：</p><p>::: literalinclude /code/ch13/lookup.hs :::</p><p><code>lookup</code> 在输入列表为空时返回 <code>Nothing</code> 。如果输入列表不为空，那么它检查当前列表元素的 <code>key</code> 是否就是我们要找的 <code>key</code> ，如果是的话就返回和这个 <code>key</code> 对应的 <code>value</code> ，否则就继续递归处理剩余的列表元素。</p><p>再来看一个稍微复杂点的例子。在 Unix/Linux 系统中，有一个 <code>/etc/passwd</code> 文件，这个文件保存了用户名称， UID，用户的 HOME 目录位置，以及其他一些数据。文件以行分割每个用户的资料，每个数据域用冒号隔开：</p><pre><code>root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
jgoerzen:x:1000:1000:John Goerzen,,,:/home/jgoerzen:/bin/bash
</code></pre><p>以下程序读入并处理 <code>/etc/passwd</code> 文件，它创建一个关联列表，使得我们可以根据给定 UID ，获取相应的用户名：</p><p>::: literalinclude /code/ch13/passwd-al.hs :::</p><p><code>findByUID</code> 是整个程序的核心，它逐行读入并处理输入，使用 <code>lookup</code> 从处理结果中查找给定 UID ：</p><pre><code>*Main&gt; findByUID &quot;root:x:0:0:root:/root:/bin/bash&quot; 0
Just &quot;root&quot;
</code></pre><p><code>parseline</code> 读入并处理一个字符串，返回一个包含 UID 和用户名的元组：</p><pre><code>*Main&gt; parseline &quot;root:x:0:0:root:/root:/bin/bash&quot;
(0,&quot;root&quot;)
</code></pre><p><code>split</code> 函数根据给定分隔符 <code>delimiter</code> 将一个文本行分割为列表：</p><pre><code>*Main&gt; split &#39;:&#39; &quot;root:x:0:0:root:/root:/bin/bash&quot;
[&quot;root&quot;,&quot;x&quot;,&quot;0&quot;,&quot;0&quot;,&quot;root&quot;,&quot;/root&quot;,&quot;/bin/bash&quot;]
</code></pre><p>以下是在本机执行 <code>passwd-al.hs</code> 处理 <code>/etc/passwd</code> 的结果：</p><pre><code>$ runghc passwd-al.hs /etc/passwd 0
root

$ runghc passwd-al.hs /etc/passwd 10086
Could not find that UID
</code></pre><h2 id="map-类型" tabindex="-1"><a class="header-anchor" href="#map-类型"><span>Map 类型</span></a></h2><p><code>Data.Map</code> 模块提供的 <code>Map</code> 类型的行为和关联列表类似，但 <code>Map</code> 类型的性能更好。</p><p><code>Map</code> 和其他语言提供的哈希表类似。不同的是， <code>Map</code> 的内部由平衡二叉树实现，在 Haskell 这种使用不可变数据的语言中，它是一个比哈希表更高效的表示。这是一个非常明显的例子，说明纯函数式语言是如何深入地影响我们编写程序的方式：对于一个给定的任务，我们总是选择合适的算法和数据结构，使得解决方案尽可能地简单和有效，但这些（纯函数式的）选择通常不同于命令式语言处理同样问题时的选择。</p><p>因为 <code>Data.Map</code> 模块的一些函数和 <code>Prelude</code> 模块的函数重名，我们通过 <code>import qualified Data.Map as Map</code> 的方式引入模块，并使用 <code>Map.name</code> 的方式引用模块中的名字。</p><p>先来看看如何用几种不同的方式构建 <code>Map</code> ：</p><p>::: literalinclude /code/ch13/buildmap.hs :::</p><p><code>Map.insert</code> 函数处理数据的方式非常『 Haskell 化』：它返回经过函数应用的输入数据的副本。这种处理数据的方式在操作多个 <code>Map</code> 时非常有用，它意味着你可以像前面代码中 <code>mapFold</code> 那样使用 <code>fold</code> 来构建一个 <code>Map</code> ，又或者像 <code>mapManual</code> 那样，串连起多个 <code>Map.insert</code> 调用。</p><p>[译注：这里说『 Haskell 化』实际上就是『函数式化』，对于函数式语言来说，最常见的函数处理方式是接受一个输入，然后返回一个输出，输出是另一个独立的值，且原输入不会被修改。]</p><p>现在，到 ghci 中验证一下是否所有定义都如我们所预期的那样工作：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude<span class="token operator">&gt;</span> :l buildmap.hs
<span class="token punctuation">[</span><span class="token number">1</span> of <span class="token number">1</span><span class="token punctuation">]</span> Compiling Main             <span class="token punctuation">(</span> buildmap.hs, interpreted <span class="token punctuation">)</span>
Ok, modules loaded: Main.

*Main<span class="token operator">&gt;</span> al
Loading package array-0.4.0.0 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
Loading package deepseq-1.3.0.0 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
Loading package containers-0.4.2.1 <span class="token punctuation">..</span>. linking <span class="token punctuation">..</span>. done.
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3</span>,<span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4</span>,<span class="token string">&quot;four&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

*Main<span class="token operator">&gt;</span> mapFromAL
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3</span>,<span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4</span>,<span class="token string">&quot;four&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

*Main<span class="token operator">&gt;</span> mapFold
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3</span>,<span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4</span>,<span class="token string">&quot;four&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

*Main<span class="token operator">&gt;</span> mapManual
fromList <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">3</span>,<span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token number">4</span>,<span class="token string">&quot;four&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意， <code>Map</code> 并不保证它的输出排列和原本的输入排列一致，对比 <code>mapManual</code> 的输入和输出可以看出这一点。</p><p><code>Map</code> 的操作方式和关联列表类似。 <code>Data.Map</code> 模块提供了一组函数，用于增删 <code>Map</code> 元素，对 <code>Map</code> 进行过滤、修改和 fold ，以及在 <code>Map</code> 和关联列表之间进行转换。 <code>Data.Map</code> 模块本身的文档非常优秀，因此我们在这里不会详细讲解每个函数，而是在本章的后续内容中，通过例子来介绍这些概念。</p><h2 id="函数也是数据" tabindex="-1"><a class="header-anchor" href="#函数也是数据"><span>函数也是数据</span></a></h2><p>Haskell 语言的威力部分在于它可以让我们方便地创建并操作函数。</p><p>以下示例展示了怎样将函数保存到记录的域中：</p><p>::: literalinclude /code/ch13/funcrecs.hs :::</p><p>注意 <code>colorCalc</code> 域的类型：它是一个函数，接受一个 <code>Int</code> 类型值作为参数，并返回一个 <code>(CustomColor, Int)</code> 元组。</p><p>我们创建了两个 <code>FuncRec</code> 记录： <code>plus5</code> 和 <code>always0</code> ，这两个记录的 <code>colorCalc</code> 域都总是返回紫色（purple）。 <code>FuncRec</code> 自身并没有域去保存所使用的颜色，颜色的值被保存在函数当中 ------ 我们称这种用法为<em>闭包</em>。</p><p>以下是示例代码：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>*Main<span class="token operator">&gt;</span> :l funcrecs.hs
<span class="token punctuation">[</span><span class="token number">1</span> of <span class="token number">1</span><span class="token punctuation">]</span> Compiling Main             <span class="token punctuation">(</span> funcrecs.hs, interpreted <span class="token punctuation">)</span>
Ok, modules loaded: Main.

*Main<span class="token operator">&gt;</span> :t plus5
plus5 :: FuncRec

*Main<span class="token operator">&gt;</span> name plus5
<span class="token string">&quot;plus5&quot;</span>

*Main<span class="token operator">&gt;</span> :t colorCalc plus5
colorCalc plus5 :: Int -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>CustomColor, Int<span class="token punctuation">)</span>

*Main<span class="token operator">&gt;</span> <span class="token punctuation">(</span>colorCalc plus5<span class="token punctuation">)</span> <span class="token number">7</span>
<span class="token punctuation">(</span>CustomColor <span class="token punctuation">{</span>red <span class="token operator">=</span> <span class="token number">255</span>, green <span class="token operator">=</span> <span class="token number">0</span>, blue <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">}</span>,12<span class="token punctuation">)</span>

*Main<span class="token operator">&gt;</span> :t colorCalc always0
colorCalc always0 :: Int -<span class="token operator">&gt;</span> <span class="token punctuation">(</span>CustomColor, Int<span class="token punctuation">)</span>

*Main<span class="token operator">&gt;</span> <span class="token punctuation">(</span>colorCalc always0<span class="token punctuation">)</span> <span class="token number">7</span>
<span class="token punctuation">(</span>CustomColor <span class="token punctuation">{</span>red <span class="token operator">=</span> <span class="token number">255</span>, green <span class="token operator">=</span> <span class="token number">0</span>, blue <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">}</span>,0<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的程序工作得很好，但我们还想做一些更有趣的事，比如说，在多个域中使用同一段数据。可以使用一个类型构造函数来做到这一点：</p><p>::: literalinclude /code/ch13/funcrecs2.hs :::</p><p><code>mkFuncRecs</code> 函数接受一个字符串和一个函数作为参数，返回一个新的 <code>FuncRec</code> 记录。以下是对 <code>mkFuncRecs</code> 函数的测试：</p><pre><code>*Main&gt; :l funcrecs2.hs
[1 of 1] Compiling Main             ( funcrecs2.hs, interpreted )
Ok, modules loaded: Main.

*Main&gt; :t plus5
plus5 :: FuncRec

*Main&gt; name plus5
&quot;plus5&quot;

*Main&gt; (calc plus5) 5
10

*Main&gt; (namedCalc plus5) 5
(&quot;plus5&quot;,10)

*Main&gt; let plus5a = plus5 {name = &quot;PLUS5A&quot;}

*Main&gt; name plus5a
&quot;PLUS5A&quot;

*Main&gt; (namedCalc plus5a) 5
(&quot;plus5&quot;,10)
</code></pre><p>注意 <code>plus5a</code> 的创建过程：我们改变了 <code>plus5</code> 的 <code>name</code> 域，但没有修改它的 <code>namedCalc</code> 域。这就是为什么调用 <code>name</code> 会返回新名字，而 <code>namedCalc</code> 依然返回原本使用 <code>mkFuncRecs</code> 创建时设置的名字 ------ 除非我们显式地修改域，否则它们不会被改变。</p><h2 id="扩展示例-etc-password" tabindex="-1"><a class="header-anchor" href="#扩展示例-etc-password"><span>扩展示例： /etc/password</span></a></h2><p>以下是一个扩展示例，它展示了几种不同的数据结构的用法，根据 <code>/etc/passwd</code> 文件的格式，程序处理并保存它的实体（entry）：</p><p>::: literalinclude /code/ch13/passwdmap.hs :::</p><p>示例程序维持两个 <code>Map</code> ：一个从用户名映射到 <code>PasswdEntry</code> ，另一个从 UID 映射到 <code>PasswdEntry</code> 。有数据库使用经验的人可以将它们看作是两个不同数据域的索引。</p><p>根据 <code>/etc/passwd</code> 文件的格式， <code>PasswdEntry</code> 的 <code>Show</code> 和 <code>Read</code> 实例分别用于显示（display）和处理（parse）工作。</p><h2 id="extended-example-numeric-types" tabindex="-1"><a class="header-anchor" href="#extended-example-numeric-types"><span>扩展示例：数字类型（Numeric Types）</span></a></h2><p>我们已经讲过 Haskell 的类型系统有多强大，表达能力有多强。我们已经讲过很多利用这种能力的方法。现在我们来举一个实际的例子看看。</p>`,59),c=s("p",null,[n("在 "),s("code",{class:"interpreted-text",role:"ref"},"numeric-types"),n(" 一节中，我们展示了 Haskell 的数字类型类。现在，我们来定义一些类，然后用数字类型类把它们和 Haskell 的基本数学结合起来，看看能得到什么。")],-1),i=a(`<p>我们先来想想我们想用这些新类型在 <strong>ghci</strong> 里干什么。首先，一个不错的选择是把数学表达式转成字符串，并确保它显示了正确的优先级。我们可以写一个 <code>prettyShow</code> 函数来实现。稍后我们就告诉你怎么写，先来看看怎么用它。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :l num.hs
<span class="token punctuation">[</span><span class="token number">1</span> of <span class="token number">1</span><span class="token punctuation">]</span> Compiling Main             <span class="token punctuation">(</span> num.hs, interpreted <span class="token punctuation">)</span>
Ok, modules loaded: Main.
ghci<span class="token operator">&gt;</span> <span class="token number">5</span> + <span class="token number">1</span> * <span class="token number">3</span>
<span class="token number">8</span>
ghci<span class="token operator">&gt;</span> prettyShow $ <span class="token number">5</span> + <span class="token number">1</span> * <span class="token number">3</span>
<span class="token string">&quot;5+(1*3)&quot;</span>
ghci<span class="token operator">&gt;</span> prettyShow $ <span class="token number">5</span> * <span class="token number">1</span> + <span class="token number">3</span>
<span class="token string">&quot;(5*1)+3&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看起来不错，但还不够聪明。我们可以很容易地把 <code>1 *</code> 从表达式里拿掉。写个函数来简化怎么样？</p><pre><code>ghci&gt; prettyShow $ simplify $ 5 + 1 * 3
&quot;5+3&quot;
</code></pre><p>把数学表达式转成逆波兰表达式（RPN）怎么样？RPN 是一种后缀表示法，它不要求括号，常见于 HP 计算器。 RPN 是一种基于栈的表达式。我们把数字放进栈里，当碰到操作符时，栈顶的数字出栈，结果再被放回栈里。</p><pre><code>ghci&gt; rpnShow $ 5 + 1 * 3
&quot;5 1 3 * +&quot;
ghci&gt; rpnShow $ simplify $ 5 + 1 * 3
&quot;5 3 +&quot;
</code></pre><p>能表示含有未知符号的简单表达式也很不错。</p><pre><code>ghci&gt; prettyShow $ 5 + (Symbol &quot;x&quot;) * 3
&quot;5+(x*3)&quot;
</code></pre><p>跟数字打交道时，单位常常很重要。例如，当你看见数字5时，它是5米，5英尺，还是5字节？当然，当你用5米除以2秒时，系统应该推出来正确的单位。而且，它应该阻止你用2秒加上5米。</p><pre><code>ghci&gt; 5 / 2
2.5
ghci&gt; (units 5 &quot;m&quot;) / (units 2 &quot;s&quot;)
2.5_m/s
ghci&gt; (units 5 &quot;m&quot;) + (units 2 &quot;s&quot;)
*** Exception: Mis-matched units in add
ghci&gt; (units 5 &quot;m&quot;) + (units 2 &quot;m&quot;)
7_m
ghci&gt; (units 5 &quot;m&quot;) / 2
2.5_m
ghci&gt; 10 * (units 5 &quot;m&quot;) / (units 2 &quot;s&quot;)
25.0_m/s
</code></pre><p>如果我们定义的表达式或函数对所有数字都合法，那我们就应该能计算出结果，或者把表达式转成字符串。例如，如果我们定义 <code>test</code> 的类型为 <code>Num a =&gt; a</code>，并令 <code>test = 2 * 5 + 3</code>，那我们应该可以：</p><pre><code>ghci&gt; test
13
ghci&gt; rpnShow test
&quot;2 5 * 3 +&quot;
ghci&gt; prettyShow test
&quot;(2*5)+3&quot;
ghci&gt; test + 5
18
ghci&gt; prettyShow (test + 5)
&quot;((2*5)+3)+5&quot;
ghci&gt; rpnShow (test + 5)
&quot;2 5 * 3 + 5 +&quot;
</code></pre><p>既然我们能处理单位，那我们也应该能处理一些基本的三角函数，其中很多操作都是关于角的。让我们确保角度和弧度都能被处理。</p><pre><code>ghci&gt; sin (pi / 2)
1.0
ghci&gt; sin (units (pi / 2) &quot;rad&quot;)
1.0_1.0
ghci&gt; sin (units 90 &quot;deg&quot;)
1.0_1.0
ghci&gt; (units 50 &quot;m&quot;) * sin (units 90 &quot;deg&quot;)
50.0_m
</code></pre><p>最后，我们应该能把这些都放在一起，把不同类型的表达式混合使用。</p><pre><code>ghci&gt; ((units 50 &quot;m&quot;) * sin (units 90 &quot;deg&quot;)) :: Units (SymbolicManip Double)
50.0*sin(((2.0*pi)*90.0)/360.0)_m
ghci&gt; prettyShow $ dropUnits $ (units 50 &quot;m&quot;) * sin (units 90 &quot;deg&quot;)
&quot;50.0*sin(((2.0*pi)*90.0)/360.0)&quot;
ghci&gt; rpnShow $ dropUnits $ (units 50 &quot;m&quot;) * sin (units 90 &quot;deg&quot;)
&quot;50.0 2.0 pi * 90.0 * 360.0 / sin *&quot;
ghci&gt; (units (Symbol &quot;x&quot;) &quot;m&quot;) * sin (units 90 &quot;deg&quot;)
x*sin(((2.0*pi)*90.0)/360.0)_m
</code></pre><p>你刚才看到的一切都可以用 Haskell 的类型和类型类实现。实际上，你看到的正是我们马上要实现的 <code>num.hs</code>。</p><h3 id="first-steps" tabindex="-1"><a class="header-anchor" href="#first-steps"><span>第一步</span></a></h3><p>我们想想怎么实现上面提到的功能。首先，用 <strong>ghci</strong> 查看一下可知，<code>(+)</code> 的类型是 <code>Num a =&gt; a -&gt; a -&gt; a</code>。 如果我们想给加号实现一些自定义行为，我们就必须定义一个新类型并声明它为 <code>Num</code> 的实例。这个类型得用符号的形式来存储表达式。我们可以从加法操作开始。我们需要存储操作符本身、左侧以及右侧内容。左侧和右侧内容本身又可以是表达式。</p><p>我们可以把表达式想象成一棵树。让我们从一些简单类型开始。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/numsimple.hs</span>
<span class="token comment">-- 我们支持的操作符</span>
<span class="token keyword">data</span> <span class="token constant">Op</span> <span class="token operator">=</span> <span class="token constant">Plus</span> <span class="token operator">|</span> <span class="token constant">Minus</span> <span class="token operator">|</span> <span class="token constant">Mul</span> <span class="token operator">|</span> <span class="token constant">Div</span> <span class="token operator">|</span> <span class="token constant">Pow</span>
        <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>

<span class="token comment">{- 核心符号操作类型（core symbolic manipulation type） -}</span>
<span class="token keyword">data</span> <span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span> <span class="token operator">=</span>
          <span class="token constant">Number</span> <span class="token hvariable">a</span>           <span class="token comment">-- Simple number, such as 5</span>
        <span class="token operator">|</span> <span class="token constant">Arith</span> <span class="token constant">Op</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
          <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>

<span class="token comment">{- SymbolicManip 是 Num 的实例。定义 SymbolicManip 实现 Num 的函数。如(+)等。 -}</span>
<span class="token keyword">instance</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">Num</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Arith</span> <span class="token constant">Plus</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token hvariable">a</span> <span class="token operator">-</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Arith</span> <span class="token constant">Minus</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Arith</span> <span class="token constant">Mul</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token builtin">negate</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Arith</span> <span class="token constant">Mul</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">a</span>
    <span class="token builtin">abs</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;abs is unimplemented&quot;</span>
    <span class="token builtin">signum</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;signum is unimplemented&quot;</span>
    <span class="token builtin">fromInteger</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token constant">Number</span> <span class="token punctuation">(</span><span class="token builtin">fromInteger</span> <span class="token hvariable">i</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们定义了 <code>Op</code> 类型。这个类型表示我们要支持的操作。接着，我们定义了 <code>SymbolicManip a</code>， 由于 <code>Num a</code> 约束的存在，<code>a</code> 可替换为任何 <code>Num</code> 实例。我们可以有 <code>SymbolicManip Int</code> 这样的具体类型。</p><p><code>SymbolicManip</code> 类型可以是数字，也可以是数学运算。<code>Arith</code> 构造器是递归的，这在 Haskell 里完全合法。 <code>Arith</code> 用一个 <code>Op</code> 和两个 <code>SymbolicManip</code> 创建了一个 <code>SymbolicManip</code>。我们来看一个例子：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token constant">Prelude</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">l</span> <span class="token hvariable">numsimple</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">of</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token constant">Compiling</span> <span class="token constant">Main</span>             <span class="token punctuation">(</span> <span class="token hvariable">numsimple</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token punctuation">,</span> <span class="token hvariable">interpreted</span> <span class="token punctuation">)</span>
<span class="token constant">Ok</span><span class="token punctuation">,</span> <span class="token hvariable">modules</span> <span class="token hvariable">loaded</span><span class="token operator">:</span> <span class="token constant">Main</span><span class="token punctuation">.</span>
<span class="token operator">*</span><span class="token constant">Main</span><span class="token operator">&gt;</span> <span class="token constant">Number</span> <span class="token number">5</span>
<span class="token constant">Number</span> <span class="token number">5</span>
<span class="token operator">*</span><span class="token constant">Main</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Number</span> <span class="token number">5</span>
<span class="token constant">Number</span> <span class="token number">5</span> <span class="token operator">::</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span>
<span class="token operator">*</span><span class="token constant">Main</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Number</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">::</span><span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token constant">Number</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">::</span><span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">SymbolicManip</span> <span class="token constant">Int</span>
<span class="token operator">*</span><span class="token constant">Main</span><span class="token operator">&gt;</span> <span class="token constant">Number</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token constant">Number</span> <span class="token number">10</span>
<span class="token constant">Arith</span> <span class="token constant">Mul</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token operator">*</span><span class="token constant">Main</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">::</span><span class="token constant">SymbolicManip</span> <span class="token constant">Int</span>
<span class="token constant">Arith</span> <span class="token constant">Mul</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token operator">*</span><span class="token constant">Main</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">::</span><span class="token constant">SymbolicManip</span> <span class="token constant">Int</span>
<span class="token constant">Arith</span> <span class="token constant">Plus</span> <span class="token punctuation">(</span><span class="token constant">Arith</span> <span class="token constant">Mul</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">2</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，我们已经可以表示一些简单的表达式了。注意观察 Haskell 是如何把 <code>5 * 10 + 2</code> &quot;转换&quot;成 <code>SymbolicManip</code> 值的，它甚至还正确处理了求值顺序。事实上，这并不是真正意义上的转换，因为 <code>SymbolicManip</code> 已经是一等数字（first-class number）了。 就算 <code>Integer</code> 类型的数字字面量（numeric literals）在内部也是被包装在 <code>fromInteger</code> 里的， 所以 <code>5</code> 作为一个 <code>SymbolicManip Int</code> 和作为一个 <code>Int</code> 同样有效。</p><p>从这儿开始，我们的任务就简单了：扩展 <code>SymbolicManip</code>，使它能表示所有我们想要的操作；把它声明为其它数字类型类的实例；为 <code>SymbolicManip</code> 实现我们自己的 <code>Show</code> 实例，使这棵树在显示时更友好。</p><h3 id="completed-code" tabindex="-1"><a class="header-anchor" href="#completed-code"><span>完整代码</span></a></h3><p>这里是完整的 <code>num.hs</code>，我们在本节开始的 <strong>ghci</strong> 例子中用到了它。我们来一点一点分析这段代码。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token operator">--------------------------------------------------</span>
<span class="token comment">-- Symbolic/units manipulation</span>
<span class="token operator">--------------------------------------------------</span>

<span class="token comment">-- The &quot;operators&quot; that we&#39;re going to support</span>
<span class="token keyword">data</span> <span class="token constant">Op</span> <span class="token operator">=</span> <span class="token constant">Plus</span> <span class="token operator">|</span> <span class="token constant">Minus</span> <span class="token operator">|</span> <span class="token constant">Mul</span> <span class="token operator">|</span> <span class="token constant">Div</span> <span class="token operator">|</span> <span class="token constant">Pow</span>
        <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>

<span class="token comment">{- The core symbolic manipulation type.  It can be a simple number,
a symbol, a binary arithmetic operation (such as +), or a unary
arithmetic operation (such as cos)

Notice the types of BinaryArith and UnaryArith: it&#39;s a recursive
type.  So, we could represent a (+) over two SymbolicManips. -}</span>
<span class="token keyword">data</span> <span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span> <span class="token operator">=</span>
        <span class="token constant">Number</span> <span class="token hvariable">a</span>           <span class="token comment">-- Simple number, such as 5</span>
      <span class="token operator">|</span> <span class="token constant">Symbol</span> <span class="token constant">String</span>      <span class="token comment">-- A symbol, such as x</span>
      <span class="token operator">|</span> <span class="token constant">BinaryArith</span> <span class="token constant">Op</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
      <span class="token operator">|</span> <span class="token constant">UnaryArith</span> <span class="token constant">String</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
        <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在这段代码中定义了 <code>Op</code>，和之前我们用到的一样。我们也定义了 <code>SymbolicManip</code>，它和我们之前用到的类似。在这个版本中，我们开始支持一元数学操作（unary arithmetic operations）（也就是接受一个参数的操作）， 例如 <code>abs</code> 和 <code>cos</code>。接下来我们来定义自己的 <code>Num</code> 实例。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- SymbolicManip will be an instance of Num.  Define how the Num
operations are handled over a SymbolicManip.  This will implement things
like (+) for SymbolicManip. -}</span>
<span class="token keyword">instance</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">Num</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">BinaryArith</span> <span class="token constant">Plus</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token hvariable">a</span> <span class="token operator">-</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">BinaryArith</span> <span class="token constant">Minus</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">BinaryArith</span> <span class="token constant">Mul</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token builtin">negate</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">BinaryArith</span> <span class="token constant">Mul</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">a</span>
    <span class="token builtin">abs</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;abs&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">signum</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;signum is unimplemented&quot;</span>
    <span class="token builtin">fromInteger</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token constant">Number</span> <span class="token punctuation">(</span><span class="token builtin">fromInteger</span> <span class="token hvariable">i</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>非常直观，和之前的代码很像。注意之前我们不支持 <code>abs</code>，但现在可以了，因为有了 <code>UnaryArith</code>。接下来，我们再定义几个实例。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- 定义 SymbolicManip 为 Fractional 实例 -}</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Fractional</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Fractional</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">a</span> <span class="token operator">/</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">BinaryArith</span> <span class="token constant">Div</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token builtin">recip</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">BinaryArith</span> <span class="token constant">Div</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">a</span>
    <span class="token builtin">fromRational</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token constant">Number</span> <span class="token punctuation">(</span><span class="token builtin">fromRational</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>

<span class="token comment">{- 定义 SymbolicManip 为 Floating 实例 -}</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Floating</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Floating</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">pi</span> <span class="token operator">=</span> <span class="token constant">Symbol</span> <span class="token string">&quot;pi&quot;</span>
    <span class="token builtin">exp</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;exp&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">log</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;log&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">sqrt</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;sqrt&quot;</span> <span class="token hvariable">a</span>
    <span class="token hvariable">a</span> <span class="token operator">**</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">BinaryArith</span> <span class="token constant">Pow</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token builtin">sin</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;sin&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">cos</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;cos&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">tan</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;tan&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">asin</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;asin&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">acos</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;acos&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">atan</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;atan&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">sinh</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;sinh&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">cosh</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;cosh&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">tanh</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;tanh&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">asinh</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;asinh&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">acosh</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;acosh&quot;</span> <span class="token hvariable">a</span>
    <span class="token builtin">atanh</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token string">&quot;atanh&quot;</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码直观地定义了 <code>Fractional</code> 和 <code>Floating</code> 实例。接下来，我们把表达式转换字符串。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- 使用常规代数表示法，把 SymbolicManip 转换为字符串 -}</span>
<span class="token hvariable">prettyShow</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>

<span class="token comment">-- 显示字符或符号</span>
<span class="token hvariable">prettyShow</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">show</span> <span class="token hvariable">x</span>
<span class="token hvariable">prettyShow</span> <span class="token punctuation">(</span><span class="token constant">Symbol</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token hvariable">prettyShow</span> <span class="token punctuation">(</span><span class="token constant">BinaryArith</span> <span class="token hvariable">op</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">pa</span> <span class="token operator">=</span> <span class="token hvariable">simpleParen</span> <span class="token hvariable">a</span>
        <span class="token hvariable">pb</span> <span class="token operator">=</span> <span class="token hvariable">simpleParen</span> <span class="token hvariable">b</span>
        <span class="token hvariable">pop</span> <span class="token operator">=</span> <span class="token hvariable">op2str</span> <span class="token hvariable">op</span>
        <span class="token keyword">in</span> <span class="token hvariable">pa</span> <span class="token operator">++</span> <span class="token hvariable">pop</span> <span class="token operator">++</span> <span class="token hvariable">pb</span>
<span class="token hvariable">prettyShow</span> <span class="token punctuation">(</span><span class="token constant">UnaryArith</span> <span class="token hvariable">opstr</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token hvariable">opstr</span> <span class="token operator">++</span> <span class="token string">&quot;(&quot;</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">&quot;)&quot;</span>

<span class="token hvariable">op2str</span> <span class="token operator">::</span> <span class="token constant">Op</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">op2str</span> <span class="token constant">Plus</span> <span class="token operator">=</span> <span class="token string">&quot;+&quot;</span>
<span class="token hvariable">op2str</span> <span class="token constant">Minus</span> <span class="token operator">=</span> <span class="token string">&quot;-&quot;</span>
<span class="token hvariable">op2str</span> <span class="token constant">Mul</span> <span class="token operator">=</span> <span class="token string">&quot;*&quot;</span>
<span class="token hvariable">op2str</span> <span class="token constant">Div</span> <span class="token operator">=</span> <span class="token string">&quot;/&quot;</span>
<span class="token hvariable">op2str</span> <span class="token constant">Pow</span> <span class="token operator">=</span> <span class="token string">&quot;**&quot;</span>

<span class="token comment">{- 在需要的地方添加括号。这个函数比较保守，有时候不需要也会加。
Haskell 在构建 SymbolicManip 的时候已经处理好优先级了。-}</span>
<span class="token hvariable">simpleParen</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">simpleParen</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">prettyShow</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token hvariable">simpleParen</span> <span class="token punctuation">(</span><span class="token constant">Symbol</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">prettyShow</span> <span class="token punctuation">(</span><span class="token constant">Symbol</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token hvariable">simpleParen</span> <span class="token hvariable">x</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token constant">BinaryArith</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;(&quot;</span> <span class="token operator">++</span> <span class="token hvariable">prettyShow</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">&quot;)&quot;</span>
<span class="token hvariable">simpleParen</span> <span class="token hvariable">x</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token constant">UnaryArith</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">prettyShow</span> <span class="token hvariable">x</span>

<span class="token comment">{- 调用 prettyShow 函数显示 SymbolicManip 值 -}</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Show</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">prettyShow</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们定义了 <code>prettyShow</code> 函数。它把一个表达式转换成常规表达形式。算法相当简单：数字和符号不做处理；二元操作是转换后两侧的内容加上中间的操作符；当然我们也处理了一元操作。<code>op2str</code> 把 <code>Op</code> 转为 <code>String</code>。在 <code>simpleParen</code> 里，我们加括号的算法非常保守，以确保优先级在结果里清楚显示。最后，我们声明 <code>SymbolicManip</code> 为 <code>Show</code> 的实例然后用 <code>prettyShow</code> 来实现。 现在，我们来设计一个算法把表达式转为 RPN 形式的字符串。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- Show a SymbolicManip using RPN.  HP calculator users may
find this familiar. -}</span>
<span class="token hvariable">rpnShow</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">rpnShow</span> <span class="token hvariable">i</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">toList</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
        <span class="token hvariable">toList</span> <span class="token punctuation">(</span><span class="token constant">Symbol</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
        <span class="token hvariable">toList</span> <span class="token punctuation">(</span><span class="token constant">BinaryArith</span> <span class="token hvariable">op</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">toList</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token hvariable">toList</span> <span class="token hvariable">b</span> <span class="token operator">++</span>
            <span class="token punctuation">[</span><span class="token hvariable">op2str</span> <span class="token hvariable">op</span><span class="token punctuation">]</span>
        <span class="token hvariable">toList</span> <span class="token punctuation">(</span><span class="token constant">UnaryArith</span> <span class="token hvariable">op</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">toList</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">op</span><span class="token punctuation">]</span>
        <span class="token hvariable">join</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
        <span class="token hvariable">join</span> <span class="token hvariable">delim</span> <span class="token hvariable">l</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token hvariable">intersperse</span> <span class="token hvariable">delim</span> <span class="token hvariable">l</span><span class="token punctuation">)</span>
    <span class="token keyword">in</span> <span class="token hvariable">join</span> <span class="token string">&quot; &quot;</span> <span class="token punctuation">(</span><span class="token hvariable">toList</span> <span class="token hvariable">i</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RPN 爱好者会发现，跟上面的算法相比，这个算法是多么简洁。尤其是，我们根本不用关心要从哪里加括号，因为 RPN 天生只能沿着一个方向求值。接下来，我们写个函数来实现一些基本的表达式化简。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- Perform some basic algebraic simplifications on a SymbolicManip. -}</span>
<span class="token hvariable">simplify</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span>
<span class="token hvariable">simplify</span> <span class="token punctuation">(</span><span class="token constant">BinaryArith</span> <span class="token hvariable">op</span> <span class="token hvariable">ia</span> <span class="token hvariable">ib</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">sa</span> <span class="token operator">=</span> <span class="token hvariable">simplify</span> <span class="token hvariable">ia</span>
        <span class="token hvariable">sb</span> <span class="token operator">=</span> <span class="token hvariable">simplify</span> <span class="token hvariable">ib</span>
        <span class="token keyword">in</span>
        <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token hvariable">op</span><span class="token punctuation">,</span> <span class="token hvariable">sa</span><span class="token punctuation">,</span> <span class="token hvariable">sb</span><span class="token punctuation">)</span> <span class="token keyword">of</span>
                <span class="token punctuation">(</span><span class="token constant">Mul</span><span class="token punctuation">,</span> <span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
                <span class="token punctuation">(</span><span class="token constant">Mul</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
                <span class="token punctuation">(</span><span class="token constant">Mul</span><span class="token punctuation">,</span> <span class="token constant">Number</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Number</span> <span class="token number">0</span>
                <span class="token punctuation">(</span><span class="token constant">Mul</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Number</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Number</span> <span class="token number">0</span>
                <span class="token punctuation">(</span><span class="token constant">Div</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
                <span class="token punctuation">(</span><span class="token constant">Plus</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Number</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
                <span class="token punctuation">(</span><span class="token constant">Plus</span><span class="token punctuation">,</span> <span class="token constant">Number</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
                <span class="token punctuation">(</span><span class="token constant">Minus</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Number</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
                <span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token constant">BinaryArith</span> <span class="token hvariable">op</span> <span class="token hvariable">sa</span> <span class="token hvariable">sb</span>
<span class="token hvariable">simplify</span> <span class="token punctuation">(</span><span class="token constant">UnaryArith</span> <span class="token hvariable">op</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">UnaryArith</span> <span class="token hvariable">op</span> <span class="token punctuation">(</span><span class="token hvariable">simplify</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">simplify</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数相当简单。我们很轻易地就能化简某些二元数学运算------例如，用1乘以任何值。我们首先得到操作符两侧操作数被化简之后的版本（在这儿用到了递归）然后再化简结果。对于一元操作符我们能做的不多，所以我们仅仅简化它们作用于的表达式。</p><p>从现在开始，我们会增加对计量单位的支持。增加之后我们就能表示&quot;5米&quot;这种数量了。跟之前一样，我们先来定义一个类型：</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- 新数据类型：Units。Units 类型包含一个数字和一个 SymbolicManip，也就是计量单位。
计量单位符号可以是 (Symbol &quot;m&quot;) 这个样子。 -}</span>
<span class="token keyword">data</span> <span class="token constant">Units</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">SymbolicManip</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
             <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个 <code>Units</code> 值包含一个数字和一个符号。符号本身是 <code>SymbolicManip</code> 类型。接下来，将 <code>Units</code> 声明为 <code>Num</code> 实例。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- 为 Units 实现 Num 实例。我们不知道如何转换任意单位，因此当不同单位的数字相加时，我们报告错误。
对于乘法，我们生成对应的新单位。 -}</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Num</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xb</span> <span class="token hvariable">ub</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token hvariable">ub</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token hvariable">xa</span> <span class="token operator">+</span> <span class="token hvariable">xb</span><span class="token punctuation">)</span> <span class="token hvariable">ua</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;Mis-matched units in add or subtract&quot;</span>
    <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xb</span> <span class="token hvariable">ub</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token hvariable">xb</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">ub</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xb</span> <span class="token hvariable">ub</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token hvariable">xa</span> <span class="token operator">*</span> <span class="token hvariable">xb</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">ua</span> <span class="token operator">*</span> <span class="token hvariable">ub</span><span class="token punctuation">)</span>
    <span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">negate</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token hvariable">ua</span>
    <span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token hvariable">ua</span>
    <span class="token builtin">signum</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">signum</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token builtin">fromInteger</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">fromInteger</span> <span class="token hvariable">i</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们应该清楚为什么要用 <code>SymbolicManip</code> 而不是 <code>String</code> 来存储计量单位了。做乘法时，计量单位也会发生改变。例如，5米乘以2米会得到10平方米。我们要求加法运算的单位必须匹配，并用加法实现了减法。我们再来看几个 <code>Units</code> 的类型类实例。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- Make Units an instance of Fractional -}</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Fractional</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Fractional</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xb</span> <span class="token hvariable">ub</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token hvariable">xa</span> <span class="token operator">/</span> <span class="token hvariable">xb</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">ua</span> <span class="token operator">/</span> <span class="token hvariable">ub</span><span class="token punctuation">)</span>
    <span class="token builtin">recip</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token hvariable">a</span>
    <span class="token builtin">fromRational</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">fromRational</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token comment">{- Floating implementation for Units.

Use some intelligence for angle calculations: support deg and rad
-}</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Floating</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Floating</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">pi</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token builtin">pi</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token builtin">exp</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;exp not yet implemented in Units&quot;</span>
    <span class="token builtin">log</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;log not yet implemented in Units&quot;</span>
    <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xb</span> <span class="token hvariable">ub</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ub</span> <span class="token operator">==</span> <span class="token constant">Number</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token hvariable">xa</span> <span class="token operator">**</span> <span class="token hvariable">xb</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">ua</span> <span class="token operator">**</span> <span class="token constant">Number</span> <span class="token hvariable">xb</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;units for RHS of ** not supported&quot;</span>
    <span class="token builtin">sqrt</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">sqrt</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">sqrt</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span>
    <span class="token builtin">sin</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Symbol</span> <span class="token string">&quot;rad&quot;</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">sin</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Symbol</span> <span class="token string">&quot;deg&quot;</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">sin</span> <span class="token punctuation">(</span><span class="token hvariable">deg2rad</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;Units for sin must be deg or rad&quot;</span>
    <span class="token builtin">cos</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Symbol</span> <span class="token string">&quot;rad&quot;</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">cos</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Symbol</span> <span class="token string">&quot;deg&quot;</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">cos</span> <span class="token punctuation">(</span><span class="token hvariable">deg2rad</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;Units for cos must be deg or rad&quot;</span>
    <span class="token builtin">tan</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Symbol</span> <span class="token string">&quot;rad&quot;</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">tan</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Symbol</span> <span class="token string">&quot;deg&quot;</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token builtin">tan</span> <span class="token punctuation">(</span><span class="token hvariable">deg2rad</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Number</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;Units for tan must be deg or rad&quot;</span>
    <span class="token builtin">asin</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Number</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token hvariable">rad2deg</span> <span class="token operator">$</span> <span class="token builtin">asin</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Symbol</span> <span class="token string">&quot;deg&quot;</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;Units for asin must be empty&quot;</span>
    <span class="token builtin">acos</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Number</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token hvariable">rad2deg</span> <span class="token operator">$</span> <span class="token builtin">acos</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Symbol</span> <span class="token string">&quot;deg&quot;</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;Units for acos must be empty&quot;</span>
    <span class="token builtin">atan</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token hvariable">ua</span> <span class="token operator">==</span> <span class="token constant">Number</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token punctuation">(</span><span class="token hvariable">rad2deg</span> <span class="token operator">$</span> <span class="token builtin">atan</span> <span class="token hvariable">xa</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Symbol</span> <span class="token string">&quot;deg&quot;</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;Units for atan must be empty&quot;</span>
    <span class="token builtin">sinh</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;sinh not yet implemented in Units&quot;</span>
    <span class="token builtin">cosh</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;cosh not yet implemented in Units&quot;</span>
    <span class="token builtin">tanh</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;tanh not yet implemented in Units&quot;</span>
    <span class="token builtin">asinh</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;asinh not yet implemented in Units&quot;</span>
    <span class="token builtin">acosh</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;acosh not yet implemented in Units&quot;</span>
    <span class="token builtin">atanh</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;atanh not yet implemented in Units&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然没有实现所有函数，但大部分都定义了。现在我们来定义几个跟单位打交道的工具函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- A simple function that takes a number and a String and returns an
appropriate Units type to represent the number and its unit of measure -}</span>
<span class="token hvariable">units</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">z</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Units</span> <span class="token hvariable">z</span>
<span class="token hvariable">units</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Units</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Symbol</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>

<span class="token comment">{- Extract the number only out of a Units type -}</span>
<span class="token hvariable">dropUnits</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Units</span> <span class="token hvariable">z</span> <span class="token operator">-&gt;</span> <span class="token hvariable">z</span>
<span class="token hvariable">dropUnits</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">x</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token comment">{- Utilities for the Unit implementation -}</span>
<span class="token hvariable">deg2rad</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">x</span> <span class="token operator">/</span> <span class="token number">360</span>
<span class="token hvariable">rad2deg</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token number">360</span> <span class="token operator">*</span> <span class="token hvariable">x</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们定义了 <code>units</code>，使表达式更简洁。<code>units 5 &quot;m&quot;</code> 肯定要比 <code>Units 5 (Symbol &quot;m&quot;)</code> 省事。 我们还定义了 <code>dropUnits</code>，它把单位去掉只返回 <code>Num</code>。最后，我们定义了两个函数，用来在角度和弧度之间转换。接下来，我们给 <code>Units</code> 定义 <code>Show</code> 实例。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token comment">{- Showing units: we show the numeric component, an underscore,
then the prettyShow version of the simplified units -}</span>
<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Show</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token constant">Units</span> <span class="token hvariable">xa</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">show</span> <span class="token hvariable">xa</span> <span class="token operator">++</span> <span class="token string">&quot;_&quot;</span> <span class="token operator">++</span> <span class="token hvariable">prettyShow</span> <span class="token punctuation">(</span><span class="token hvariable">simplify</span> <span class="token hvariable">ua</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很简单。最后我们定义 <code>test</code> 变量用来测试。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/num.hs</span>
<span class="token hvariable">test</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">test</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>回头看看这些代码，我们已经完成了既定目标：给 <code>SymbolicManip</code> 实现更多实例； 我们引入了新类型 <code>Units</code>，它包含一个数字和一个单位；我们实现了几个 show 函数，以便用不同的方式来转换 <code>SymbolicManip</code> 和 <code>Units</code>。</p><p>这个例子还给了我们另外一点启发。所有语言------即使那些包含对象和重载的------都有从某种角度看很独特的地方。在 Haskell 里，这个&quot;特殊&quot;的部分很小。我们刚刚开发了一种新的表示法用来表示像数字一样基本的东西，而且很容易就实现了。我们的新类型是一等类型，编译器在编译时就知道使用它哪个函数。Haskell 把代码复用和互换（interchangeability）发挥到了极致。写通用代码很容易，而且很方便就能把它们用于多种不同类型的东西上。同样容易的是创建新类型并使它们自动成为系统的一等功能（first-class features）。</p><p>还记得本节开头的 <strong>ghci</strong> 例子吗？我们已经实现了它的全部功能。你可以自己试试，看看它们是怎么工作的。</p><h3 id="exercises" tabindex="-1"><a class="header-anchor" href="#exercises"><span>练习</span></a></h3><ol><li>扩展 <code>prettyShow</code> 函数，去掉不必要的括号。</li></ol><h2 id="taking-advantage-of-functions-as-data" tabindex="-1"><a class="header-anchor" href="#taking-advantage-of-functions-as-data"><span>把函数当成数据来用</span></a></h2><p>在命令式语言当中，拼接两个列表很容易。下面的 C 语言结构维护了指向列表头尾的指针：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们想把列表 B 拼接到列表 A 的尾部时，我们将 A 的最后一个节点指向 B 的 <code>head</code> 节点，再把 A 的 <code>tail</code> 指针指向 B 的 <code>tail</code> 节点。</p><p>很显然，在 Haskell 里，如果我们想保持&quot;纯&quot;的话，这种方法是有局限性的。由于纯数据是不可变的，我们无法原地修改列表。Haskell 的 <code>(++)</code> 操作符通过生成一个新列表来拼接列表。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/Append.hs</span>
<span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">xs</span> <span class="token operator">++</span> <span class="token hvariable">ys</span>
<span class="token hvariable">_</span>      <span class="token operator">++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">ys</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码里可以看出，创建新列表的开销取决于第一个列表的长度。</p><p>我们经常需要通过重复拼接列表来创建一个大列表。例如，在生成网页内容时我们可能想生成一个 <code>String</code>。 每当有新内容添加到网页中时，我们会很自然地想到把它拼接到已有 <code>String</code> 的末尾。</p><p>如果每一次拼接的开销都正比与初始列表的长度，每一次拼接都把初始列表加的更长，那么我们将会陷入一个很糟糕的情况：所有拼接的总开销将会正比于最终列表长度的平方。</p><p>为了更好地理解，我们来研究一下。<code>(++)</code> 操作符是右结合的。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :info <span class="token punctuation">(</span>++<span class="token punctuation">)</span>
<span class="token punctuation">(</span>++<span class="token punctuation">)</span> :: <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>   -- Defined <span class="token keyword">in</span> GHC.Base
infixr <span class="token number">5</span> ++
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这意味着 Haskell 在求值表达式 <code>&quot;a&quot; ++ &quot;b&quot; ++ &quot;c&quot;</code> 时会从右向左进行，就像加了括号一样：<code>&quot;a&quot; ++ (&quot;b&quot; ++ &quot;c&quot;)</code>。这对于提高性能非常有好处，因为它会让左侧操作数始终保持最短。</p><p>当我们重复向列表末尾拼接时，我们破坏了这种结合性。假设我们有一个列表 <code>&quot;a&quot;</code> 然后想把 <code>&quot;b&quot;</code> 拼接上去，我们把结果存储在一个新列表里。稍后如果我们想把 <code>&quot;c&quot;</code> 拼接上去时，这时的左操作数已经变成了 <code>&quot;ab&quot;</code>。在这种情况下，每次拼接都让左操作数变得更长。</p><p>与此同时，命令式语言的程序员却在偷笑，因为他们重复拼接的开销只取决于操作的次数。他们的性能是线性的，我们的是平方的。</p><p>当像重复拼接列表这种常见任务都暴露出如此严重的性能问题时，我们有必要从另一个角度来看看问题了。</p>`,72),r=s("p",null,[n("表达式 "),s("code",null,'("a"++)'),n(" 是一个 "),s("code",{class:"interpreted-text",role:"ref"},"sections"),n(" (section)，一个部分应用的函数。它的类型是什么呢？")],-1),u=a(`<div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span> ++<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span> ++<span class="token punctuation">)</span> :: <span class="token punctuation">[</span>Char<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>Char<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于这是一个函数，我们可以用 <code>(.)</code> 操作符把它和另一个节组合起来，例如 <code>(&quot;b&quot;++)</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :type <span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span> ++<span class="token punctuation">)</span> <span class="token builtin class-name">.</span> <span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span> ++<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span> ++<span class="token punctuation">)</span> <span class="token builtin class-name">.</span> <span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span> ++<span class="token punctuation">)</span> :: <span class="token punctuation">[</span>Char<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>Char<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>新函数的类型和之前相同。当我们停止组合函数，并向我们创造的函数提供一个 <code>String</code> 会发生什么呢？</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span> ++<span class="token punctuation">)</span> <span class="token builtin class-name">.</span> <span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span> ++<span class="token punctuation">)</span>
ghci<span class="token operator">&gt;</span> f <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token string">&quot;ab&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们实现了字符串拼接！我们利用这些部分应用的函数来存储数据，并且只要提供一个空列表就可以把数据提取出来。每一个 <code>(++)</code> 和 <code>(.)</code> 部分应用都代表了一次拼接，但它们并没有真正完成拼接。</p><p>这个方法有两点非常有趣。第一点是部分应用的开销是固定的，这样多次部分应用的开销就是线性的。第二点是当我们提供一个 <code>[]</code> 值来从部分应用链中提取最终列表时，求值会从右至左进行。 这使得 <code>(++)</code> 的左操作数尽可能小，使得所有拼接的总开销是线性而不是平方。</p><p>通过使用这种并不太熟悉的数据表示方式，我们避免了一个性能泥潭，并且对&quot;把函数当成数据来用&quot;有了新的认识。顺便说一下，这个技巧并不新鲜，它通常被称为<em>差异列表</em>（difference list）。</p><p>还有一点没讲。尽管从理论上看差异列表非常吸引人，但如果在实际中把 <code>(++)</code>、<code>(.)</code> 和部分应用都暴露在外的话，它并不会非常好用。我们需要把它转成一种更好用的形式。</p><h3 id="turning-difference-lists-into-a-proper-library" tabindex="-1"><a class="header-anchor" href="#turning-difference-lists-into-a-proper-library"><span>把差异列表转成库</span></a></h3><p>第一步是用 <code>newtype</code> 声明把底层的类型隐藏起来。我们会创建一个 <code>DList</code> 类型。类似于普通列表，它是一个参数化类型。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token keyword">newtype</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">DL</span> <span class="token punctuation">{</span>
    <span class="token hvariable">unDL</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>unDL</code> 是我们的析构函数，它把 <code>DL</code> 构造器删除掉。我们最后导出模块函数时会忽略掉构造函数和析构函数，这样我们的用户就没必要知道 <code>DList</code> 类型的实现细节。他们只用我们导出的函数即可。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token hvariable">append</span> <span class="token operator">::</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span>
<span class="token hvariable">append</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token constant">DL</span> <span class="token punctuation">(</span><span class="token hvariable">unDL</span> <span class="token hvariable">xs</span> <span class="token operator">.</span> <span class="token hvariable">unDL</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的 <code>append</code> 函数看起来可能有点复杂，但其实它仅仅是围绕着 <code>(.)</code> 操作符做了一些簿记工作，<code>(.)</code> 的用法和我们之前展示的完全一样。生成函数的时候，我们必须首先用 <code>unDL</code> 函数把它们从 <code>DL</code> 构造器中取出来。然后我们在把得到的结果重新用 <code>DL</code> 包装起来，确保它的类型正确。</p><p>下面是相同函数的另一种写法，这种方法通过模式识别取出 <code>xs</code> 和 <code>ys</code>。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token hvariable">append&#39;</span> <span class="token operator">::</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span>
<span class="token hvariable">append&#39;</span> <span class="token punctuation">(</span><span class="token constant">DL</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">DL</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">DL</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">.</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要在 <code>DList</code> 类型和普通列表之间来回转换。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token hvariable">fromList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span>
<span class="token hvariable">fromList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token constant">DL</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">++</span><span class="token punctuation">)</span>

<span class="token hvariable">toList</span> <span class="token operator">::</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">toList</span> <span class="token punctuation">(</span><span class="token constant">DL</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">xs</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次声明，跟这些函数最原始的版本相比，我们在这里做的只是一些簿记工作。</p><p>如果我们想把 <code>DList</code> 作为普通列表的替代品，我们还需要提供一些常用的列表操作。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token hvariable">empty</span> <span class="token operator">::</span> <span class="token constant">DList</span> <span class="token hvariable">a</span>
<span class="token hvariable">empty</span> <span class="token operator">=</span> <span class="token constant">DL</span> <span class="token builtin">id</span>

<span class="token comment">-- equivalent of the list type&#39;s (:) operator</span>
<span class="token hvariable">cons</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span>
<span class="token hvariable">cons</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">DL</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">DL</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
<span class="token keyword">infixr</span> <span class="token operator">\`cons\`</span>

<span class="token hvariable">dfoldr</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">dfoldr</span> <span class="token hvariable">f</span> <span class="token hvariable">z</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token hvariable">f</span> <span class="token hvariable">z</span> <span class="token punctuation">(</span><span class="token hvariable">toList</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尽管 <code>DList</code> 使得拼接很廉价，但并不是所有的列表操作都容易实现。 列表的 <code>head</code> 函数具有常数开销，而对应的 <code>DList</code> 实现却需要将整个 <code>DList</code> 转为普通列表，因此它比普通列表的实现昂贵得多： 它的开销正比于构造 <code>DList</code> 所需的拼接次数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token hvariable">safeHead</span> <span class="token operator">::</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">safeHead</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">toList</span> <span class="token hvariable">xs</span> <span class="token keyword">of</span>
                <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token hvariable">y</span>
                <span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了实现对应的 <code>map</code> 函数，我们可以把 <code>DList</code> 类型声明为一个 Functor（函子）。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token hvariable">dmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">DList</span> <span class="token hvariable">b</span>
<span class="token hvariable">dmap</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">dfoldr</span> <span class="token hvariable">go</span> <span class="token hvariable">empty</span>
    <span class="token keyword">where</span> <span class="token hvariable">go</span> <span class="token hvariable">x</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">cons</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>

<span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">DList</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">=</span> <span class="token hvariable">dmap</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们实现了足够多的列表操作时，我们回到源文件顶部增加一个模块头。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token keyword">module</span> <span class="token constant">DList</span>
    <span class="token punctuation">(</span>
    <span class="token constant">DList</span>
    <span class="token punctuation">,</span> <span class="token hvariable">fromList</span>
    <span class="token punctuation">,</span> <span class="token hvariable">toList</span>
    <span class="token punctuation">,</span> <span class="token hvariable">empty</span>
    <span class="token punctuation">,</span> <span class="token hvariable">append</span>
    <span class="token punctuation">,</span> <span class="token hvariable">cons</span>
    <span class="token punctuation">,</span> <span class="token hvariable">dfoldr</span>
    <span class="token punctuation">)</span> <span class="token keyword">where</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="lists-difference-lists-and-monoids" tabindex="-1"><a class="header-anchor" href="#lists-difference-lists-and-monoids"><span>列表、差异列表和幺半群（monoids）</span></a></h3><p>在抽象代数中，有一类简单的抽象结构被称为<em>幺半群</em>。许多数学结构都是幺半群，因为成为幺半群的要求非常低。 一个结构只要满足两个性质便可称为幺半群：</p><ul><li>一个满足结合律的二元操作符。我们称之为 <code>(*)</code>：表达式 <code>a * (b * c)</code> 和 <code>(a * b) * c</code> 结果必须相同。</li><li>一个单位元素。我们称之为 <code>e</code>，它必须遵守两条法则：<code>a * e == a</code> 和 <code>e * a == a</code>。</li></ul><p>幺半群并不要求这个二元操作符做什么，它只要求这个二元操作符必须存在。因此很多数学结构都是幺半群。如果我们把加号作为二元操作符，0作为单位元素，那么整数就是一个幺半群。把乘号作为二元操作符，1作为单位元素，整数就形成了另一个幺半群。</p><p>Haskell 中幺半群无所不在。<code>Data.Monoid</code> 模块定义了 <code>Monoid</code> 类型类。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/Monoid.hs</span>
<span class="token keyword">class</span> <span class="token constant">Monoid</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span>  <span class="token operator">::</span> <span class="token hvariable">a</span>                <span class="token comment">-- the identity</span>
    <span class="token hvariable">mappend</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>      <span class="token comment">-- associative binary operator</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们把 <code>(++)</code> 当做二元操作符，<code>[]</code> 当做单位元素，列表就形成了一个幺半群。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/Monoid.hs</span>
<span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span>  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token hvariable">mappend</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于列表和 <code>DLists</code> 关系如此紧密，<code>DList</code> 类型也必须是一个幺半群。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/DList.hs</span>
<span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token punctuation">(</span><span class="token constant">DList</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token hvariable">empty</span>
    <span class="token hvariable">mappend</span> <span class="token operator">=</span> <span class="token hvariable">append</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <strong>ghci</strong> 里试试 <code>Monoid</code> 类型类的函数。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token string">&quot;foo&quot;</span> <span class="token variable"><span class="token variable">\`</span>mappend<span class="token variable">\`</span></span> <span class="token string">&quot;bar&quot;</span>
<span class="token string">&quot;foobar&quot;</span>
ghci<span class="token operator">&gt;</span> toList <span class="token punctuation">(</span>fromList <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span> <span class="token variable"><span class="token variable">\`</span>mappend<span class="token variable">\`</span></span> fromList <span class="token punctuation">[</span><span class="token number">3,4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1,2</span>,3,4<span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> mempty <span class="token variable"><span class="token variable">\`</span>mappend<span class="token variable">\`</span></span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">Note</p><p>尽管从数学的角度看，整数可以以两种不同的方式作为幺半群，但在 Haskell 里，我们却不能给 <code>Int</code> 写两个不同的 <code>Monoid</code> 实例：编译器会报告重复实例错误。</p><p>如果我们真的需要在同一个类型上实现多个 <code>Monoid</code> 实例，我们可以用 <code>newtype</code> 创建不同的类型来达到目的。</p><div class="language-haskell line-numbers-mode" data-ext="haskell" data-title="haskell"><pre class="language-haskell"><code><span class="token comment">-- file: ch13/Monoid.hs</span>
<span class="token comment">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="token keyword">newtype</span> <span class="token constant">AInt</span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token punctuation">{</span> <span class="token hvariable">unA</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token punctuation">}</span>
    <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Num</span><span class="token punctuation">)</span>

<span class="token comment">-- monoid under addition</span>
<span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token constant">AInt</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token hvariable">mappend</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span>

<span class="token keyword">newtype</span> <span class="token constant">MInt</span> <span class="token operator">=</span> <span class="token constant">M</span> <span class="token punctuation">{</span> <span class="token hvariable">unM</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token punctuation">}</span>
    <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Num</span><span class="token punctuation">)</span>

<span class="token comment">-- monoid under multiplication</span>
<span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token constant">MInt</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token hvariable">mappend</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，根据使用类型的不同，我们就能得到不同的行为。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token variable"><span class="token variable">\`</span>mappend<span class="token variable">\`</span></span> <span class="token number">5</span> :: MInt
M <span class="token punctuation">{</span>unM <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">}</span>
ghci<span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token variable"><span class="token variable">\`</span>mappend<span class="token variable">\`</span></span> <span class="token number">5</span> :: AInt
A <span class="token punctuation">{</span>unA <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>在这一节（The writer monad and lists）中，我们还会继续讨论差异列表和它的幺半群性质。</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>跟 functor 规则一样，Haskell 没法替我们检查幺半群的规则。如果我们定义了一个 <code>Monoid</code> 实例，我们可以很容易地写一些 QuickCheck 性质来得到一个较高的统计推断，确保代码遵守了幺半群规则。</p></div><h2 id="general-purpose-sequences" tabindex="-1"><a class="header-anchor" href="#general-purpose-sequences"><span>通用序列</span></a></h2><p>不论是 Haskell 内置的列表，还是我们前面定义的 <code>DList</code> ，这些数据结构在不同的地方都有自己的性能短板。为此， <code>Data.Sequence</code> 模块定义了 <code>Seq</code> 容器类型，对于大多数操作，这种类型能都提供良好的效率保证。</p><p>为了避免命名冲突， <code>Data.Sequence</code> 模块通常以 <code>qualified</code> 的方式引入：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude<span class="token operator">&gt;</span> <span class="token function">import</span> qualified Data.Sequence as Seq
Prelude Seq<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>empty</code> 函数用于创建一个空 <code>Seq</code> ， <code>singleton</code> 用于创建只包含单个元素的 <code>Seq</code> ：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq<span class="token operator">&gt;</span> Seq.empty
fromList <span class="token punctuation">[</span><span class="token punctuation">]</span>

Prelude Seq<span class="token operator">&gt;</span> Seq.singleton <span class="token number">1</span>
fromList <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以使用 <code>fromList</code> 函数，通过列表创建出相应的 <code>Seq</code> ：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> a <span class="token operator">=</span> Seq.fromList <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span>

Prelude Seq<span class="token operator">&gt;</span> a
fromList <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Data.Sequence</code> 模块还提供了几种操作符形式的构造函数。但是，在使用 <code>qualified</code> 形式载入模块的情况下调用它们会非常难看：</p><p>[译注：操作符形式指的是那种放在两个操作对象之间的函数，比如 <code>2 * 2</code> 中的 <code>*</code> 函数。]</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq<span class="token operator">&gt;</span> <span class="token number">1</span> Seq.<span class="token operator">&lt;</span><span class="token operator">|</span> Seq.singleton <span class="token number">2</span>
fromList <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以通过直接载入这几个函数来改善可读性：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq<span class="token operator">&gt;</span> <span class="token function">import</span> Data.Sequence<span class="token variable"><span class="token punctuation">((</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">|</span><span class="token operator">&gt;</span><span class="token punctuation">))</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在好多了：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq Data.Sequence<span class="token operator">&gt;</span> Seq.singleton <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">&gt;</span> <span class="token number">2</span>
fromList <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一个帮助记忆 <code>(&lt;|)</code> 和 <code>(|&gt;)</code> 函数的方法是，函数的『箭头』总是指向被添加的元素： <code>(&lt;|)</code> 函数要添加的元素在左边，而 <code>(|&gt;)</code> 函数要添加的元素在右边：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq Data.Sequence<span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">|</span> Seq.singleton <span class="token number">2</span>
fromList <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span>

Prelude Seq Data.Sequence<span class="token operator">&gt;</span> Seq.singleton <span class="token number">1</span> <span class="token operator">|</span><span class="token operator">&gt;</span> <span class="token number">2</span>
fromList <span class="token punctuation">[</span><span class="token number">1,2</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不管是从左边添加元素，还是从右边添加元素，添加操作都可以在常数时间内完成。对两个 <code>Seq</code> 进行追加（append）操作同样非常廉价，复杂度等同于两个 <code>Seq</code> 中较短的那个 <code>Seq</code> 的长度的对数。</p><p>追加操作由 <code>(&gt;&lt;)</code> 函数完成：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq Data.Sequence<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> left <span class="token operator">=</span> Seq.fromList <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">3</span>, <span class="token number">3</span><span class="token punctuation">]</span>

Prelude Seq Data.Sequence<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> right <span class="token operator">=</span> Seq.fromList <span class="token punctuation">[</span><span class="token number">7</span>, <span class="token number">1</span><span class="token punctuation">]</span>

Prelude Seq Data.Sequence<span class="token operator">&gt;</span> left <span class="token operator">&gt;</span><span class="token operator">&lt;</span> right
fromList <span class="token punctuation">[</span><span class="token number">1,3</span>,3,7,1<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反过来，如果我们想将 <code>Seq</code> 转换回列表，那么就需要 <code>Data.Foldable</code> 模块的帮助：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq Data.Sequence<span class="token operator">&gt;</span> <span class="token function">import</span> qualified Data.Foldable as Foldable
Prelude Seq Data.Sequence Foldable<span class="token operator">&gt;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个模块定义了一个类型， <code>Foldable</code> ，而 <code>Seq</code> 实现了这个类型：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq Data.Sequence Foldable<span class="token operator">&gt;</span> Foldable.toList <span class="token punctuation">(</span>Seq.fromList <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Data.Foldable</code> 中的 fold 函数可以用于对 <code>Seq</code> 进行 fold 操作：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Prelude Seq Data.Sequence Foldable<span class="token operator">&gt;</span> Foldable.foldl&#39; <span class="token punctuation">(</span>+<span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">(</span>Seq.fromList <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">6</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Data.Sequence</code> 模块还提供了大量有用的函数，这些函数都和 Haskell 列表的函数类似。模块的文档也非常齐全，还提供了函数的时间复杂度信息。</p><p>最后的疑问是，既然 <code>Seq</code> 的效率这么好，那为什么它不是 Haskell 默认的序列类型呢？答案是，列表类型更简单，消耗更低，对于大多数应用程序来说，列表已经足够满足需求了。除此之外，列表可以很好地处理惰性环境，而 <code>Seq</code> 在这方面做得还不够好。</p>`,71),k=[l,c,i,r,u];function d(b,v){return t(),p("div",null,k)}const g=e(o,[["render",d],["__file","13.html.vue"]]),q=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/13.html","title":"第 13 章：数据结构","lang":"zh-CN","frontmatter":{"description":"第 13 章：数据结构 关联列表 我们常常会跟一些以键为索引的无序数据打交道。 举个例子，UNIX 管理猿可能需要这么一个列表，它包含系统中所有用户的 UID，以及和这个 UID 相对应的用户名。这个列表根据 UID 而不是数据的位置来查找相应的用户名。换句话来说， UID 就是这个数据集的键。 Haskell 里有几种不同的方法来处理这种结构的数据，...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E5%AD%A6%E4%B9%A0/Haskell%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/13.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"第 13 章：数据结构"}],["meta",{"property":"og:description","content":"第 13 章：数据结构 关联列表 我们常常会跟一些以键为索引的无序数据打交道。 举个例子，UNIX 管理猿可能需要这么一个列表，它包含系统中所有用户的 UID，以及和这个 UID 相对应的用户名。这个列表根据 UID 而不是数据的位置来查找相应的用户名。换句话来说， UID 就是这个数据集的键。 Haskell 里有几种不同的方法来处理这种结构的数据，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-25T04:39:03.000Z"}],["meta",{"property":"article:author","content":"hahg"}],["meta",{"property":"article:modified_time","content":"2024-02-25T04:39:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第 13 章：数据结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-25T04:39:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hahg\\"}]}"]]},"headers":[{"level":2,"title":"关联列表","slug":"association-lists","link":"#association-lists","children":[]},{"level":2,"title":"Map 类型","slug":"map-类型","link":"#map-类型","children":[]},{"level":2,"title":"函数也是数据","slug":"函数也是数据","link":"#函数也是数据","children":[]},{"level":2,"title":"扩展示例： /etc/password","slug":"扩展示例-etc-password","link":"#扩展示例-etc-password","children":[]},{"level":2,"title":"扩展示例：数字类型（Numeric Types）","slug":"extended-example-numeric-types","link":"#extended-example-numeric-types","children":[{"level":3,"title":"第一步","slug":"first-steps","link":"#first-steps","children":[]},{"level":3,"title":"完整代码","slug":"completed-code","link":"#completed-code","children":[]},{"level":3,"title":"练习","slug":"exercises","link":"#exercises","children":[]}]},{"level":2,"title":"把函数当成数据来用","slug":"taking-advantage-of-functions-as-data","link":"#taking-advantage-of-functions-as-data","children":[{"level":3,"title":"把差异列表转成库","slug":"turning-difference-lists-into-a-proper-library","link":"#turning-difference-lists-into-a-proper-library","children":[]},{"level":3,"title":"列表、差异列表和幺半群（monoids）","slug":"lists-difference-lists-and-monoids","link":"#lists-difference-lists-and-monoids","children":[]}]},{"level":2,"title":"通用序列","slug":"general-purpose-sequences","link":"#general-purpose-sequences","children":[]}],"git":{"createdTime":1708835943000,"updatedTime":1708835943000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":31.2,"words":9361},"filePathRelative":"学习/Haskell中文文档/13.md","localizedDate":"2024年2月25日","excerpt":"\\n<h2>关联列表</h2>\\n<p>我们常常会跟一些以键为索引的无序数据打交道。</p>\\n<p>举个例子，UNIX 管理猿可能需要这么一个列表，它包含系统中所有用户的 UID，以及和这个 UID 相对应的用户名。这个列表根据 UID 而不是数据的位置来查找相应的用户名。换句话来说， UID 就是这个数据集的键。</p>\\n<p>Haskell 里有几种不同的方法来处理这种结构的数据，最常用的两个是关联列表（association list）和 <code>Data.Map</code> 模块提供的 <code>Map</code> 类型。</p>\\n<p>关联列表非常简单，易于使用。由于关联列表由 Haskell\\n列表构成，因此所有列表操作函数都可以用于处理关联列表。</p>","autoDesc":true}');export{g as comp,q as data};
