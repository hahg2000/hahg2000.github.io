const e=JSON.parse('{"key":"v-7868b426","path":"/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/SSM%E6%A1%86%E6%9E%B6/SSM%E5%89%8D%E8%A8%80/%E4%B8%89%E3%80%81SSM%E6%A1%86%E6%9E%B6%E5%89%8D%E8%A8%80-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html","title":"三、SSM前言——代理模式","lang":"zh-CN","frontmatter":{"readingTime":true,"autoNext":"四、SSM框架前言-适配器模式","tag":["SSM框架","学习","Java"],"description":"三、SSM前言——代理模式 3.1 代理模式 使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑。客户类想要访问的对象是目标对象，但客户类真正能访问的对象是代理对象。 客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口。 可以用生活中的“代理律师”为例，来理解“代理模式”。根据代理关系建立的时间不同，可以将代理分为两类： 静态代理 —— 法律顾问 动态代理 —— 代理律师","head":[["meta",{"property":"og:url","content":"https://hahg2000.github.io/%E5%AD%A6%E4%B9%A0/%E5%90%8E%E7%AB%AF/SSM%E6%A1%86%E6%9E%B6/SSM%E5%89%8D%E8%A8%80/%E4%B8%89%E3%80%81SSM%E6%A1%86%E6%9E%B6%E5%89%8D%E8%A8%80-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:title","content":"三、SSM前言——代理模式"}],["meta",{"property":"og:description","content":"三、SSM前言——代理模式 3.1 代理模式 使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑。客户类想要访问的对象是目标对象，但客户类真正能访问的对象是代理对象。 客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口。 可以用生活中的“代理律师”为例，来理解“代理模式”。根据代理关系建立的时间不同，可以将代理分为两类： 静态代理 —— 法律顾问 动态代理 —— 代理律师"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-12T04:21:01.000Z"}],["meta",{"property":"article:tag","content":"SSM框架"}],["meta",{"property":"article:tag","content":"学习"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2023-03-12T04:21:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"三、SSM前言——代理模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-12T04:21:01.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"3.1 代理模式","slug":"_3-1-代理模式","link":"#_3-1-代理模式","children":[]},{"level":2,"title":"3.2 Java包的命名","slug":"_3-2-java包的命名","link":"#_3-2-java包的命名","children":[]},{"level":2,"title":"3.3 静态代理的实现","slug":"_3-3-静态代理的实现","link":"#_3-3-静态代理的实现","children":[{"level":3,"title":"（1）目标类定义","slug":"_1-目标类定义","link":"#_1-目标类定义","children":[]},{"level":3,"title":"（2）代理类的定义","slug":"_2-代理类的定义","link":"#_2-代理类的定义","children":[]}]},{"level":2,"title":"3.4 动态代理——JDK代理","slug":"_3-4-动态代理——jdk代理","link":"#_3-4-动态代理——jdk代理","children":[{"level":3,"title":"（1）执行Java文件的过程","slug":"_1-执行java文件的过程","link":"#_1-执行java文件的过程","children":[]},{"level":3,"title":"（2）需要用到的代理方法","slug":"_2-需要用到的代理方法","link":"#_2-需要用到的代理方法","children":[]},{"level":3,"title":"（3）测试文件","slug":"_3-测试文件","link":"#_3-测试文件","children":[]}]},{"level":2,"title":"3.5 动态代理——CGLIB代理","slug":"_3-5-动态代理——cglib代理","link":"#_3-5-动态代理——cglib代理","children":[{"level":3,"title":"（1）无接口的CGLIB代理的实现","slug":"_1-无接口的cglib代理的实现","link":"#_1-无接口的cglib代理的实现","children":[]},{"level":3,"title":"（2）有接口的CGLIB代理的实现","slug":"_2-有接口的cglib代理的实现","link":"#_2-有接口的cglib代理的实现","children":[]}]},{"level":2,"title":"附录","slug":"附录","link":"#附录","children":[{"level":3,"title":"Eclipse 常用快捷键","slug":"eclipse-常用快捷键","link":"#eclipse-常用快捷键","children":[]}]}],"git":{"createdTime":1678594861000,"updatedTime":1678594861000,"contributors":[{"name":"hahg2000","email":"61403802+hahg2000@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":10.05,"words":3014},"filePathRelative":"学习/后端/SSM框架/SSM前言/三、SSM框架前言-代理模式.md","localizedDate":"2023年3月12日","excerpt":"<h1> 三、SSM前言——代理模式</h1>\\n<h2> 3.1 代理模式</h2>\\n<p>使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑。客户类<u><strong>想要访问</strong></u>的对象是目标对象，但客户类<u><strong>真正能访问</strong></u>的对象是代理对象。\\n客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口。</p>\\n<p>可以用生活中的“代理律师”为例，来理解“代理模式”。根据代理关系建立的时间不同，可以将代理分为两类：</p>\\n<ol>\\n<li>静态代理 —— 法律顾问</li>\\n<li>动态代理 —— 代理律师</li>\\n</ol>","autoDesc":true}');export{e as data};
