---
tags:
  - SSM框架
  - 学习
  - MyBatis
readingTime: true 
autoNext: 四、查询缓存
---

# 三、关联关系查询

## 3.1 UML类图的几种关系

在UML类图中，常见的有以下几种关系:

+ 泛化（Generalization）；
+ 实现（Realization）；
+ 关联（Association）；
+ 聚合（Aggregation）；
+ 组合（Composition）；
+ 依赖（Dependency）。

### 3.1.1 泛化

【关系】：一种继承关系，指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种。

【箭头类型】：带空心三角的实线，箭头指向父类

【代码表示】：继承 extend

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E6%B3%9B%E5%8C%96.png" style="zoom:75%;" />

### 3.1.2 实现

【关系】：一种类与接口的关系，表现了类是接口所有特征和行为的实现。

【箭头类型】：带空心三角的虚线，箭头指向接口

【代码表示】：实现 implements

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E5%AE%9E%E7%8E%B0.png" style="zoom:75%;" />

### 3.1.3 关联

【关系】：是一种拥有关系，它使一个类知道另一个类的属性。如老师与学生；国家与部长。

关联可以是双向的，多对多；也可以是单向的，一对多；

【箭头类型】：双向，无箭头实体线；单向，普通箭头实体线。箭头指向被拥有者。

【代码表示】：成员变量。

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E5%85%B3%E8%81%94.png" style="zoom:75%;" />

上图中，老师与学生是双向关联，多对多，老师有多个学生，学生也有多个老师。一个学生要上多门课程，但课程是抽象的不拥有学生。

数据库中的自关联

### 3.1.4 聚合

【关系】：是整体与部分关系，如车和轮胎是整体和部分的关系。

聚合关系是关联关系的一种，是强的关联关系。

关联可以是双向的，多对多；也可以是单向的，一对多；

【箭头类型】：带空心菱形的实线，菱形位置为整体

【代码表示】：成员变量。

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E8%81%9A%E5%90%88.png" style="zoom:75%;" />

### 3.1.5 组合

【关系】：是整体与部分关系，组合关系是关联关系的一种，是比聚合关系还强的关系。如公司与部门，没有了公司就不存在部门。

【箭头类型】：带实心菱形的实线，菱形位置为整体

【代码表示】：成员变量。

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E7%BB%84%E5%90%88.png" style="zoom:75%;" />

### 3.1.6 依赖

【关系】：是一种使用的关系。

【箭头类型】：带普通箭头的虚线，指向被使用者

【代码表示】：局部变量、方法的参数或对静态方法的调用。

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E4%BE%9D%E8%B5%96.png" style="zoom:75%;" />

## 3.2 关联查询

​	当查询内容涉及到具有关联关系的 **多个表** 时，就需要使用关联查询。根据表与表间的关联关系的不同，关联查询分为四种：

1. 一对一关联查询

2. 一对多关联查询
3. 多对一关联查询
4. 多对多关联查询

日常使用中最常见的关联关系是一对多、多对一与多对多。

### 3.1.1 一对多关联查询

​	这里的一对多关联查询是指，在查询一方对象的时候，同时将其所关联的多方对象也都查询出来，**多方一定是外键**。

​	下面以国家 Country 与部长 Minister 间的一对多关系进行演示。

项目：one2many，在项目 dynamicMapper 基础上进行修改。

#### （1）定义实体

​	在定义实体时，若定义的是双向关联，即双方的属性中均有对方对象作为域属性出现，那么它们在定义各自的 toString() 方法时需要注意，**只让某一方可以输出另一方即可**，不要让双方的toString()方法均可输出对方。这样会形成递归调用，程序出错。

**Country.java**：

```java
public class Country {
	private Integer cid;
	private String cname;
	private Set<Minister> ministers;
	
	// getter and setter
	// toString()
}
```

**Minister.java**：

```java
public class Minister {
	private Integer mid;
	private String mname;
	
	// getter and setter
	// toString()
}
```

#### （2）定义数据库表

country 的数据库表

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/20210223122944.png" style="zoom:80%;" />

minister 的数据库表

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/ministertable.png" style="zoom:80%;" />

#### （3）定义 Dao 层接口

ISomeDao.java：

```java
public interface ISomeDao {
	Country selectCountryById(int cid);
}
```

#### （4）定义测试类

​	依旧是使用 MyBatisUtils 来创建 sqlSession 对象。

```java
@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		dao = sqlSession.getMapper(ISomeDao.class);
	}

	@After
	public void after() {
		if (sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void test01() {
		Country country = dao.selectCountryById(1);
		System.out.println(country);
	}
```

#### （5）定义映射文件

##### A、多表连接查询

第一步：将两张表连接在一起查询，查询出来的是两张表的笛卡尔乘积

```mysql
SELECT * FROM minister,country
```

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2-%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5.png" style="zoom:80%;" />

第二步：筛选出需要使用的信息和字段

很明显，只有 countryId 和 cid 相等的数据才有意义。再因为 countryId 和 cid 相等，所以这两个字段名只查询一个即可，这里为了与类里的属性名一致，所以保留 cid。最后添加传进来的条件即可。

```sql
SELECT cid,cname,mid,mname FROM minister,country WHERE cid=#{xxx} AND countryId=cid
```

第三步：封装查询出来的结果

假设现在条件的是 cid = 1，查询出来的结果如下图：

 <img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C.png" style="zoom:80%;" />

现在需要把 mid，mname 进行封装成 Minister 对象，所以需要用到 resultMap。

```xml
<select id="selectCountryById" resultMap="countryMapper">
		select cid,cname,mid,mname
		from country,minister
		where cid=#{xxx} and cid=countryId
</select>
```

第四步：定义 resultMap

+ type 属性的值为映射属性的类型，这里是将数据映射到 Country 类型的属性。
+ 一个个将字段名映射至属性名。注意，即使字段名和属性名相等，也需要映射。
+ &lt;collection/> 标签会把数据封装成指定类型：
  + property 属性为将要映射成的属性名；
  + ofType 属性指定封装的类型；
  + &lt;id/> 和 &lt;result/> 标签使用方式一致

```xml
<resultMap type="Country" id="countryMapper">
	<id column="cid" property="cid"/>
	<result column="cname" property="cname"/>
	<collection property="ministers" ofType="Minister">
		<id column="mid" property="mid"/>
		<result column="mname" property="mname"/>
	</collection>
</resultMap>
```

##### B、多表单独查询

项目：one2many-2，在项目 one2many 基础上进行修改。

​	多表连接查询方式是将多张表进行连接，组成一张表后进行查询。其查询的本质是一张表。而多表单独查询方式是多张表各自查询各自的相关内容，需要多张表的联合数据。

​	当然，这多个查询是可以跨越多个映射文件的，即可以跨越多个 namespace 的。在使用其他 namespace 的查询时，添加上其所在的 namespace 即可。

第一步：明确需要查询的表

首先需要在 country 表中查询指定 cid 的 countryId ，再根据 countryId 在 minister 表中查找指定数据。

第二步：列出各自的 Sql 语句

```sql
SELECT cid,cname FROM country WHERE cid=#{xxx}

SELECT mid,mname FROM minister WHERE countryId=#{ooo}
```

问题：如何将第 1 行查询出的结果传到 第 3 行的参数那里。

第三步：使用 &lt;resultMap/> 标签

+ 使用了 &lt;resultMap/> 标签里的 &lt;collection/> 子标签
+ 该集合的数据来自于执行 select 语句后的查询结果。
+ &lt;collection/> 标签里的 select 属性指定执行的 select 语句；column 属性指定传递参数的字段名。

```xml
<mapper namespace="com.hahg.dao.ISomeDao">

	<!-- 根据外键 countryId 查询 minister 表 -->
	<select id="selectMinisterByCountry" resultType="Minister">
		SELECT mid,mname FROM minister WHERE countryId=#{ooo}
	</select>
	
	<resultMap type="Country" id="countryMapper">
		<id column="cid" property="cid" />
		<result column="cname" property="cname" />
		<!-- 集合的数据来自于指定的 select 查询 -->
		<collection property="ministers" ofType="Minister"
			select="selectMinisterByCountry" column="cid" />
	</resultMap>
	
	<select id="selectCountryById" resultMap="countryMapper">
		SELECT cid,cname FROM
		country WHERE cid=#{xxx}
	</select>
</mapper>
```

### 3.1.2 多对一关联查询

​	这里的多对一关联查询时指，在查询多方对象的时候，同时将其所关联的一方对象也查询出来。

​	由于在查询多方对象时也是一个个查询，所以多对一查询，其实就是一对一查询。即 **一对一关联查询的实现方式与多对一的实现方式是相同的**。

​	下面的例子为 部长 Minister 与 国家 Country 间的多对一关系。

项目：many2one，在项目 one2many 基础上修改。

#### （1）修改实体

**Country.java**：

```java
public class Country {
	private Integer cid;
	private String cname;
	// getter and setter
	// toString()
}	
```

**Minister.java**：因为一个部长只被一个国家所拥有，所以不使用集合类型。

```java
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;
	// getter and setter
	// toString()
}
```

#### （2）修改 Dao 层接口

```java
public interface ISomeDao {
	Minister selectMinisterById(int mid);
}
```

#### （3）定义测试类

```java
@Test
	public void test01() {
		Minister minister = dao.selectMinisterById(1);
		System.out.println(minister);
	}
```

#### （5）定义映射文件

##### A、多表连接查询

​	因为 Country 对象不是集合类型，所以使用 &lt;association/> 标签即可。 

```xml
<resultMap type="Minister" id="ministerMapper">
		<id column="mid" property="mid" />
		<result column="mname" property="mname" />
		<association property="country" javaType="Country">
			<id column="cid" property="cid" />
			<result column="cname" property="cname" />
		</association>
	</resultMap>
	
	<select id="selectMinisterById" resultMap="ministerMapper">
		SELECT mid,mname,cid,cname FROM
		minister,country WHERE mid=#{xxx} and cid=countryId
	</select> 
```

##### B、多表单独查询

项目：many2one-2，在项目 many2one 基础上修改。

```xml
<mapper namespace="com.hahg.dao.ISomeDao">

	<select id="selectCountryById" resultType="Country">
		SELECT * FROM country WHERE cid=#{ooo}
	</select>
	
	<resultMap type="Minister" id="ministerMapper">
		<id column="mid" property="mid" />
		<result column="mname" property="mname" />
		<!-- 集合的数据来自于指定的 select 查询 -->
		<association property="country"
			javaType="Country"
			select="selectCountryById"
			column="countryId"
		/>
	</resultMap>
	
	<select id="selectMinisterById" resultMap="ministerMapper">
		SELECT mid,mname,countryId FROM
		minister WHERE mid=#{xxx}
	</select>
</mapper>
```

### 3.1.3 自关联查询

​	所谓自关联是指，自己即充当一方，又充当多方，是 1:n 或 n:1 的变型。

​	例如，对于新闻栏目 NewsColumn，表中的字段有父栏目的 id 属性，所以每一项数据可以充当一方，即父栏目，也可以充当多方，即子栏目。而反映到 DB 表中，只有一张表，这张表中具有一个外键，用于表示该栏目的父栏目。一级栏目没有父栏目，所以可以将其外键值设为 0，而子栏目则具有外键值。

​	为了便于理解，将自关联分为两种情况来讲解。一种是当作 1:n 讲解，即当前类作为一方，其包含多方的集合域属性。一种是当作 n:1 讲解，即当前类作为多方，其包含一方的域属性。

​	下面以新闻栏目为例进行讲解。由于Column 是 DBMS 中的关键字，为了避免误解，将新闻栏目实体类定义为 NewsLabel。

#### （1）自关联的 DB 表

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E8%87%AA%E5%85%B3%E8%81%94DB%E8%A1%A8.png" style="zoom:80%;" />

#### （2）一对多的方式处理

​	以一对多方式处理，即一方可以看到多方。该处理方式的应用场景比较多，例如在页面上点击父栏目，显示出其子栏目。再如，将鼠标定位在窗口中的某菜单项上会显示其所有子菜单项等。

​	根据查询需求的不同，又可以分为两种情况：<u>一种是查询出指定栏目的所有子孙栏目，一种是查询出指定栏目及其所有子孙栏目</u>。

##### A、查询指定栏目的所有子孙栏目

项目：oneself-one2many，在项目 one2many 基础上修改。

​	根据指定的id，**仅查询出其所有子栏目**。当然，包括其所有辈份的孙子栏目。即，给出的查询id实际为父栏目id。

###### a、定义实体类

```java
// 定义栏目实体，将当前类当作一方
public class NewsLabel {
	private Integer id;
	private String name;
	// 关联属性，指定子栏目，即多方
	private Set<NewsLabel> children;
	
	// getter and setter
	// toString()
}
```

###### b、定义  Dao 接口

```java
public interface ISomeDao {
	List<NewsLabel> selectChildrenByParentId(int pid);;
}
```

###### c、定义 mapper 映射

第一步：先使用传进来的参数，查询信息并使用 resultMap 映射成对象的属性。

```xml
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
```

第二步：使用 &lt;collection/> 标签将 id 属性作为参数继续执行 select 语句查询该 id 属性的信息。 

```xml
<resultMap type="NewsLabel" id="newslabelMapper">
    <id column="id" property="id"/>
    <result column="name" property="name"/>
    <collection property="children" 
                ofType="NewsLabel"
                select=""
                column="id"/>
</resultMap>
```

第三步：定义查询使用 id 属性作为参数的 select 语句。" #{ooo} " 来表示传进来的参数，因为查询出来的数据也需要 resultMap 来映射，所以依旧使用原来的 resultMap 。

```xml
<select id="" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>
```

第四步：合并 &lt;select/> 标签

比较两个 select 标签，发现两个标签的基本内容一模一样，所以第三步的 &lt;select/> 标签的 id 属性值可以和第一步的相同。

因为两个 id 属性值一致，所以两个 &lt;select/> 标签可以合并成一个。

最后将代码汇总到一块：

```xml
<mapper namespace="com.hahg.dao.ISomeDao">

	<resultMap type="NewsLabel" id="newslabelMapper">
		<id column="id" property="id"/>
		<result column="name" property="name"/>
		<collection property="children" 
					ofType="NewsLabel"
					select="selectChildrenByParentId"
					column="id"/>
	</resultMap>
	
	<select id="selectChildrenByParentId" resultMap="newslabelMapper">
		select id,name from newslabel where pid=#{xxx}
	</select>
</mapper>
```

##### B、查询指定栏目以及其所有子孙栏目

项目：oneself-one2many-2，在项目 oneself -one2many 基础上修改。

这个与上面的查询条件多了自身。

###### a、修改 Dao 接口

```java
public interface ISomeDao {
	NewsLabel selectNewsLabelById(int pid);;
}
```

###### b、修改映射文件

+ 第16 ~ 18 行先使用 id 为查询条件查询出来自身的信息；
+ 第 7 ~ 14 行使用 resultMap 映射 NewsLabel 对象的属性；
+ 第 3 ~ 5 行查询该 id 的 children 数据。

```xml
<mapper namespace="com.hahg.dao.ISomeDao">

	<select id="selectChildrenByParentId" resultMap="newslabelMapper">
		select id,name from newslabel where pid=#{ooo}
	</select>

	<resultMap type="NewsLabel" id="newslabelMapper">
		<id column="id" property="id"/>
		<result column="name" property="name"/>
		<collection property="children" 
					ofType="NewsLabel"
					select="selectChildrenByParentId"
					column="id"/>
	</resultMap>
	
	<select id="selectNewsLabelById" resultMap="newslabelMapper">
		select id,name from newslabel where id=#{xxx}
	</select>
</mapper>
```

###### c、修改测试类

```java
@Test
	public void test01() {
		NewsLabel newsLabel = dao.selectNewsLabelById(2);
		System.out.println(newsLabel);
	}
```

#### （3）多对一的方式处理

​	以多对一方式处理，即多方可以看到一方。该处理方式的应用场景，例如在网页上显示当前页面的站内位置。

项目：oneself –many2one，在项目 oneself -one2many 基础上修改。

##### A、定义实体

```java
public class NewsLabel {
	private Integer id;
	private String name;
	private NewsLabel parent;
	
	// getter and setter
	// toString()
}
```

##### B、定义 Dao 接口

```java
public interface ISomeDao {
	NewsLabel selectNewsLabelById(int pid);
}
```

##### C、定义 mapper 映射

依旧是递归执行查询语句，将上次查询出来的 pid 作为下次执行查询的 id。

```xml
<mapper namespace="com.hahg.dao.ISomeDao">

	<resultMap type="NewsLabel" id="newslabelMapper">
		<id column="id" property="id"/>
		<result column="name" property="name"/>
		<collection property="parent" 
					ofType="NewsLabel"
					select="selectNewsLabelById"
					column="pid"/>
	</resultMap>
	
	<select id="selectNewsLabelById" resultMap="newslabelMapper">
		select id,name,pid from newslabel where id=#{xxx}
	</select>
</mapper>
```

##### D、定义测试类

```java
@Test
	public void test01() {
		NewsLabel newsLabel = dao.selectNewsLabelById(7);
		System.out.println(newsLabel);
	}
```

### 3.1.4 多对多关联查询

​	什么是多对多关联关系？一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立，例如选课表。

​	然后利用之前学过的数据库知识，列出两张表的逻辑结构。

学生（<u>学号</u>，姓名，已选课程）

课程（<u>课程号</u>，课程名，已选学生）

​	两个都是多方，所以关联表中会有两个属性，并且都是主键。关联表中还有一个选课号属性。以下为这几个表的E-R 图。

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/E-R.png" style="zoom:60%;" />

​	而选课表的逻辑结构为：

选课表（<u>学号</u>，<u>课程号</u>，选课号）

项目：many2many，在项目 one2many 基础上进行修改。

#### （1）定义数据库表

​	根据上面的 E-R 图，定义数据库表

​	学生表							课程表							选课表

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/studentTable2.png" style="zoom:80%;" />&emsp;<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/coursetable.png" style="zoom:80%;" />&emsp;<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/middletable.png" style="zoom:80%;" />

#### （2）定义实体

​	在定义双向关联（双方均可看到对方的关联关系）的实体的 toString() 方法时，只让一方的 toString() 方法中可以输出对方，不要让双方均可输出对方。否则将会出现输出时的递归现象，程序报错。

**Course.java**：

```java
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
    // getter and setter
	// toString()
}
```

**Student.java**：

```java
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	// getter and setter
	// toString()
}
```

#### （3）定义 Dao 接口

```java
public interface ISomeDao {
	Student selectStudentById(int id);
}
```

#### （4）定义 Mapper 映射

​	多对多关联关系也是通过映射文件 &lt;resultMap/> 的 &lt;collection/> 体现的。但是，需要注意的是 SQL 语句中是对三张表的连接查询。

```xml
<mapper namespace="com.hahg.dao.ISomeDao">

	<resultMap type="Student" id="studentMapper">
		<id column="sid" property="sid" />
		<result column="sname" property="sname" />
		<collection property="courses" ofType="Course" >
		<id property="cid" column="cid"/>
		<result property="cname" column="cname"/>
		</collection>
	</resultMap>
	
	<select id="selectStudentById" resultMap="studentMapper">
		SELECT sid,sname,cid,cname FROM
		student,course,middle WHERE sid=#{xxx} 
		and sid=studentId and cid=courseId
	</select>
</mapper>
```

#### （5）定义测试类

```java
@Test
	public void test01() {
		Student student = dao.selectStudentById(2);
		System.out.println(student);
	}
```

## 3.3 延迟加载

​	MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时，按照设置延迟规则推迟对关联对象的 select 查询。延迟加载可以有效的减少数据库压力。需要注意的是，<span style="color:red">MyBatis 的延迟加载只是对 **关联对象** 的查询有迟延设置，对于主加载对象都是 **直接** 执行查询语句的</span>。

###  3.3.1关联对象加载时机

​	MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：直接加载、侵入式延迟加载与深度延迟加载。

+ 直接加载：执行完对主加载对象的 select 语句，**马上执行** 对关联对象的 select 查询。
+ 侵入式延迟：执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的 **详情** 时，就会马上执行关联对象的 select 查询。即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
+ 深度延迟：执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当 **真正访问关联对象** 的详情时，才会执行对关联对象的 select 查询。

需要注意的是，延迟加载的应用要求，关联对象的查询与主加载对象的查询<span style="color:red">必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询</span>。

因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。下面以一对多关联关系查询为例，讲解MyBatis中的延迟加载应用。

项目：one2many-2-lazy。在 one2many-2 的基础上修改。

### 3.2.2 直接加载

#### （1）修改主配置文件

​	在主配置文件的 &lt;properties/> 与 &lt;typeAliases/> 标签之间，添加 &lt;settings/> 标签，用于完成全局参数设置。在MyBatis帮助文档中 Ctrl + F 查询关键字 “ lazy ”，则可查询出延迟加载的相关参数名称及取值。

<img src="https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%8F%82%E6%95%B0%E5%90%8D.png" style="zoom:60%;" />

​	lazyLoadingEnabled 的默认值为 false，即直接加载。全局属性 lazyLoadingEnabled 的值只要设置为 false，那么，对于关联对象的查询，将采用直接加载，即在查询过主加载对象后，会马上查询关联对象。

​	当然，对于标签的书写位置，是由约束文件进行规定好的，不能随便写。在 &lt;configuration/> 标签上点击 F2，可查看它们的顺序及数量要求。

::: tip

这些Content Model后所跟的一些符号，表示这些子标签在当前标签中可以包含的数量。

常见的有：

+ ？：表示子标签可以没有，若有的话，**最多只能有一个**。即小于等于1。
+ \* ：表示子标签可以没有，**也可以有多个**。即大于等于0。
+ \+ ：表示子标签**最少要有一个**。即大于等于1。
+ 没符号：表示**有且只能有一个**。即等于1。

:::

#### （2）修改测试类

```java
@Test
	public void test01() {
		Country country = dao.selectCountryById(1);
		// 此处添加断点
		System.out.println(country.getCname());
		System.out.println(country.getMinisters().size());
	}
```

### 3.2.3 深度加载

​	修改主配置文件的 &lt;settings/>：

+ 将延迟加载开关 lazyLoadingEnabled 开启，置为true；
+ 将侵入式延迟加载开关 aggressiveLazyLoading 关闭，置为false。

由测试可知，当访问主加载对象的详情时，是只进行主加载对象查询。

![](https://raw.githubusercontent.com/hahg2000/SSMPic/main/%E6%B7%B1%E5%BA%A6%E5%8A%A0%E8%BD%BD.png)

### 3.2.4 侵入式加载

改主配置文件的 &lt;settings/>：

+ 将延迟加载开关 lazyLoadingEnabled 开启，置为 true；
+ 将侵入式延迟加载开关 aggressiveLazyLoading 也开启，置为 true，默认为true。

由测试可知，当访问主加载对象的详情时，是不仅进行主加载对象查询，而且进行关联对象查询。

![image-20210302164533482](C:\Users\98375\AppData\Roaming\Typora\typora-user-images\image-20210302164533482.png)

​	其它代码均不作改变。此时运行会发现，当代码执行断点处语句时会立即查询country表，但没未查询 minister  表。说明现在的延迟加载已经启动。但继续执行下一语句，即对 Country 对象的详情进行访问时，对 minister 表也进行了查询。

​	因为该延迟策略已经将主加载对象的关联属性值也作为主加载对象的基本信息了，而前面已经查询出了主加载对象的基本信息，但其关联对象基本信息尚无。所以，马上进行对 minister 表的查询。换个角度来说，该延迟策略使关联对象的数据侵入到了主加载对象的数据中，所以称为侵入式延迟加载。

​	需要注意的是，该延迟策略也是一种延迟加载，需要在延迟加载开关lazyLoadingEnabled 开启时才会起作用。若 lazyLoadingEnabled 为 false，则aggressiveLazyLoading 无论取何值，均不起作用。

### 3.2.5 延迟加载策略总结

| 加载策略       | lazyLoadingEnabled | aggressiveLazyLoading |
| -------------- | ------------------ | --------------------- |
| 直接加载       | false              | false                 |
| 深度延迟加载   | true               | false                 |
| 侵入式延迟加载 | true               | true                  |