# 算法七

## 四十九、石子游戏

力扣链接：https://leetcode.cn/problems/stone-game-vi/

> Alice 和 Bob 轮流玩一个游戏，Alice 先手。
>
> 一堆石子里总共有 n 个石子，轮到某个玩家时，他可以 **移出** 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 **不一样的的评判标准** 。双方都知道对方的评判标准。
>
> 给你两个长度为 n 的整数数组 aliceValues 和 bobValues 。aliceValues[i] 和 bobValues[i] 分别表示 Alice 和 Bob 认为第 i 个石子的价值。
>
> 所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 **最优策略** 进行游戏。
>
> 请你推断游戏的结果，用如下的方式表示：
>
> 如果 Alice 赢，返回 1 。如果 Bob 赢，返回 -1 。如果游戏平局，返回 0 。
>
>
> 示例 1：
>
> + 输入：aliceValues = [1,3], bobValues = [2,1]
> + 输出：1
> + 解释：
>   + 如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。
>   + Bob 只能选择石子 0 ，得到 2 分。
>   + Alice 获胜。
>
> 示例 2：
>
> + 输入：aliceValues = [1,2], bobValues = [3,1]
> + 输出：0
> + 解释：
>   + Alice 拿石子 0 ， Bob 拿石子 1 ，他们得分都为 1 分。
>   + 打平。
>
> 提示：
>
> + `n == aliceValues.length == bobValues.length`
> + `1 <= n <= 105`
> + `1 <= aliceValues[i], bobValues[i] <= 100`

### （1）贪心算法

当拿了一个石子的时候，拿石子的人既 **获取到的石子的价值** 又让对面 **失去了这个石子的价值**

所以选择石子优先选择： **获取到的石子的价值** 加上 **失去了这个石子的价值** 最大。

但实际自己获取到只有自己认为的价值。

```java
class Solution {
  public int stoneGameVI(int[] aliceValues, int[] bobValues) {
    
    int n = aliceValues.length;
    // 存放总和数组
    int[][] sum = new int[n][2];

    // 计算两个数组对应格的和
    for (int i = 0; i < n; i++) {
      sum[i][0] = aliceValues[i] + bobValues[i];
      sum[i][1] = i;
    }
    
    // 对数组进行排序
    Arrays.sort(sum, new Comparator<int[]>() {
      @Override
      public int compare(int[] o1, int[] o2) {
        if (o1[0] == o2[0]) return 0;
        return o1[0] > o2[0] ? -1 : 1;
      }
    });

    int sumA = 0;
    int sumB = 0;
    // 分别统计两个玩家的分数
    for (int i = 0; i < n; i++) {
      int index = sum[i][1];
      if (i % 2 == 0){
        sumA += aliceValues[index];
      } else {
        sumB += bobValues[index];
      }
    }
    
    // 根据结果分别输出不同结果
    if (sumA == sumB) {
      return 0;
    }
    return sumA > sumB ? 1 : -1;
  }
}
```



```java
public class Solution {
  public int networkDelayTime(int[][] times, int n, int k) {
    int[][] graph = new int[n][n];    //邻接矩阵初始化图
    for (int i = 0; i < n; i++) {
      Arrays.fill(graph[i], Integer.MAX_VALUE / 2);   //因为可能点与点之间无连接，因此初始化为无穷大。此处为避免33行计算溢出，>>2
    }
    for (int i = 0; i < times.length; i++) {         //根据题目给的信息times，对graph初始化。
      int source = times[i][0] - 1;
      int target = times[i][1] - 1;
      graph[source][target] = times[i][2];
    }
    boolean[] visited = new boolean[n];             //初始值为false,若访问，则为true。
    int[] dist = new int[n];                        //距离表。
    Arrays.fill(dist, Integer.MAX_VALUE / 2);   //初始化距离表为无穷。
    dist[k - 1] = 0;             //初始化起始点K-K的距离为0
    //dijkstra
    for (int j = 0; j < n; j++) {  //一次加入一个节点到路径中
      int cur = -1;
      for (int i = 0; i < n; i++){  //找出距离表中最小的节点 收录进来 即锁死该点，以后就不用了
        if (!visited[i] && (cur == -1 || dist[i] < dist[cur])) {   //！vidsited[i]即锁死的不用
          cur = i;
        }
      }

      visited[cur] = true;   //锁死上述找到的距离表中最小的节点。

      for (int i = 0; i < n; i++) {    //更新锁死节点与其相邻节点的dist.
        dist[i] = Math.min(dist[i], dist[cur] + graph[cur][i]);
      }
    }

    int result = 0;                      //题目要求，若dist中有未到达的节点，return-1；
    for (int i = 0; i < n; i++) {
      if (dist[i] == Integer.MAX_VALUE / 2) {
        return -1;
      }
      result = Math.max(result, dist[i]);
    }
    return result;
  }
}
```

## 五十、分割等和子集1

原题链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485658&idx=1&sn=f298abe76d9cc058805b6a18d2523db6&chksm=fd9ca3c5caeb2ad31f6faefd800471b339d21cf54988e123fc507ff07b1447ae31337d826b0e&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「416. 分割等和子集」**，难度为 **Medium**。
>
> 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
> 注意:
>
> - 每个数组中的元素不会超过 100
> - 数组的大小不会超过 200
>
> 示例 1:
>
> + 输入: [1, 5, 11, 5]
> 
> + 输出: true
> 
> + 解释: 数组可以分割成 [1, 5, 5] 和 [11].
> 
> 示例 2:
>
> + 输入: [1, 2, 3, 5]
>
> + 输出: false
> 
> + 解释: 数组不能分割成两个元素和相等的子集.

### （1）分析

**通常「背包问题」相关的题，都是在考察我们的「建模」能力，也就是将问题转换为「背包问题」的能力**。

由于本题是问我们能否将一个数组分成两个「等和」子集。

问题等效于**「能否从数组中挑选若干个元素，使得元素总和等于所有元素总和的一半」**。

这道题如果抽象成「背包问题」的话，应该是：

**我们背包容量为 $target = sum / 2$ ，每个数组元素的「价值」与「成本」都是其数值大小，求我们能否装满背包。**

### （2）转换为背包问题

然后就可以转换成背包问题

由于每个数字（数组元素）只能被选一次，而且每个数字选择与否对应了**「价值」和「成本」**，求解的问题也与「最大价值」相关。

可以使用「01 背包」的模型来做。

当我们确定一个问题可以转化为「01 背包」之后，就可以直接套用「01 背包」的状态定义进行求解了。

我们直接套用「01 背包」的状态定义：

`f[i][j]` 代表考虑前 `i` 个数值，其选择数字总和不超过 `j` 的最大价值。

当有了「状态定义」之后，结合我们的「最后一步分析法」，每个数字都有「选」和「不选」两种选择。

因此不难得出状态转移方程：

+ `f[i - 1, j]` ：不选该数字
+ `f[i - 1][j - nums[i]] + nums[j]` ：选了该数字

`f[i][j] = max( f[i - 1, j], f[i - 1][j - nums[i]] + nums[j] )`

优化：

+ 如果全部和除以 2 为奇数时，等和子集的目标和必然不能凑成。
  + 根据题目已知，能分割子集的式子： $f[0] + f[1] + ... + f[n-2] = f[n-1]$ （假设数组已经升序排序），可以推出 $\sum_{n=0}^{n-1} {f[n]} = f[0] + f[1] + ... + f[n-2] + f[n-1] = 2f[n-1]$ ，左右边全部除以 2，$\frac{\sum_{n=0}^{n-1} {f[n]}}{2} = f[0] + f[1] + ... + f[n-2] + f[n-1]$
+ 一维下标为 n，代表在该下标之前取到的数。例如下标为 2，代表可以取到 0，1，2 三个物品
+ 二维下标为 价值数量，代表小于该数值的情况下的最大价值。例如二维下标为 4，代表不超过价值 4 的情况下的最大价值，最大价值是 4，且是最后一格，则返回证明可以凑成。

```java
class Solution {
  public boolean canPartition(int[] nums) {
    int n = nums.length;

    //「等和子集」的和必然是总和的一半
    int sum = 0;
    for (int i : nums) sum += i;
    int target = sum / 2;

    // 对应了总和为奇数的情况，注定不能被分为两个「等和子集」
    if (target * 2 != sum) return false;

    int[][] f = new int[n][target + 1];
    // 先处理考虑第 1 件物品的情况
    for (int j = 0; j <= target; j++) {
      f[0][j] = j >= nums[0] ? nums[0] : 0;
    }

    // 再处理考虑其余物品的情况
    for (int i = 1; i < n; i++) {
      int t = nums[i];
      // 遍历价值
      for (int j = 0; j <= target; j++) {
        // 不选第 i 件物品
        int no = f[i - 1][j];
        // 选第 i 件物品
        int yes = j >= t ? f[i - 1][j - t] + t : 0;
        f[i][j] = Math.max(no, yes);
      }
    }
    // 如果最大价值等于 target，说明可以拆分成两个「等和子集」
    return f[n - 1][target] == target;
  }
}
```

- 时间复杂度：$target$ 为数组总和的一半，$n$ 为数组元素个数。或者看两层循环的长度。共有 $target * n$ 个状态需要被转移，复杂度为 $O(target * n)$ 
- 空间复杂度：$O(target * n)$ 

### （3）优化空间

之前也说过动态规划优化空间。

+ 第 1 个方式是滚动数组，只存放两行数据，当前行和上一行，每次覆盖将下一行的值覆盖到上一行的位置
+ 第 2 个方式优化成一维数组，利用每次取数据的方向。因为每次取数据的是一个方向，**覆盖已经取数据的位置就行**。
  + 但循环是向右遍历从 `0` 到 `target - 1` ，而取数的方向是往左取的——`f[i - 1][j - t]` ，`j - t` 代表了是取左边的数，而之前左边的数被新数据覆盖，取不到旧数据。
  + 所以循环需要换个方向，从右往左循环 `for (int j = target; j >= 0; j--) {`

全部代码如下：

```java
class Solution {
  public boolean canPartition(int[] nums) {
    int n = nums.length;

    int sum = 0;
    for (int i : nums) sum += i;
    int target = sum / 2;

    if (target * 2 != sum) return false;

    // 将「物品维度」取消
    int[] f = new int[target + 1];
    for (int i = 0; i < n; i++) {
      int t = nums[i];
      // 将「容量维度」改成从大到小遍历
      for (int j = target; j >= 0; j--) {
        // 不选第 i 件物品
        int no = f[j];
        // 选第 i 件物品
        int yes = j >= t ? f[j-t] + t : 0;
        f[j] = Math.max(no, yes);
      }
    }
    // 如果最大价值等于 target，说明可以拆分成两个「等和子集」
    return f[target] == target;
  }
}
```

## 五十一、数据流中的第 K 大元素

原题链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485689&idx=1&sn=a0f92c80f91049d5ca5b0101274b14a6&chksm=fd9ca3e6caeb2af02b761d529eb833ab020694001c9ed7b0cd224dfdf615cb302ae8c28d6738&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「703. 数据流中的第 K 大元素」**，难度为 **「Easy」**。
>
> 设计一个找到数据流中第 k 大元素的类（class）。
>
> 注意是排序后的第 k 大元素，不是第 k 个不同的元素。
>
> 请实现 KthLargest 类：
>
> - KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
> - int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。
>
> 示例：
>
> + 输入：
>   + `["KthLargest", "add", "add", "add", "add", "add"]`
>   + `[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]`
>
> + 输出：
>   + `[null, 4, 5, 5, 8, 8]`
>
> + 解释：
>   + `KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);`
>   + `kthLargest.add(3);   // return 4`
>   + `kthLargest.add(5);   // return 5`
>   + `kthLargest.add(10);  // return 5`
>   + `kthLargest.add(9);   // return 8`
>   + `kthLargest.add(4);   // return 8`
>
> 提示：
>
> - 1 <= k <= 10^4^
> - 0 <= nums.length <= 10^4^
> -  -10^4^ <= nums[i] <= 10^4^
> -  -10^4^ <= val <= 10^4^
> - 最多调用 add 方法 10^4^ 次
> - 题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素

### （1）冒泡排序

+ 初始化时，不排序，只有在添加的时候再排序。
+ 使用列表：因为扩展数组的长度较容易

```java
class KthLargest {

  List<Integer> data = new ArrayList();

  int k;

  public KthLargest(int k, int[] nums) {
    this.k = k;
		// 不排序依次添加到列表
    for (int i : nums) {
      data.add(i);
    }
  }

  public int add(int val) {
    // 添加新的数字
    data.add(val);
    
    // 进行冒泡排序（降序）
    int n = data.size(); 
    for (int i = 0; i < k; i++) {
      // 找到最大值
      int maxIndex = findMax(i, n - 1);
      // 将最大值与当前位置的数字交换
      swapNum(i, maxIndex);
    }
    return data.get(k - 1);
  }

  public void swapNum(int a, int b) {
    int temp = data.get(a);
    data.set(a, data.get(b));
    data.set(b, temp);
  }

  // 在start和end下标之间找最大值
  public int findMax(int start, int end) {
    int max = Integer.MIN_VALUE / 2;
    int maxIndex = start;
    for (int i = start; i <= end; i++) {
      int tempNum = data.get(i);
      if (tempNum > max) {
        max = tempNum;
        maxIndex = i;
      }
    }
    return maxIndex;
  }
}
```

- 时间复杂度：$O(n * k)$
- 空间复杂度：$O(k)$
- 当 $n、k$  都很大时，就会超时。如果使用 Java 自带的排序进行排序，不会超时，但花费的时间依然很多

### （2）移动数字

其实 **没有必要在每次添加数字后进行排序**，因为第 1 次添加的时候已经排过一次序。后面添加的时候只需要找到新数字的位置，然后再将其余的数字往后移动。

```java
import java.util.Collections;
class KthLargest {

  int[] data;

  int length;

  int k;

  public KthLargest(int k, int[] nums) {
    this.k = k;
    this.data = nums;
    this.length = data.length;
		// 对数组进行排序（升序）
    Arrays.sort(data);
  }

  public int add(int val) {
    // 新建一个临时数组
    int[] tempArray = new int[++length];

    // 如果最开始的空的，不适合移动数字算法
    if (length == 1) {
      tempArray[0] = val;
      data = tempArray;
      return val;
    }
    
    int i = length - 1;
    for (; i > 0; i--) {
      if (val < data[i - 1]) {	// 如果新数比当前数字小，直接将数字往后移
        tempArray[i] = data[i - 1];
      } else {	// 如果新数大于等于当前数字，结束循环
        // 将新的数字放入空格中
        tempArray[i] = val;
        // 剩余的数字一一对应放入
        for (int j = 0; j < i; j++) {
          tempArray[j] = data[j];
        }
        break;
      }
    }
    
    // 如果将所有的数字全部移了一遍，
    // 则新数组里的第1格是空的，需要额外处理
    if (i == 0) {
      tempArray[0] = val;
    }
    // 更新对面的里数组
    data = tempArray;
    return data[length - k];
  }
}
```

+ 时间复杂度：
  + 排序：$O(nlogn)$
  + 调用 1 次 `add()` 方法：最差 $O(n)$ ，最好 $O(1)$
  + 所以最差情况，n 个数字添加，每次都要移动全部数字，$O(n^2)$
+ 空间复杂度：$O(n)$

### （3）小根堆

+ 小根堆：会自动排序的容器，最顶部是容器中的最小值。
+ 只存放 k 个数：因为我们使用到前面 k 个数，只有添加的数符合某些规则时，才会调整这 k 个数
  + 添加的数 <= 根顶元素：因为堆里面是 **数组里前 k 大的值**，如果添加的数小于或者等于第 k 大的值，则添加的数是第 k + x 大的数，我们永远不会使用到
  + 添加的数 > 根顶元素：一定会导致堆变化，而根顶的元素 **一定会被排除在前面 k 个数** ，所以直接
  + 小根堆的使用场景：**只在乎存的数值，不在乎在数组里的位置**。在 【四十八、跳跃游戏】中，虽然也是找滑动窗口的最大值，但是移除元素的时候是根据在数组的下标.

```java
class KthLargest {
  int k;
  PriorityQueue<Integer> queue;
  
  public KthLargest(int _k, int[] _nums) {
    k = _k;
    // 新建小根堆
    queue = new PriorityQueue<>(k, Integer::compare);
    int n = _nums.length;
    // 前 k 个数直接放入小根堆里
    for (int i = 0; i < k && i < n; i++) queue.add(_nums[i]);
    // 其他的数，调用add()方法来添加，以维持小根堆的长度
    for (int i = k; i < n; i++) add(_nums[i]);
  }
  
  public int add(int val) {
    // 如果小根堆是空，则无法取出根顶元素
    int t = !queue.isEmpty() ? queue.peek() : Integer.MIN_VALUE;
    // 只有两种场景才要操作
    // 1. 堆的长度没有够 k
    // 2. 堆满的时候，新数大于根顶
    if (val > t || queue.size() < k) {
      // 当堆满的时候才需要去除元素
      if (queue.size() >= k) {
        queue.poll();
      }
      // 因为无论是第1点还是第2点，都需要添加元素
      // 所以相同的操作提取出来
      queue.add(val);
    }
    return queue.peek();
  }
}
```

- 时间复杂度：最坏情况下，`n` 个元素入堆，都触发堆调整。调整一次堆排序就需要时间 $O(logk)$ ，所以总复杂度为 $O(nlogk)$
- 空间复杂度：$O(logk)$

## 五十二、分割等和子集2

原题链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485727&idx=1&sn=2cfb1a43bdb4f47cf4457c58f809deb8&chksm=fd9ca200caeb2b16e7c70ffe673886ba3577b3c084ec204a532cf4a5e0d46dc1b51b34970ba2&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「416. 分割等和子集」**，难度为 **Medium**。
>
> 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
> 注意:
>
> - 每个数组中的元素不会超过 100
> - 数组的大小不会超过 200
>
> 示例 1:
>
> + 输入: [1, 5, 11, 5]
>
> + 输出: true
>
> + 解释: 数组可以分割成 [1, 5, 5] 和 [11].
>
> 示例 2:
>
> + 输入: [1, 2, 3, 5]
>
> + 输出: false
>
> + 解释: 数组不能分割成两个元素和相等的子集.

### （1）分析

在【分割等和子集1】中，我们是 **间接** 得出结果。

+ 间接：先求出不超过某个值的最大值，再判断是否和某个值相等。

这次要改正使用，要 **直接** 得出结果

+ 直接：直接知道是否可以 **凑出** 指定数字。

### （2）实现

现在需要改变 **状态定义** 和 **转移方程**。

+ 状态定义：
  + `f[i - 1][j]` 代表不选当前数字，是否可以凑出；
  + `f[i - 1][j - nums[i]]` 代表选了当前数字，是否可以凑出
+ 转移方程：
  + 二维数组中存放的是 **布尔值**。
  + 第 1 行会遇到初始化问题，因为每个行都依靠上一行的数据。所以需要在第 1 行添加 **不考虑任何物品** 的情况。
  + 最终的转移方程是 $f[i][j] = f[i-1][j] \vee f[i][j-nums[i]]$
  + $i$ 的取值范围 $0 \sim n$ ；$j$ 的取值范围 $0 \sim target$

```java
class Solution {
  public boolean canPartition(int[] nums) {
    int n = nums.length;

    //「等和子集」的和必然是总和的一半
    int sum = 0;
    for (int i : nums) sum += i;
    int target = sum / 2;

    // 对应了总和为奇数的情况，注定不能被分为两个「等和子集」
    if (target * 2 != sum) return false;

    // f[i][j] 代表考虑前 i 件物品，能否凑出价值「恰好」为 j 的方案
    // 横坐标：0 ~ n，长度为 n + 1
    // 纵坐标：0 ~ target,长度为 target + 1
    boolean[][] f = new boolean[n + 1][target + 1];
    f[0][0] = true;
    
    // i的范围是0 ~ n，但第1行已初始化，循环的范围是1 ~ n
    for (int i = 1; i <= n; i++) {
      // 取 nums[] 的数 i 需要减 1，因为 nums 下标范围是 0 ~ n-1
      int t = nums[i - 1];
      for (int j = 0; j <= target; j++) {
        // 不选该物品
        boolean no = f[i - 1][j];
        // 选该物品
        boolean yes = j >= t ? f[i - 1][j - t] : false;
        f[i][j] = no | yes;
      }
    }
    return f[n][target];
  }
}
```

