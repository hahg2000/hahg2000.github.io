## 二十八、组合总和

原题链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484952&idx=1&sn=a268b086be9425bb56598d8cdf1996aa&chksm=fd9cad07caeb241173c9d524f9230a8fe4efa9d215a0ec1756152ed452b0a611c13ef7e14bba&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「39. 组合总和」**，难度为 **Medium**。
>
> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的数字可以无限制重复被选取。
>
> 说明：
>
> - 所有数字（包括 target）都是正整数。
> - 解集不能包含重复的组合。
>
> 示例 1：
>
> + 输入：candidates = [2,3,6,7], target = 7,
> + 所求解集为：[  [7],  [2,2,3] ]
>
> 提示：
>
> - 1 <= candidates.length <= 30
> - 1 <= candidates[i] <= 200
> - `candidate` 中的每个元素都是独一无二的。
> - 1 <= target <= 500

### （1）DFS+回溯

> 如何快速判断一道题是否应该使用 DFS + 回溯算法来爆搜。
>
> 总的来说，你可以从两个方面来考虑：
>
> - **「1. 求的是所有的方案，而不是方案数。」** 由于求的是所有方案，不可能有什么特别的优化，我们只能进行枚举。这时候可能的解法有动态规划、记忆化搜索、DFS + 回溯算法。
> - **「2. 通常数据范围不会太大，只有几十。」** 如果是动态规划或是记忆化搜索的题的话，由于它们的特点在于低重复/不重复枚举，所以一般数据范围可以出到 10^5^ ~ 10^7^，而 DFS + 回溯的话，通常会限制在 30 以内。
> -  这道题数据范围是 30 以内，而且是求所有方案。因此我们使用 DFS + 回溯来求解： 

动态规划的路线就相当于求出所有方案，所以当看到求出所有方案，而不是方案数，就可以考虑用动态规划。这道题目比较像背包问题，每次选择一个数，目标数减少，然后继续选择。

由于是无限制选择相同的数字：

+ 可以选择一个数字后进入下一个递归
+ 或者选择多个相同的数字后再进入下一个递归，下面代码为这种解法。
+ 下面代码有点与众不同：

1. **先压栈再添加到当前结果集**，所以会从原数组的最后一个数添加
2. 遍历当前数字的使用次数后，需要撤销所遍历的数字。
   1. 遍历使用次数的代码第 28 行—— `for (int i = 0; cs[u] * i <= t; i++)` 代表在到达 target 之前，不断增加当前数字的次数
   2. 撤销所遍历的数字需要移除一样的次数，所以循环的条件一样，如第 36 行

```java
class Solution {
  public List<List<Integer>> combinationSum(int[] cs, int t) {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> cur = new ArrayList<>();
    dfs(cs, t, 0, ans, cur);
    return ans;
  }

  /**
     * cs: 原数组，从该数组进行选数
     * t: 还剩多少值需要凑成。起始值为 target ，代表还没选择任何数；当 t = 0，代表选择的数凑成了 target
     * u: 当前决策到 cs[] 中的第几位
     * ans: 最终结果集
     * cur: 当前结果集
     */
  void dfs(int[] cs, int t, int u, List<List<Integer>> ans, List<Integer> cur) {
    // 如果target为0则添加到结果里并返回
    if (t == 0) {
      ans.add(new ArrayList<>(cur));
      return;
    }
    
    // 如果选择的数字为最后一个或者target小于0则返回上一个递归
    // 因为没有排序，所以当选择的数字为最后一个，target大于0的情况存在
    if (u == cs.length || t < 0) return;

    // 枚举 cs[u] 的使用次数，使用零次、一次以及多次
    for (int i = 0; cs[u] * i <= t; i++) {
      dfs(cs, t - cs[u] * i, u + 1, ans, cur);
      // 由于每次
      cur.add(cs[u]);
    }
    
    // 进行回溯，将之前添加去掉。
    // 注意回溯总是将数组的最后一位弹出
    for (int i = 0; cs[u] * i <= t; i++) {
      cur.remove(cur.size() - 1);
    }
  }
}
```

- 时间复杂度：由于每个数字的使用次数不确定，因此无法分析具体的复杂度。但是 DFS 回溯算法通常是指数级别的复杂度（因此数据范围通常为 30 以内）。这里暂定 O ( n * 2^n^ )
- 空间复杂度：同上。复杂度为 O ( n * 2^n^ )

## 二十九、组合总和2

原题链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484964&idx=1&sn=9ab54e6eaf9b0298724a1be8e507f62d&chksm=fd9cad3bcaeb242d8390a2c4196c0811d1520c13ea7f7eb705bdfbe9deb67d60d7655ac50c87&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「40. 组合总和 II」**，难度为 **Medium**。
>
> 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用一次。
>
> 说明：
>
> - 所有数字（包括目标数）都是正整数。
> - 解集不能包含重复的组合。
>
> 示例 1:
>
> + 输入: candidates = [10,1,2,7,6,1,5], target = 8
> + 所求解集为:[ [1, 7],  [1, 2, 5],  [2, 6],  [1, 1, 6] ]

### （1）DFS+回溯

该题目与上一道题很类似，但这道题要求每个数字只能用一次。可以按照模板来解决问题，但也可以 **使用每个数字只能用一次** 的特点，每个数字只有两种状态，选择或者不选择，所以就不需要循环来确定第 n 个数是哪个数字了。即不用确定答案的第 1 个数是数组中第 1 个数还是第 2 个数、答案的第 2 个数是第 3 个数还是第 n 个数。

只用将每一个数字的两个状态 **全部组合一次**，再看是否符合要求。注意要去重，所以要【排序 + Set集合】。

需要去重证明：假设 candidates = [1, 1, 1, 1, 3]，target = 5。答案会得到多个 [1, 1, 3]，因为有在 4 个数字中，取其中两个，可以取到 6 种不同的结果。下标分别为 [ [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3] ]

核心代码：**每层递归都会调用两个下层递归**，第 5 行和第 11 行，分别代表该层的数字是否使用

```java
// 使用 cs[u]
cur.add(cs[u]);

// 进行递归
dfs(cs, t - cs[u], u + 1, ans, cur);

// 进行回溯
cur.remove(cur.size() - 1);

// 不使用 cs[u]
dfs(cs, t, u + 1, ans, cur);
```

### （2）全部代码

```java
class Solution {
  public List<List<Integer>> combinationSum2(int[] cs, int t) {
    Arrays.sort(cs);
    Set<List<Integer>> ans = new HashSet<>();
    List<Integer> cur = new ArrayList<>();
    dfs(cs, t, 0, ans, cur);
    return new ArrayList<>(ans);
  }

  /**
     * cs: 原数组，从该数组进行选数
     * t: 还剩多少值需要凑成。起始值为 target ，代表还没选择任何数；当 t = 0，代表选择的数凑成了 target
     * u: 当前决策到 cs[] 中的第几位
     * ans: 最终结果集
     * cur: 当前结果集
     */
  void dfs(int[] cs, int t, int u, Set<List<Integer>> ans, List<Integer> cur) {
    if (t == 0) {
      ans.add(new ArrayList<>(cur));
      return;
    }
    if (u == cs.length || t < 0) return;

    // 使用 cs[u]
    cur.add(cs[u]);
    
    // 进行递归
    dfs(cs, t - cs[u], u + 1, ans, cur);

    // 进行回溯
    cur.remove(cur.size() - 1);
    
    // 不使用 cs[u]
    dfs(cs, t, u + 1, ans, cur);
  }
}
```

- 时间复杂度： DFS 回溯算法通常是指数级别的复杂度（因此数据范围通常为 30 以内）。这里暂定 。这里暂定 O ( n * 2^n^ )
- 空间复杂度：同上。复杂度为 O ( n * 2^n^ )

## 三十、组合总和3

原题链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484985&idx=1&sn=7b34d7445e98f5c4365714f93d3a3f52&chksm=fd9cad26caeb24304fff97709e7262c3bc569bde50c923ba8f878328fd2d034cbb564d2d1eaa&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「216. 组合总和 III」**，难度为 **Medium**。
>
> 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
>
> 说明：
>
> - 所有数字都是正整数。
> - 解集不能包含重复的组合。
>
> 示例 1:
>
> + 输入: k = 3, n = 7
> + 输出: [ [1,2,4] ]
>
> 示例 2:
>
> + 输入: k = 3, n = 9
> + 输出: [ [1,2,6], [1,3,5], [2,3,4] ]

### （1）DFS+回溯

这道题依然是不能使用重复的数字，所以就可以使用 总和2 的方法，把