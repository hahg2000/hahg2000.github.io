# 算法六

## 四十一、用栈实现队列

原题链接：

https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485449&idx=1&sn=91d22371d76fdb58508b596798288430&chksm=fd9ca316caeb2a005aac5e79d9e8fde74e3294ef117160233881ab32d915c8ec4bc255ec7e24&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「232. 用栈实现队列」**，难度为 **Easy**。
>
> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
>
> 实现 MyQueue 类：
>
> - void push(int x) 将元素 x 推到队列的末尾
> - int pop() 从队列的开头移除并返回元素
> - int peek() 返回队列开头的元素
> - boolean empty() 如果队列为空，返回 true ；否则，返回 false
>
> 说明：
>
> - 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
> - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
>
> 进阶：
>
> - 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。
>
> 提示：
>
> - 1 <= x <= 9
> - 最多调用 100 次 push、pop、peek 和 empty
> - 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）

### （1）O(n)解法

做这道题需要了解栈和队列的特点，栈是末尾进，末尾出；队列末尾进，开头出。

用栈模拟队列实际就是 **将栈底的元素弹出**。在日常生活可知，想要拿箱底的东西，必须要将东西上面的东西全部拿出来，才能拿到箱底的东西。

例如下面所示，依次放入 1、2、3、4、5

| 栈底 |      |      |      | 栈顶 |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    | 5    |

此时需要将 1 取出，则需要将 2 3 4 5 全部取出

+ 临时栈：

| 栈底 |      |      |      | 栈顶 |
| ---- | ---- | ---- | ---- | ---- |
| 5    | 4    | 3    | 2    |      |

+ 主栈：

| 栈底 |      |      |      | 栈顶 |
| ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |

如果这时要放入元素 6，这再次需要将临时栈的元素放入到主栈中，然后再放入

+ 主栈：

| 栈底 |      |      |      | 栈顶 |
| ---- | ---- | ---- | ---- | ---- |
| 2    | 3    | 4    | 5    | 6    |

由上可知，**无论是取出还是放入都需要将在两个栈之间倒腾元素**。

下面为完整代码：

- `in` 栈（主栈）用作处理输入操作 `push()`，使用 `in` 时需确保 `out` 为空
- `out` 栈（临时栈）用作处理输出操作 `pop()` 和 `peek()`，使用 `out` 时需确保 `in` 为空

```java
class MyQueue {
  Deque<Integer> out, in;
  public MyQueue() {
    in = new ArrayDeque<>();
    out = new ArrayDeque<>();
  }

  public void push(int x) {
    // 将out栈元素全部清空
    while (!out.isEmpty()) in.addLast(out.pollLast());
    in.addLast(x);
  }

  public int pop() {
    // 将in栈元素全部清空
    while (!in.isEmpty()) out.addLast(in.pollLast());
    return out.pollLast();
  }

  public int peek() {
    // 将in栈元素全部清空
    while (!in.isEmpty()) out.addLast(in.pollLast());
    return out.peekLast();
  }

  public boolean empty() {
    return out.isEmpty() && in.isEmpty();
  }
}
```

- 时间复杂度：$ O( n )$
- 空间复杂度：$ O( n )$

### （2）均摊O(1)解法

在将主栈的元素放入到临时栈后，会发现临时栈的已经排列成需要的形状了。

例如下面所示：

+ 原先的栈：

| 栈底 |      |      |      | 栈顶 |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    | 5    |

+ 临时栈：由原先的栈可知，当 1 取出后下一个要取出 2，而临时栈中正好能够取出 2

| 栈底 |      |      |      | 栈顶 |
| ---- | ---- | ---- | ---- | ---- |
| 5    | 4    | 3    | 2    |      |

而当放入元素时，因为处于模拟队列的队尾，所以在临时栈为空之前，都取不到新元素。所以**当临时栈为空时，再将主栈的元素放到临时栈里**。

下面为全部代码：

```java
class MyQueue {
  Deque<Integer> out, in;
  
  public MyQueue() {
    in = new ArrayDeque<>();
    out = new ArrayDeque<>();
  }

  public void push(int x) {
    // 直接放入，不用倒腾
    in.addLast(x);
  }

  public int pop() {
    // 如果临时栈为空，则将主栈倒腾放入到临时栈里
    if (out.isEmpty()) {
      while (!in.isEmpty()) out.addLast(in.pollLast());
    }
    return out.pollLast();
  }

  public int peek() {
    if (out.isEmpty()) {
      while (!in.isEmpty()) out.addLast(in.pollLast());
    }
    return out.peekLast();
  }

  public boolean empty() {
    return out.isEmpty() && in.isEmpty();
  }
}
```

- 时间复杂度：`pop()` 和 `peek()` 操作都是均摊 $O( 1 )$
- 空间复杂度：$O( n )$

### （3）均摊复杂度

我们先用另外一个例子来理解「均摊复杂度」，大家都知道「哈希表」底层是通过数组实现的。

正常情况下，计算元素在哈希桶的位置，然后放入哈希桶，复杂度为 $O( 1 )$，假定是通过简单的 “ 拉链法 ” 搭配「头插法」方式来解决哈希冲突。

但当某次元素插入后，「哈希表」达到扩容阈值，则需要对底层所使用的数组进行扩容，这个复杂度是 $O( n )$

**显然「扩容」操作不会发生在每一次的元素插入中**，因此扩容的 $O( n )$ 都会伴随着 `n` 次的 $O( 1 )$，换句话就是你插入了 n 个元素，就会触发一次 $O( n )$ 的扩容，这样 $O( n )$ 的复杂度会被均摊到每一次插入当中，因此哈希表插入仍然是 $O( 1 )$ 的。

**「同理，我们的「倒腾」不是发生在每一次的「输出操作」中，而是集中发生在一次「输出栈为空」的时候，因此 `pop` 和 `peek` 都是均摊复杂度为 的操作。」**

我们需要对操作进行复杂度分析进行判断，而不是看时间来判断自己是不是均摊 O(1) 哦 ~

## 四十二、用队列实现栈

原题链接：

https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485519&idx=1&sn=cd984987eb9e03493b1e775794b79971&chksm=fd9ca350caeb2a4623f2d8d71bc0f12a1f7ae38ca5e0301f97a01742782cbca3f1ed21da801c&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「225. 用队列实现栈」**，难度为 **Easy**。
>
> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。
>
> 实现 MyStack 类：
>
> - void push(int x) 将元素 x 压入栈顶。
> - int pop() 移除并返回栈顶元素。
> - int top() 返回栈顶元素。
> - boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
>
> 注意：
>
> 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
>
> 提示：
>
> - 1 <= x <= 9
> - 最多调用100 次 push、pop、top 和 empty
> - 每次调用 pop 和 top 都保证栈不为空
>
> 进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。

### （1）双队列解法

和上一道题思路一致，需要额外一个队列，作为临时存放数据的地方。例如下面所示：

+ 主队列：

| 队头 |      |      |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    | 5    |

现在需要弹出 5，但只能将前面的 1 - 4 先存放到临时队列中

+ 临时队列

| 队头 |      |      |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    |      |

+ 主队列：

| 队头 |      |      |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 5    |      |      |      |      |

和上一题一样，不用每次都倒腾，放入可以直接放入到临时队列或者主队列中，弹出元素再倒腾到另一个队列中。或者放入时倒腾，弹出时直接弹出。

+ 全部代码如下：下面代码为弹出时倒腾。
  + `data` 为主队列
  + `help` 为临时队列
  + 但这两个队列其实不用分得太清楚，因为都可以互相转换

```java
class MyStack {
  // 主队列
  Deque<Integer> data = new ArrayDeque<>();
  // 临时队列
  Deque<Integer> help = new ArrayDeque<>();

  public void push(int x) {
    // 直接放入数据即可
    data.addLast(x);
  }

  public int pop() {
    // 将主队列的数据放入到临时队列
    while (data.size() > 1) {
      help.addLast(data.pollFirst());
    }
    int u = data.pollFirst();
    // 将主队列和临时队列调换
    swap();
    return u;
  }

  public int top() {
    while (data.size() > 1) {
      help.addLast(data.pollFirst());
    }
    int u = data.peekFirst();
    help.addLast(data.pollFirst());
    swap();
    return u;
  }

  public boolean empty() {
    return data.isEmpty() && help.isEmpty();
  }

  void swap() {
    Deque<Integer> tmp = data;
    data = help;
    help = tmp;
  }
}
```

- 时间复杂度： `push()` 和 `empty()` 方法的复杂度为 $O( 1 )$ ；而 `pop()` 和 `top()` 的复杂度为 $O( n )$ 。
- 空间复杂度：$O( n )$

### （2）单队列解法

由第 （1） 点可知：经过倒腾后的队列，里面的排序没有变化，就如同弹栈，栈底的排序不会变化，例如下面所示

+ 主队列：

| 队头 |      |      |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    | 5    |

现在需要弹出 5，但只能将前面的 1 - 4 先存放到临时队列中

+ 临时队列：1 - 4 的排序没有变化

| 队头 |      |      |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    |      |

我们可以使用这个特效来简化成只使用一个队列。就像体育课同学先按高到低排好队，然后老师让同学从低到高排队，这时只需要第一个同学走到最后一个，然后后面的同学就依次跟着前面的同学，直到最后一个同学位置。

全部代码如下：

```java
class MyStack {
  Deque<Integer> data = new ArrayDeque<>();

  public void push(int x) {
    data.addLast(x);
  }

  public int pop() {
    int size = data.size();
    // 将最前面的元素依次放到最后面
    while (size-- > 1) {
      data.addLast(data.pollFirst());
    }
    // 去掉目标元素
    return data.pollFirst();
  }

  public int top() {
    int size = data.size();
    while (size-- > 1) {
      data.addLast(data.pollFirst());
    }
    // 取目标元素的值
    int u = data.peekFirst();
    // 将目标元素也添加到最后面，还原成之前的样子
    data.addLast(data.pollFirst());
    return u;
  }

  public boolean empty() {
    return data.isEmpty();
  }
}
```

- 时间复杂度： `push()` 和 `empty()` 方法的复杂度为 $O( 1 )$ ；而 `pop()` 和 `top()` 的复杂度为 $O( n )$ 。
- 空间复杂度：$O( n )$

### （3）总结

第四十一题和第四十二题，都是用队列或者栈其中一个，来模拟另一个，但实现思路完全不同。

其实就是队列和栈的特性导致的：

+ 队列添加元素和删除元素的位置 **不是同一个位置**。这就可以让队列删除的同时添加元素，所以就可以缩减成一个队列。这个特性在其他领域也很常见，例如消息队列，你发送消息，我就放到队尾，而我在队头处理消息，一点都不受影响。
+ 栈添加元素和删除元素的位置 **是同一个位置**。这个特性就让在操作栈的时候，必须明确是添加元素还是删除元素。在操作系统保存现场信息的时候使用，可以明确还原现场的顺序。

## 四十三、最小栈

原题链接：

https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485547&idx=1&sn=22a592f1c62b69af177845ef85a686fd&chksm=fd9ca374caeb2a628610fa4fbdd951f209b5989e2d4de900ab0c302e19a143ea3cdcc6bcf773&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「155. 最小栈」**，难度为 **Easy**。
>
> 设计一个支持 push ，pop ，top 操作，并能在「常数时间」内检索到最小元素的栈。
>
> - push(x) —— 将元素 x 推入栈中。
> - pop() —— 删除栈顶的元素。
> - top() —— 获取栈顶元素。
> - getMin() —— 检索栈中的最小元素。
> - 提示：
>   - pop、top 和 getMin 操作总是在「非空栈」上调用。

### （1）思路

这题的难点是在常数时间检索到最小元素。通常会拿一个变量来存放最小值。每次弹栈需要判断弹栈的元素是否为最小值。

但又有一个问题，如果弹的是最后一个最小值，则需要获取到次小值，这个要求需要将每个元素排列好。

还有一个问题，如何知道这是最后一个最小值，所以需要记录最小值的数量。

这三个要求，其实多用一个栈就可以全部解决。这个栈的要求：

+ 当放入的元素比第一个元素大，则在栈顶多复制第一个元素
+ 当放入的元素比第一个元素小，则直接放入到栈里
+ 弹栈的时候和主栈同步

### （2）解法详情

下面假设输入 `[2, 6, 2, 8, 4, 6, 5]`

辅助栈的结构如下：

+ 首先入 2。然后入 6，6 大于 2，则改成入 2

| 下标 | 数据 |
| ---- | ---- |
| 0    |      |
| 1    |      |
| 2    |      |
| 3    |      |
| 4    |      |
| 5    | 2    |
| 6    | 2    |

+ 然后入 2。入 8 ，8 大于 2 则改成入 2。后面的数都大于 2，所以也都是入 2

| 下标 | 数据 |
| ---- | ---- |
| 0    | 2    |
| 1    | 2    |
| 2    | 2    |
| 3    | 2    |
| 4    | 2    |
| 5    | 2    |
| 6    | 2    |

看上面的辅助栈，全部是 2，是因为 2 在栈底，只要入栈的元素大于 2，则栈中的最小值还是 2。

上面的例子是全部入栈后再全部弹栈，如果在弹栈入栈的过程中，涉及到最小值的变化，会不会有问题呢？

例如先入栈 `[6, 5, 3, 6]` ，然后再弹栈两个，再入栈 `[4, 7]`

+ 入栈 `[6, 5, 3, 6]` ，这时最小值为 3

| 下标 | 数据 |
| ---- | ---- |
| 0    | 3    |
| 1    | 3    |
| 2    | 5    |
| 3    | 6    |

+ 弹栈两个，这时最小值为 5

| 下标 | 数据 |
| ---- | ---- |
| 0    |      |
| 1    |      |
| 2    | 5    |
| 3    | 6    |

+ 再入栈 `[4, 7]` ，最小值为 4

| 下标 | 数据 |
| ---- | ---- |
| 0    | 4    |
| 1    | 4    |
| 2    | 5    |
| 3    | 6    |

很明显，没有任何问题。辅助栈的使用解决了第（1）点提出的问题：

+ 栈顶存放了最小值，最小值的数值问题解决
+ 记录了最后一个最小值的下标，可以知道最后一个最小值是否被弹出
+ 因为入栈元素等于最小值，也会直接入栈，栈里就会有多个最小值，所以记录了最小值的数量

其实这个栈的核心就是：

+ 在最小值还没弹出之前，最小值上面的元素怎么操作，**都不会影响到最小值和次小值**，除非加入了比最小值小的数，但之前的最小值和次小值的 **顺序还是保持不变**

### （3）全部代码

```java
class MinStack {
  Deque<Integer> data = new ArrayDeque<>();
  Deque<Integer> help = new ArrayDeque<>();

  public void push(int val) {
    data.addLast(val);
    // 如果栈为空或者比最小值小，则直接入栈
    if (help.isEmpty() || help.peekLast() >= val) {
      help.addLast(val);
    } else {	// 否则复制最小值
      help.addLast(help.peekLast());
    }
  }

  public void pop() {
    // 两个栈同时弹出
    data.pollLast();
    help.pollLast();
  }

  public int top() {
    return data.peekLast();
  }

  public int getMin() {
    // 取出辅助栈的第1个元素
    return help.peekLast();
  }
}
```

- 时间复杂度：所有的操作均为 $ O( 1 ) $
- 空间复杂度：$ O( 1 ) $

## 四十四、最大得分的路径数目

原题链接：

https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485565&idx=1&sn=9d307e3ef239d9ba509624736408fc3c&chksm=fd9ca362caeb2a7400a621755acffc51c9eabbade8bd2e0dec07ef4c8c7ffae4a98b84b9243e&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 这是 LeetCode 上的**「1301. 最大得分的路径数目」**，难度为 **Hard**。
>
> 给你一个正方形字符数组 board ，你从数组最右下方的字符 'S' 出发。
>
> 你的目标是到达数组最左上角的字符 'E' ，数组剩余的部分为数字字符 1,2,...,9 或者障碍 'X'。
>
> 在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。
>
> 一条路径的 「得分」 定义为：路径上所有数字的和。
>
> 请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 10^9 + 7 取余。
>
> 如果没有任何路径可以到达终点，请返回 [0, 0] 
>
> 示例 1：
>
> + 输入：board = ["E23","2X2","12S"]
> + 输出：[7,1]
> + 解释：上 -> 上 -> 左 -> 左，2 + 3 + 2 = 7，1 条路径
>
> ```
> E  2  3
> 2  X  2
> 1  2  S
> ```
>
> 示例 3：
>
> + 输入：board = ["E11","XXX","11S"]
> + 输出：[0,0]
> + 解释：路全部被封死，走不到终点
>
> ```
> E  1  1
> X  X  X
> 1  1  S
> ```
>
> 提示：
>
> - 2 <= board.length == board[i].length <= 100

### （1）动态规划

这道题之前也做过类似的，也是有障碍的，但

## 四十五、在系统中查找重复文件

原题链接：

https://leetcode.cn/problems/find-duplicate-file-in-system/

> 这是力扣上的 **【609. 在系统中查找重复文件】**，难度为 **普通**
>
> 给你一个目录信息列表 paths ，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按 **任意顺序** 返回。
>
> 一组重复的文件至少包括 **两个** 具有完全相同内容的文件。
>
> **输入** 列表中的单个目录信息字符串的格式如下：
>
> + "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"
>
> 这意味着，在目录 `root/d1/d2/.../dm` 下，有 n 个文件 ( `f1.txt, f2.txt ... fn.txt` ) 的内容分别是 ( `f1_content, f2_content ... fn_content` ) 。
>
> 注意：n >= 1 且 m >= 0 。如果 m = 0 ，则表示该目录是根目录。
>
> **输出** 是由 **重复文件路径组** 构成的列表。其中每个组由所有具有相同内容文件的文件路径组成。文件路径是具有下列格式的字符串：
>
> + "directory_path/file_name.txt"
>
>
> 示例 1：
>
> + 输入：`paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]`
> + 输出：`[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]`

### （1）Java代码

这道题一长串，其实就是 **考验处理字符串**。麻烦的是 Java 处理字符串没有很多方法。就只能一个个处理。

思路：题目要求找到文本内容相同的文件，文件内容（1）-> 文件（n），一对多关系，很明显使用哈希表 + 列表就比较简单。

这道题的难点：

1. 使用正则表达式处理字符串
2. 看明白题目要求。例如，**只返回重复了的文件名**，不是返回曾经出现过的文件名。

完整代码如下：

```java
class Solution {
  public List<List<String>> findDuplicate(String[] paths) {
    // 新建存放结果的哈希表
    Map<String, List<String>> map = new HashMap<>();
    
    // 遍历数组的每一个元素，每个元素是一长串字符串
    for (int i = 0; i < paths.length; i++) {
      // 取出字符串
      String string = paths[i];
      // 取出文件名和文件内容
      String suffix = string.replaceFirst("^([^\\s]+ )", "");
      // 计算出文件路径的长度
      int prefixLength = string.length() - suffix.length();
      // 取出文件路径
      String prefix = string.substring(0, prefixLength);
      // 将一长串字符串分割成数组
      String[] fileNameArray = suffix.split(" ");
      
      // 遍历结果数组
      for (int j = 0; j < fileNameArray.length; j++) {
        // 取出数组中的每一个元素，元素内容包括每一个文件名和文件内容
        String index = fileNameArray[j];
        // 取出文件名
        String fileName = index.replaceFirst("\\(.*?\\)", "");
        // 取出文件内容
        String content = index.substring(fileName.length() + 1, index.length() - 1);
        // 如果第一次放入到哈希表，则新建一个列表
        if (!map.containsKey(content)) {
          map.put(content, new ArrayList<String>());
        }
        // 将拼接后的字符串加入到哈希表中的列表中
        map.get(content).add(prefix.substring(0, prefixLength - 1) + "/" + fileName);
      }
    }
    
    List<List<String>> res = new ArrayList<>();
    // 遍历哈希表中的内容 
    for (Map.Entry<String, List<String>> entry : map.entrySet()) {
      // 取出 key
      String key = entry.getKey();
      // 取出 value
      List<String> val = entry.getValue();
      // 只有列表的长度大于2，才是要的结果
      if (val.size() >= 2) {
        res.add(val);
      }
    }
    return res;
  }
}
```

### （2）JS代码

在 Javascript 中，有很多操作字符串的方法，所以 Javascript 代码会比较简洁。

代码来自力扣题解：

https://leetcode.cn/problems/find-duplicate-file-in-system/solution/js-qing-jiao-wo-jsde-gong-ju-han-shu-xia-73gj/

```js
var findDuplicate = function (paths) {
  // ans Array 存放最终结果 每一个元素是拥有相同内容的多个文件
  // map Object 存放文本的内容 [key-文本内容, value-map的下标]
  const map = {}, ans = [];
  
  for (const path of paths) {
    // ES6新语法
    // 将字符串以空格分开然后依次赋值到 root 和 files 变量
    // root为字符串，files为数组
    const [root, ...files] = path.split(' ');
    
    // 然后遍历files数组
    for (const file of files) {
      // 将字符串再以"("分隔
      // 例如，4.txt(efgh) 分割成 4.txt efgh)
      const [filename, content] = file.split('(');
      if (content in map) {	// 如果文本内容在map里，则直接往map放入数据
    		// 在map取出下标后，再去ans里取对应的数组
        ans[map[content]].push(`${root}/${filename}`);
      } else {	// 如果不在，则要将数据放入map里，用作之后的判断
        // push()方法会返回数组的长度
        // 长度-1 作为ans的下标
        map[content] = ans.push([`${root}/${filename}`]) - 1;
      }
    }
  }
  // 最后将长度大于2的数组返回
  return ans.filter(arr => arr.length > 1);
};

```

## 四十六、贴纸拼词

原题链接：

https://leetcode.cn/problems/stickers-to-spell-word/

> 这是 LeetCode 上的**【691. 贴纸拼词】**，难度为 **Hard**。
>
> 我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。
>
> 您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。
>
> 返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。
>
> 注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。
>
> 示例 1：
>
> + 输入： stickers = ["with","example","science"], target = "thehat"
> + 输出：3
> + 解释：我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。
>   把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。
>   此外，这是形成目标字符串所需的最小贴纸数量。

### （1）动态规划

下面是

```java
class Solution {
  String[] s;

  int res = -1;

  public int minStickers(String[] stickers, String target) {
    int m = stickers.length;
    int n = target.length();
    s = stickers;

    dfs(0, target, 0);

    return res;

  }

  private void dfs(int count, String target, int depth) {

    if (target.equals("")) {
      if (res == -1) {
        res = count;
      }
      res = res < count ? res : count;
      return;
    }
    if (depth >= s.length) {
      return;
    }

    // 变化的字符串
    String newString = target;
    // 存放上一次的字符串
    String temp = "";
    int useCount = count;
    do {
      dfs(useCount, newString, depth + 1);
      temp = newString;
      newString = deleteChar(s[depth], newString);
      useCount++;
    } while (!newString.equals(temp));
  }

  public String deleteChar(String sub, String oldString) {
    String newString = oldString;
    for (int i = 0; i < sub.length(); i++) {
      String item = sub.charAt(i) + "";
      newString = newString.replaceFirst(item, "");
    }
    return newString;
  }
}
```



```java
/**
     * 相当于每一次可以任意选择1张贴纸，这张贴纸上的部分字符可以为凑出target做出贡献，问至少需要几张贴纸，才能凑出target
     */

int n;

int[] memo;


/**
     * 方法一：dfs
     * 需要考虑的是，对于任意一张贴纸，使用当前贴纸后(假设每个字符都做出最大贡献)，能够得到什么样的字符串
     * 我们最终要得到target，所以我们可以 用 0 或 1表示 target 每一位置上的字符是否已经凑出，因为 target长度在1-15之间，
     * 所以我们可以用1个int变量state完成这件事，
     * 初始时：state = 0，每个字符都没凑出来
     * 如果能凑出target，最终 state就是 2^(target.length)-1，也就是 target.length()个1，表示每个位置都被凑到了
     * 为了避免某些状态重复搜索，我们还需要一个memo数组来做备忘录，因为一共有 2^(target.length) 个状态（state取值为0-1<<len-1），所以数组大小为 1<< len
     *
     * 那么，假设当前状态为state，选择 某个 贴纸 sticker时，能得到什么样的新状态
     *
     * 遍历 sticker 的每个字符 s[i]
     *      遍历 target 的每个字符 t[j]
     *          if (s[i] == t[j] && state & (1 << j) == 0) 说明此时t[j]还未被凑出，并且s[i] 能凑出 t[j]，那么state第j个位置变为1
     *          break；s[i]对当前字符做出贡献后，就该考虑s[i+1]为哪个位置做贡献了，并且因为state已经更新，所以不会出现s[i+1]仍然为t[j]贡献的情况
     *                  这里不要先统计s每个字符出现次数，再统计t每个字符出现次数，又逐一比较，更新，这样是做不到明确target每个位置是否被凑出的，也就是得不到新的state
     * 因为每次可以选择任意一个贴纸，所以 遍历s前要准备一个 state的备份nstate，在遍历过程中使用的也是nstate
     * 并且，如果遍历完成后，nstate==state，说明当前贴纸对当前状态已再无贡献，直接换下一个贴纸
     * 否则·从当前状态 到 target 所需要的贴纸数 就是 1(使用当前贴纸) + dfs(nstate)
     *
     * 然后从多个选择的结果中选择结果最小的（所以，先给一个不可能的结果）
     *
     * 并且，当 state == 1<<n-1时，返回0，
     *
     *
     * @param stickers
     * @param target
     * @return
     */
public int minStickers(String[] stickers, String target) {
  // 记录target长度
  n = target.length();
  // 备忘录，注意初始化大小
  memo = new int[1 << n];
  // 标记备忘录
  Arrays.fill(memo, -1);
  // 如果凑不出来target，返回的是个不可能的值，这里用 n + 1代替
  int ans = dfs(stickers, target, 0);
  return ans > n ? - 1: ans;
}

/**
     * dfs，当前状态是 state（二进制第j位为1代表target[j]已经凑出）
     * 返回从当前状态凑出target需要的最少贴纸数
     * @param stickers
     * @param target
     * @param state
     * @return
     */
private int dfs(String[] stickers, String target, int state) {
  // target每个字符全部凑出
  if (state == (1 << n) - 1) {
    return 0;
  }
  // 已计算过
  if (memo[state] != -1) {
    return memo[state];
  }
  // 可以选择任意一张贴纸，选择结果最小的选择，先给个不可能的值
  int ans = n + 1;
  // 任意选一张贴纸
  for (String sticker : stickers) {
    // 先做state的备份
    int nstate = state;
    // 考虑贴纸s每个字符能做出的贡献
    for (char c: sticker.toCharArray()) {
      for (int j = 0; j < n; ++j) {
        // 如果s[i]恰好能凑上t[j]（前提是t[j]还未被凑出，注意这里用的是nstate）
        if (c == target.charAt(j) && ((nstate >> j) & 1) == 0) {
          // 标记t[j]被凑出
          nstate |= (1 << j);
          // 考虑是[i+1]做贡献
          break;
        }
      }
    }
    // 的确做出了贡献
    if (nstate != state) {
      // 选择当前贴纸，完成整个过程所需要的最小贴纸数
      // 多个选择中选最优
      ans = Math.min(ans, 1 + dfs(stickers, target, nstate));
    }
  }
  // 更新备忘录并返回
  memo[state] = ans;
  return ans;
}


/**
     * 思路不变，使用 bfs, 每次可以 选择任意一张贴纸。选择不同贴纸就会得到不同邻接状态
     * 按照 bfs 【齐头并进】特点，最先 达到 终极状态 (1<<n-1)时，返回 step(看作多叉树数层序遍历的话，对应最小的叶子节点层数)即可
     * @param stickers
     * @param target
     * @return
     */
public int minStickers2(String[] stickers, String target) {
  n = target.length();
  return bfs(stickers, target);
}

/**
     * bfs，当前状态是 state（二进制第j位为1代表target[j]已经凑出）
     * 
     * 每个节点 有 stickers.length 种邻接选项，选择不同贴纸，得到不同邻接状态
     *
     * @param stickers
     * @param target
     * @return
     */
private int bfs(String[] stickers, String target) {
  int step = 0;
  Deque<Integer> queue = new ArrayDeque<>();
  // bfs不需要备忘录，但要避免节点重复访问
  Set<Integer> set = new HashSet<>();
  // 初始状态
  queue.offer(0);
  set.add(0);
  while (!queue.isEmpty()) {
    // 当前层 节点个数
    int sz = queue.size();
    // 逐个取出当前层节点，找到他们的邻接点，加入下一层队列
    for (int i = 0; i < sz; ++i) {
      Integer state = queue.poll();
      // 发现目标状态，返回 step
      if (state == (1 << n) - 1) {
        return step;
      }
      // 找寻全部邻接点
      // 任意选一张贴纸
      for (String sticker : stickers) {
        // 先做state的备份
        int nstate = state;
        // 考虑贴纸s每个字符能做出的贡献
        for (char c: sticker.toCharArray()) {
          for (int j = 0; j < n; ++j) {
            // 如果s[i]恰好能凑上t[j]（前提是t[j]还未被凑出，注意这里用的是nstate）
            if (c == target.charAt(j) && ((nstate >> j) & 1) == 0) {
              // 标记t[j]被凑出
              nstate |= (1 << j);
              // 考虑是[i+1]做贡献
              break;
            }
          }
        }
        // 的确做出了贡献 并且 邻接状态没访问过
        if (nstate != state && !set.contains(nstate)) {
          // 邻接状态入队列
          queue.offer(nstate);
          // 标记邻接状态已访问
          set.add(nstate);
        }
      }
    }
    // 齐头并进
    step++;
  }
  // 不在bfs过程中返回，就是无法凑出target
  return -1;
}
```

