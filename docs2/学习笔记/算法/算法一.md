# 算法一

## 一、正则表达式匹配

### （1）略解

原链接：https://mp.weixin.qq.com/s/Khts_1iw--oWPxe0f4AoMg

题目：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `.` 匹配任意单个字符
- `*` 匹配零个或多个前面的那一个元素

简单来说：就是实现 `.` 和 `*` 的功能。普通的两个字符串比较，涉及到 KMP 算法。

这个因为需要判断 `*` 全部所匹配到的字符， 所以需要用到 **动态规划**。

+ 状态定义：`f(i,j)` 代表 `s` 中以 `i` 下标为结尾的子串和 `p` 中的以 `j` 下标为结尾的子串是否匹配。
+ 状态转移：也就是我们要考虑 `f(i,j)` 如何求得，前面说到了 `p` 有三种字符，所以这里的状态转移也要分三种情况讨论：

1. 如果 `p[j]` 为普通字符，则在前面的基础上，再判断当前字符串是否和 s 串的某个字符相等。即 `f(i,j) = f(i - 1, j - 1) && s[i] == p[j]` 。在表格上就是取左上对角的值。
2. 如果  `p[j]` 为 `.` ，则代表 s 串的某个字符无论是什么，都可以匹配。即 `f(i,j) = f(i - 1, j - 1) && p[j] == '.'` 。在表格上就是取左上对角的值。
3.  `p[j]` 为 `*`：必须先读得上一个字符，即 `p[j - 1]` 的字符，例如为字符 a。然后根据 `a*` 实际匹配 `s` 中 `a` 的个数是 0 个 或者多个。

+ 当是 0 个的时候，则这两个字符串没有用，`f[i][j]` 等于 `f[i][j-2]` 。
+ 当是多个的时候，则只需要判断 `s[i]` 和 `p[j-1]` 是否相等，以及在加入 `s[i]` 字符之前的情况，即 `f[i-1][j]`。

---

第 1 点和第 2 点写出代码：

+ `s[i] == p[j]` 相当于普通字符比较相等
+ `p[j] == '.'` 相当于 `p[j]` 是 `.` 字符

```java
if (i - 1 >= 0 && p[j] != '*') {
  f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');
}
```

第 3 点写出代码：

+ 或条件的左边：当 `*` 匹配 0 个字符，直接取 `f[i][j - 2]` 的值
+ 或条件的右边：当 `*` 匹配 多个字符，需要满足两个条件
  + `f[i - 1][j]` ：代表 s 串加上 `s[i]` 之前是否匹配，只有之前匹配了才有机会加多一个字符来看是否匹配 p 串
  + `(s[i] == p[j - 1] || p[j - 1] == '.')` ：判断 `p[j-1]` 与 `s[i]` 是否匹配，若匹配了，则 `f[i][j]` 才匹配。

```java
else if (p[j] == '*') { 
  f[i][j] = (j - 2 >= 0 && f[i][j - 2]) || 
    (i - 1 >= 0 && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.'));
}
```

### （2）详解

动态规划的核心就是填表格。下面假设 s 串为 ` aab ` ，p 串为 `c*a*b ` 。下面是空表。

|       | p    | _    | c    | *    | a    | *    | b    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **s** |      | 0    | 1    | 2    | 3    | 4    | 5    |
| **_** | 0    | √    |      |      |      |      |      |
| **a** | 1    |      |      |      |      |      |      |
| **a** | 2    |      |      |      |      |      |      |
| **b** | 3    |      |      |      |      |      |      |

首先 `s[0]` 和 `p[0]` 都相当于空串，所以可以将 s 串和 p 串前面都加一个空格 `_aab`  、`_c*a*b`

然后 s 串的第一个字符不动， p 串从第二个字符开始循环。

1. 第 2 个字符是 c ，但其后面是 `*` 号，则进入下一个循环
2. 第 3 个字符是 `*` ，由于 s 串是第 1 个字符，无法满足或条件的右边，所以看或条件的左边——去掉 `c*` 两个字符后是否匹配，很明显 `f[0][2] = f[0][0] = true`。所以表格填充成如下：

|       | p    | _    | c    | *    | a    | *    | b    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **s** |      | 0    | 1    | 2    | 3    | 4    | 5    |
| **_** | 0    | √    | x    | √    |      |      |      |
| **a** | 1    |      |      |      |      |      |      |
| **a** | 2    |      |      |      |      |      |      |
| **b** | 3    |      |      |      |      |      |      |

3. 以此类推，得出后面 `a*` 的匹配状态，然后 b 不等于 空串，所以不匹配，则第一行的填表结果如下。

|       | p    | _    | c    | *    | a    | *    | b    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **s** |      | 0    | 1    | 2    | 3    | 4    | 5    |
| **_** | 0    | √    | x    | √    | x    | √    | x    |
| **a** | 1    |      |      |      |      |      |      |
| **a** | 2    |      |      |      |      |      |      |
| **b** | 3    |      |      |      |      |      |      |

4. 然后开始填写第 2 行，s [1] 为 a 字符。a 不等于 p[0] 空串，不匹配；p[1] 的下一个是 `*` 号，则跳过；p[2] 是 `*` 号，然后比较 p[1] 和 s[1] ，p[1]——a 不等于 s[1]——c，所以不匹配。得出下面表格结果。

|       | p    | _    | c    | *    | a    | *    | b    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **s** |      | 0    | 1    | 2    | 3    | 4    | 5    |
| **_** | 0    | √    | x    | √    | x    | √    | x    |
| **a** | 1    | x    | x    | x    |      |      |      |
| **a** | 2    |      |      |      |      |      |      |
| **b** | 3    |      |      |      |      |      |      |

5. 然后看 p[3]，因为 p[4] 是 `*` 号，所以 p[3] 跳过；看 p[4]，是 `*` 号，然后看 p[3] 是否等于 s[1] ，两个都是 a 字符，所以相等；接着看 `f[i-1][j]` 是否匹配，即看该格的上面是否是对勾，`f[0][4]` 是对勾所以 `f[1][4]` 也是对勾。结果如下表所示。

|       | p    | _    | c    | *    | a    | *    | b    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **s** |      | 0    | 1    | 2    | 3    | 4    | 5    |
| **_** | 0    | √    | x    | √    | x    | √    | x    |
| **a** | 1    | x    | x    | x    | x    | √    | x    |
| **a** | 2    |      |      |      |      |      |      |
| **b** | 3    |      |      |      |      |      |      |

6. 然后一点点将表格填写完整，最后得出两个字符串匹配。

|       | p    | _    | c    | *    | a    | *    | b    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **s** |      | 0    | 1    | 2    | 3    | 4    | 5    |
| **_** | 0    | √    | x    | √    | x    | √    | x    |
| **a** | 1    | x    | x    | x    | x    | √    | x    |
| **a** | 2    | x    | x    | x    | x    | √    | x    |
| **b** | 3    | x    | x    | x    | x    | x    | √    |

### （3）总结

动态规划算法不难理解，但需要找到状态如何转移。

全部代码：

```java
public static boolean isMatch(String ss, String pp) {
  // 技巧：往原字符头部插入空格，这样得到 char 数组是从 1 开始，而且可以使得 f[0][0] = true，可以将 true 这个结果滚动下去
  int n = ss.length(), m = pp.length();
  ss = " " + ss;
  pp = " " + pp;

  // 将字符串转化为字符数组
  char[] s = ss.toCharArray();
  char[] p = pp.toCharArray();

  // f(i,j) 代表 s 中的 1~i 字符和 p 中的 1~j 字符 是否匹配
  boolean[][] f = new boolean[n + 1][m + 1];

  // 初始化第1个数
  f[0][0] = true;

  for (int i = 0; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      // 如果下一个字符是 '*'，则代表当前字符不能被单独使用，跳过
      if (j + 1 <= m && p[j + 1] == '*')
        continue;

      // 对应了 p[j] 为普通字符和 '.' 的两种情况
      if (i - 1 >= 0 && p[j] != '*') {
        f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');
      }

      // 对应了 p[j] 为 '*' 的情况，一种情况是不看这两个字符，另一种是看p[j-1]与s[i]是否相等
      else if (p[j] == '*') {
        f[i][j] = (j - 2 >= 0 && f[i][j - 2])
          || (i - 1 >= 0 && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.'));
      }
    }
  }
  return f[n][m];
}
```

## 二、回文数

原文链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484130&idx=2&sn=4bc0ec832d90ca5cf6dbdea95560d6a9&chksm=fd9ca9fdcaeb20ebe1c29592afb103ee4120ea5aa32c1036d5f3142757c8a2431705ef2e6b57&scene=178&cur_album_id=1715134171561410565#rd

 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 

示例 1:

+ 输入: 121 

+ 输出: true

示例 2:

+ 输入: -121 
+ 输出: false
+ 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

示例 3:

+ 输入: 10 
+ 输出: false
+ 解释: 从右向左读, 为 01 。因此它不是一个回文数。

### （1）略解

最简单的一种解法就是将数字转换为字符串，然后跟原来的进行比较。

```java
class Solution {
  public boolean isPalindrome(int x) {
    String s = String.valueOf(x);
    StringBuilder sb = new StringBuilder(s);
    sb.reverse();
    return sb.toString().equals(s);
  }
}
```

另一种非字符串解法，就是 **让数字完全翻转**。新的整数的数字是从旧的整数的个位开始的。

+ 第 3 行：如果是负数，其必不是回文数
+ 第 4 行：原来的是 `int` 数据类型，其范围为 -2^31^ (-2147483648) ~ 2^31^-1 (2147483647) ，如果反转了，有溢出风险，所以使用 `long` 数据类型。 2^64^ (-9223372036854775808)~ 2^64^-1(9223372036854775807) 
+ 第 6 ~ 9 行：然后不断的对 x 取余得出个位数，然后将反转的数左移（乘10）并加上个位数。

```java
class Solution {
  public boolean isPalindrome(int x) {
    if (x < 0) return false;
    long ans = 0;
    int t = x;
    while (x > 0) {
      ans = ans * 10 + x % 10;
      x /= 10;
    }
    return ans - t == 0;
  }
}
```

如果不能使用 `long` 数据类型的话，则需要使用到回文数的特性，左右部分相等。收集右半部分和反转整数一个思路。

+ 第 4 行：如果是负数或者末尾是 0 的话，肯定不是回文数。
+ 第 6 行： x 是否大于 t 来作为左右分隔的条件，这样不用计左右部分数字的个数，不过可能会导致 t 的数字个数会比 x 的数字个数 **多一位**。
+ 第 12 行：判断的时候不仅要比较 x 和 t，还要比较 x 和去掉一位的 t 。

```java
class Solution {
  public boolean isPalindrome(int x) {
    // 对于 负数 和 x0、x00、x000 格式的数，直接返回 flase
    if (x < 0 || (x % 10 == 0 && x != 0)) return false;
    int t = 0;
    while (x > t) {
      t = t * 10 + x % 10;
      x /= 10;
    }
    // 回文长度的两种情况：直接比较 & 忽略中心点（t 的最后一位）进行比较
    return x == t || x == t / 10;
  }
}
```

## 三、工程模拟题

原题链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484130&idx=3&sn=9b23784134bdce0cc003b9b28d273e7f&chksm=fd9ca9fdcaeb20eb0faa62eb5543208f2152147b4c3369824f0a2e87d0fb56553ba8f66d11b1&cur_album_id=1715134171561410565&scene=189#wechat_redirect

> 请你来实现一个 atoi 函数，使其能将字符串转换成整数。
>
> 首先，该函数会根据需要丢弃无用的开头空格字符。
>
> 接下来的转化规则如下：
>
> - 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
> - 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
> - 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
>
> 假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。
>
> 在任何情况下，若函数不能进行有效的转换时，请返回 0 。
>
> 提示：
>
> - `0 <= s.length <= 200`
> - `s` 由英文字母（大写和小写）、数字、`' '`、`'+'`、`'-'` 和 `'.'` 组成

示例 1：

+ 输入: "42" 
+ 输出: 42

示例 2：

+ 输入: "-42" 
+ 输出: -42
+ 解释: 第一个非空白字符为 ' - '，它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42。

示例 3：

+ 输入：" 4193ssss "

+ 输出: 4193
+ 解释: 转换截止于数字 ' 3 ' ，因为它的下一个字符不为数字

示例 4：

+ 输入：“ w3029 ” 

+ 输出: 0
+ 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。因此无法执行有效的转换

示例 5:

+ 输入: "-91283472332" 
+ 输出: -2147483648
+ 解释: 数字 `"-91283472332"` 超过 32 位有符号整数范围。 因此返回 `INT_MIN (−231)` 

### （1）略解

首先对题目进行分析：

1. 去掉字符串的前导空格
2. 第一个字符只能是 `-` 、`+` 和 数字
3. 然后继续向后匹配字符，直到遇到非数字字符。其过程需要注意数字是否越界。

下面为代码：

+ 第 11 ~ 16 行：去掉字符串的前导空格
+ 第 18 ~ 28 行：判断第一个字符
+ 第 30 ~ 41 行：判断当前数字是否超过最大值，不能直接将当前数字与 `Integer.MAX_VALUE` 比较，因为如果当前数字超过最大值会程序报错，不会进行比较。所以需要将思维逆转，将  `Integer.MAX_VALUE` 降一位再进行比较。
  `ans * 10 + cur > Integer.MAX_VALUE 相当于 ans > Integer.MAX_VALUE - cur / 10`

```java
class Solution {
  public int myAtoi(String s) {
    // n 代表整个字符的长度
    int n = s.length();
    
    char[] chars = s.toCharArray();
    
    // 当前取到的字符的下标
    int idx = 0;       

    // 去除前导空格，如果去完前导空格后无字符了，返回 0
    // 不断地将下标移动到后面，直到遇到不是空格为止
    while (idx < n && chars[idx] == ' '){
      idx++;
    }
    if (idx == n) return 0;

    // 检查第一个字符：可以为正负号/数字
    // isNeg代表该数是负数
    boolean isNeg = false;
    if (chars[idx] == '-') {
      idx++;
      isNeg = true;
    } else if (chars[idx] == '+') {
      idx++;
    } else if (!Character.isDigit(chars[idx])) {
      return 0;
    } 

    int ans = 0;
    while (idx < n && Character.isDigit(chars[idx])) {
      // 将当前的字符转换为数字
      int cur = chars[idx++] - '0';
      // 防止 ans = ans * 10 + cur 溢出
      // 等价变形为 ans > (Integer.MAX_VALUE - cur) / 10 进行预判断
      if (ans > (Integer.MAX_VALUE - cur) / 10) {
        // 如果是负数则返回最小值，否则返回最大值
        return isNeg ? Integer.MIN_VALUE : Integer.MAX_VALUE;
      }
      ans = ans * 10 + cur;
    }
    // 返回最终结果数字
    return isNeg ? -ans : ans;
  }
}
```

## 四、Z字形变换

原题链接：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484130&idx=4&sn=9dee24011b1ff7814aac348d94c00460&chksm=fd9ca9fdcaeb20eb81af16d22fdfb514e9e7bd75cd5af07da157a51275e97223c265240ae6b6&cur_album_id=1715134171561410565&scene=189#wechat_redirect

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以 **先从上往下**、**再从左到右** 进行 `Z` 字形排列。

比如输入字符串为 `PAYPALISHIRING` 行数为 3 时，排列如下。然后 **先从左到右**、**再从上往下**，组成一个新的字符串，`PAHNAPLSIIGYIR` 。

```
P     A     H     N
A  P  L  S  I  I  G
Y     I     R  
```

请你实现这个将字符串进行指定行数变换的函数：`String convert(string s, int numRows)` ；

+ 输入：s = `PAYPALISHIRING`, numRows = 4 
+ 输出：`PINALSIGYAHRPI`
+ 解释：

```
P       I       N
A    L  S    I  G
Y  A    H  R
P       I 
```

### （1）略解

第一种解法就是直接计算每一个字符的偏移量，很直接，但比较麻烦。

1. 每个字符到达下一个字符，会有两种方向，从上到下，或者从下到上。例如第 2 行，从 A 到 L，从下到上，经过 YPA 三个字符；从 L 到 S ，从上到下，经过 I 一个字符。
2. 需要计算不同行的两个方向所经过的字符数。除了第 1 行和最后 1 行，因为这两行的偏移量不会变。

每下面一行，两个相邻的字符的上面都会同时多出一个字符。即原来的从上到下偏移量 + 2，从下到上的偏移量，也是如此。所以 `当前偏移量 = 当前行数 * 2 - 1`

| 行数 | 从上到下的字符数 | 从下到上的字符数 |
| ---- | ---------------- | ---------------- |
| 2    | 1                | 3                |
| 3    | 3                | 1                |

```
P       I       N
A    L  S    I  G
Y  A    H  R
P       I 
```

3. 然后因为当前字符的下一个字符的方向都不一致，所以需要定义一个标记来进行反转方向。

---

下面为具体代码：

1. 第 11 ~ 18 行：对象第 1 行和最后 1 行，偏移量是固定的，都是 `(总行数 - 1) * 2 - 1`
2. 第 25 ~ 33 行：算出两个方向的偏移量
3. 第 35 ~ 41 行：轮流加上两个方向的偏移量就可以取到正确的字符

```java
public static String convert(String s, int r) {
  // n代表字符串的长度
  int n = s.length();

  // 如果字符串只有1个字符或者只有排列1行，则直接返回原字符串
  if (n == 1 || r == 1)
    return s;

  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < r; i++) {
    // 对于第1行和最后1行，偏移量是固定的
    if (i == 0 || i == r - 1) {
      int j = i;
      int rowOffset = (r - 1) * 2 - 1;
      while (j < n) {
        sb.append(s.charAt(j));
        j += rowOffset + 1;
      }
    } else {
      // 对于其他行，需要获取到当前字符到下一个字符的偏移量
      // 到下一个字符有2个方向，一个是从当前字符向上然后向下
      // 另一个是从当前字符向下然后向上
      int j = i;

      // 获取当前行是正数第几行
      int topRow = i;
      // 算出从当前字符向上到向下需要跨过多少字符
      int topOffset = topRow * 2 - 1;

      // 获取当前行是倒数第几行
      int bottomRow = r - i - 1;
      // 算出从当前字符向下到向上需要跨过多少字符
      int bottomOffset = bottomRow * 2 - 1;

      // 因为方向每次都需要反转，所以需要设置标记
      boolean flag = true;
      while (j < n) {
        sb.append(s.charAt(j));
        j += flag ? bottomOffset + 1 : topOffset + 1;
        flag = !flag;
      }
    }
  }
  return sb.toString();
}
```

### （2）略解2

我们可以找规律直接算出下一个字符的下标。

+ 对于第 1 行：P——0；I——6；N——12。首项为 0，公差为 6 —— 2 * ( r - 1 )

+ 对于最后 1 行：P——3；I——9。首项为 r-1，公差为 6 —— 2 * ( r - 1 )

```
P       I       N
A    L  S    I  G
Y  A    H  R
P       I 
```

然后找中间行的规律：

+ 对于第 2 行：A——1；L——5；S——7；I——11；G——13
+ 对于第 3 行：Y——2；A——4；H——8；R——10

根据第 1 点的题解可以知道下一个字符有两个方向，在数学方面就是 **等差数列交替排列**。

可以看到第 2 行： 1(A) + 6 = 7(S) ；7(S) + 6 = 13(G)。5(L) + 6 = 11(I)。

第 3 行：2(Y) + 6 = 8(H) 。4(A) + 6 = 10(R)

两个等差数列的公差都是 6，即 2 * ( r - 1 )，然后就要计算出两个等差数列的首项。

+ 第 1 个等差数列很明显首项是 i
+ 第 2 个等差数列的首先需要计算一下：第 1 行的第 2 个字符（I）的下标是 2r - 2 ，而第 2 个等差数列的首项字符下标是在该基础上退后 i 个字符 ，例如第 2 行，回退 1 个字符（L）。所以得出第 2 个等差数列的首项是 `2 * r - i - 2`

得出下面代码：

```java
public String convert(String s, int r) {
  // n为s字符串的长度
  int n = s.length();
  if (n == 1 || r == 1) return s;

  StringBuilder sb = new StringBuilder();
  
  // 对每一行进行遍历
  for (int i = 0; i < r; i++) {
    // 第1行和最后1行的情况
    if (i == 0 || i == r - 1) {
      int pos = i;
      // 计算出偏移量
      int offset = 2 * (r - 1);
      while (pos < n) {
        sb.append(s.charAt(pos));
        pos += offset;
      }
    } else {
      // 得出两个等差数列的首项
      int pos1 = i, pos2 = 2 * r - i - 2;
      // 得出两个等差数列的公差
      int offset = 2 * (r - 1);
      
      // 当两个下标都同时超出字符串长度，证明已经到当前行的末尾
      while (pos1 < n || pos2 < n) {
        if (pos1 < n) {
          sb.append(s.charAt(pos1));
          pos1 += offset;
        }
        if (pos2 < n) {
          sb.append(s.charAt(pos2));
          pos2 += offset;
        }
      }
    }
  }
  return sb.toString();
}

```

## 五、找出两个数组合并后的中位数

```java
class Solution {
  public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int tot = nums1.length + nums2.length;
    if (tot % 2 == 0) {
      int left = find(nums1, 0, nums2, 0, tot / 2);
      int right = find(nums1, 0, nums2, 0, tot / 2 + 1);
      return (left + right) / 2.0;
    } else {
      return find(nums1, 0, nums2, 0, tot / 2 + 1);
    }
  }
  int find(int[] n1, int i, int[] n2, int j, int k) {
    if (n1.length - i > n2.length - j) return find(n2, j, n1, i, k);
    if (i >= n1.length) return n2[j + k - 1];
    if (k == 1) {
      return Math.min(n1[i], n2[j]);
    } else {
      int si = Math.min(i + (k / 2), n1.length), sj = j + k - (k / 2);
      if (n1[si - 1] > n2[sj - 1]) {
        return find(n1, i, n2, sj, k - (sj - j));
      } else {
        return find(n1, si, n2, j, k - (si - i));
      }
    }
  }
}
```

