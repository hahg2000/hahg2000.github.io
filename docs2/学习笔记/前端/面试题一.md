# Vue面试题一

转载链接：https://github.com/sudheerj/vuejs-interview-questions#what-is-vuejs

## 一、什么是Vue

答：Vue.js 是一个开源的、渐进式框架，用于构建增量型的用户界面。Vue.js 专注于视图图层 `view layer` ，并易于与现有的项目和其他框架集成。

英文原文：

**Vue.js** is an open-source, progressive Javascript framework for building user interfaces that aim to be incrementally adoptable. The core library of VueJS is focused on the `view layer` only, and is easy to pick up and integrate with other libraries or existing projects. 

## 二、Vue的主要特点是什么？

以下是 Vue.js 的一些主要特点：

1. **Virtual DOM：** 使用类似于 React.js、Ember 等框架的虚拟 DOM。Virtual DOM 是原始 HTML DOM 的轻量级内存树表示，并且在不影响原始 DOM 的情况下进行更新节点。
2. **组件：** 在 Vue.js 的应用程序中创建可重用的自定义元素。
3. **模板：** Vue.js 提供基于 HTML 的模板，将 DOM 与 Vue 实例数据绑定
4. **路由：**页面之间的导航通过 vue-router 来实现的
5. **轻量级：**与其他框架相比，Vue.js 是轻量级的库

英文原文：Below are the some of major features available with VueJS

1. **Virtual DOM:** It uses virtual DOM similar to other existing frameworks such as ReactJS, Ember etc. Virtual DOM is a light-weight in-memory tree representation of the original HTML DOM and updated without affecting the original DOM.
2. **Components:** Used to create reusable custom elements in VueJS applications.
3. **Templates:** VueJS provides HTML based templates that bind the DOM with the Vue instance data
4. **Routing:** Navigation between pages is achieved through vue-router
5. **Light weight:** VueJS is light weight library compared to other frameworks.

## 三、Vue.js 的生命周期方法有哪些？

大致分为四个大部分：

+ 创建部分： 在组件被添加到 DOM 之前。
  + `beforeCreate` ：数据还不是响应式的
  + `created` ：数据变为响应式的，但模板和 DOM 没有挂载，无法通过访问 `this.$el` 来获取组件 
+ 挂载部分（插入 DOM）： 可以在第一次挂载之前和之后访问组件 
  + `beforeMount` ：挂载之前触发，`this.$el` 无法访问
  + `Mounted` ：挂载之后触发，可以访问任何东西
+ 更新部分：触发于组件使用的响应式属性改变或者其他原因导致组件重新渲染
  + `beforeUpdate` ：数据更新之后，重新渲染之前
  + `updated` ：渲染页面完成之后
+ 销毁部分：
  + `beforeDestroy` ：用于清理事件和响应式订阅
  + `destroyed` ：解除绑定指令，移除了事件监听

英文原文：https://github.com/sudheerj/vuejs-interview-questions#what-are-the-lifecycle-methods-of-vuejs

## 四、有哪些条件指令？

+ `v-if`
+ `v-else-if`
+ `v-else`
+ `v-show`

英文原文：

## 五、v-show和v-if区别

1. 显示方式不同：v-if 切换是改变 DOM 渲染，v-show 切换是改变 CSS 的 `display` 来切换显示
2. 切换显示成本不同：v-if 花费成本更高，v-show 成本更低
3. 配套指令不同：v-if 可以使用 v-else-if 和 v-else 
4.  v-if 支持 `<template>` ，而 v-show 不支持

英语原文：Below are some of the main differences between **v-show** and **v-if** directives,

1. v-if only renders the element to the DOM if the expression passes whereas v-show renders all elements to the DOM and then uses the CSS display property to show/hide elements based on expression.
2. v-if supports v-else and v-else-if directives whereas v-show doesn't support else directives.
3. v-if has higher toggle costs while v-show has higher initial render costs. i.e, v-show has a performance advantage if the elements are switched on and off frequently, while the v-if has the advantage when it comes to initial render time.
4. v-if supports ` tab but v-show doesn't support.

## 六、v-for 指令的作用是什么？

答：遍历数组和对象里的元素

+ 数组用法：`( item, index ) in array`
+ 对象用法：`( value, key, index) of object`

英文原文：

## 七、什么是Vue实例

答： 每个 Vue 应用程序都通过使用 Vue 函数创建 Vue 的实例来工作。通常变量 vm（ViewModel 的缩写）用于引用 Vue 实例。您可以如下创建 vue 实例。

```js
const vm = new Vue({
  // option
})
```

## 八、如何实现有条件地显示一组元素

两个方法：

+ 一个是 `<template>` 与 `v-if` 一起使用

```html
<template v-if="condition">
  <h1>Name</h1>
  <p>Address</p>
  <p>Contact Details</p>
</template>
```

+ 另一个是 `<div>` 与 `v-show`

英语原文：https://github.com/sudheerj/vuejs-interview-questions#how-do-you-achieve-conditional-group-of-elements

## 九、如何使用key属性

在下面的代码中，会发现文本框的值会复用，在许多场合不应该这样做。所以要在不需要复用的组件，添加 key 属性，这样 Vue 就会区别出这些文本框。

::: vue-demo 文本框复用

```vue
<template v-if="loginType === 'Admin'">
<label>Admin</label>
<input placeholder="Enter your ID" type="password">
</template>
<template v-else>
<label>Guest</label>
<input placeholder="Enter your name" disabled >
</template>

<script>
  export default {
    data() {
      return {
        message: 'Hello Vue!',
        isShow: false,
      }
    },
    methods: {
      changeShow() {
        this.isShow = !this.isShow
      },
    },
  };
</script>
```

:::

## 十、为什么不应该在同一个元素上同时使用 if 和 for 指令？

 建议不要在与 v-for 相同的元素上使用 v-if。因为 v-for 指令的优先级高于 v-if 。所以 vue 在 v-for 渲染出所有列表选项后再执行 v-if 指令。

例如下面代码：在渲染出了 users 数组后，再判断每一项的 isActive 属性看是否显示出来。

```html
<ul>
  <li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```

正确的写法是使用计算属性把需要的数据筛选出来，再使用 v-for 渲染。这样写的好处：

- 使用 `v-for="user in activeUsers"` 之后，我们在渲染的时候只遍历活跃用户，渲染更高效。
- 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。

```html
<ul>
  <li
      v-for="user in activeUsers"
      :key="user.id"
      >
    {{ user.name }}
  </li>
</ul>

<script>
  computed: {
    activeUsers: function () {
      return this.users.filter(function (user) {
        return user.isActive
      })
    },
  },
</script>
```

还有一个是使用另一个变量来控制 v-for 渲染，例如下面代码，使用 shouldShowUsers 变量来控制是否渲染 v-for 的结果。

```html
<ul>
  <li
    v-for="user in users"
    v-if="shouldShowUsers"
    :key="user.id"
  >
    {{ user.name }}
  </li>
</ul>
```

正确的方式是将 v-if 提取到父元素，这样就不会去渲染 v-for 的结果。

```html
<ul v-if="shouldShowUsers">
  <li
      v-for="user in users"
      :key="user.id"
      >
    {{ user.name }}
  </li>
</ul>
```

## 十一、为什么需要在 for 指令上使用 key 属性？

 为了跟踪每个节点的身份，从而重用和重新排序现有元素。

## 十二、突变方法有哪些？

1. push() —— 在数组最后面添加元素
2. pop() —— 在数组最后面删除元素
3. shift() —— 删除数组最前面的元素
4. unshift() —— 在数组最前面添加元素
5. splice() —— 通过删除或替换现有元素或者原地添加新的元素来修改数组 
6. sort() —— 对数组的元素进行排序 
7. reverse() ——颠倒数组里的元素

正是因为这些方法原来是直接改变原数组，所以 vue.js 在原来的功能上加上了视图更新

## 十三、非突变方法有哪些？

1. filter() —— 根据条件返回一个新数组
2. concat() —— 连接多个数组后返回一个新数组
3. slice() —— 截取部分数组返回一个新数组、

因为总是返回一个新数组，所以 vue.js 不会视图更新

## 十四、关于突变方法有哪些注意事项？

如果不用突变方法，下面两个修改数组的方式不会引起界面更新

1. 使用下标改变对应的值
2. 直接修改数组长度

对于第 1 种方式可以用下面方式代替：

```js
// Vue.set() 方法
Vue.set(vm.todos, indexOfTodo, newTodoValue)

// Array.prototype.splice() 方法
// 从indexOfTodo开始删除1个元素，再添加newTodoValue
vm.todos.splice(indexOfTodo, 1, newTodoValue)
```

对于第 2 种方式：

```js
vm.todos.splice(todosLength);
```

对于对象没有如果不用突变方法，添加或者删除对象中的属性都不会引起界面更新，例如下面代码。

```js
var vm = new Vue({
  data: {
    user: {
      name: 'John'
    }
  }
})

// 添加属性不会引起界面更新
vm.user.email = john@email.com
```

您可以使用 Vue.set(object, key, value) 方法或 Object.assign() 来克服这种情况，

```
Vue.set(vm.user, 'email', 'john@email.com');
// (or)
vm.user = Object.assign({}, vm.user, {
  email: john@email.com
})
```